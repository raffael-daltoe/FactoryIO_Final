
TP3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005cf4  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000c90  08005db4  08005db4  00015db4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08006a44  08006a44  00016a44  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08006a48  08006a48  00016a48  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000018  20000000  08006a4c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000034c8  20000018  08006a64  00020018  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  200034e0  08006a64  000234e0  2**0
                  ALLOC
  8 .ARM.attributes 00000028  00000000  00000000  00020018  2**0
                  CONTENTS, READONLY
  9 .comment      00000043  00000000  00000000  00020040  2**0
                  CONTENTS, READONLY
 10 .debug_info   00015922  00000000  00000000  00020083  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00002439  00000000  00000000  000359a5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loclists 0000c1c1  00000000  00000000  00037dde  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00000838  00000000  00000000  00043fa0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 000019b9  00000000  00000000  000447d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  0000200a  00000000  00000000  00046191  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   0001763f  00000000  00000000  0004819b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    000731cd  00000000  00000000  0005f7da  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  00001884  00000000  00000000  000d29a8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 0000004f  00000000  00000000  000d422c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000018 	.word	0x20000018
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08005d9c 	.word	0x08005d9c

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	2000001c 	.word	0x2000001c
 8000104:	08005d9c 	.word	0x08005d9c

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f806 	bl	800021c <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__aeabi_idiv0>:
 800021c:	4770      	bx	lr
 800021e:	46c0      	nop			; (mov r8, r8)

08000220 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000220:	0003      	movs	r3, r0
 8000222:	3308      	adds	r3, #8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000224:	2201      	movs	r2, #1
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000226:	6043      	str	r3, [r0, #4]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000228:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800022a:	6103      	str	r3, [r0, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800022c:	2300      	movs	r3, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 800022e:	4252      	negs	r2, r2
 8000230:	6082      	str	r2, [r0, #8]
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000232:	6003      	str	r3, [r0, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8000234:	4770      	bx	lr
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8000238:	2300      	movs	r3, #0
 800023a:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800023c:	4770      	bx	lr
 800023e:	46c0      	nop			; (mov r8, r8)

08000240 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
 8000240:	6843      	ldr	r3, [r0, #4]

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000242:	689a      	ldr	r2, [r3, #8]
    pxNewListItem->pxNext = pxIndex;
 8000244:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000246:	608a      	str	r2, [r1, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 8000248:	689a      	ldr	r2, [r3, #8]
 800024a:	6051      	str	r1, [r2, #4]
    pxIndex->pxPrevious = pxNewListItem;
 800024c:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 800024e:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 8000250:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 8000252:	3301      	adds	r3, #1
 8000254:	6003      	str	r3, [r0, #0]
}
 8000256:	4770      	bx	lr

08000258 <vListInsert>:
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000258:	0003      	movs	r3, r0
{
 800025a:	b530      	push	{r4, r5, lr}
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800025c:	680d      	ldr	r5, [r1, #0]
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800025e:	3308      	adds	r3, #8
    if( xValueOfInsertion == portMAX_DELAY )
 8000260:	1c6a      	adds	r2, r5, #1
 8000262:	d00d      	beq.n	8000280 <vListInsert+0x28>
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000264:	001c      	movs	r4, r3
 8000266:	685b      	ldr	r3, [r3, #4]
 8000268:	681a      	ldr	r2, [r3, #0]
 800026a:	42aa      	cmp	r2, r5
 800026c:	d9fa      	bls.n	8000264 <vListInsert+0xc>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 800026e:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000270:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 8000272:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxPrevious = pxIterator;
 8000274:	608c      	str	r4, [r1, #8]
    ( pxList->uxNumberOfItems )++;
 8000276:	3301      	adds	r3, #1
    pxIterator->pxNext = pxNewListItem;
 8000278:	6061      	str	r1, [r4, #4]
    pxNewListItem->pxContainer = pxList;
 800027a:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 800027c:	6003      	str	r3, [r0, #0]
}
 800027e:	bd30      	pop	{r4, r5, pc}
        pxIterator = pxList->xListEnd.pxPrevious;
 8000280:	6904      	ldr	r4, [r0, #16]
    pxNewListItem->pxNext = pxIterator->pxNext;
 8000282:	6863      	ldr	r3, [r4, #4]
 8000284:	e7f3      	b.n	800026e <vListInsert+0x16>
 8000286:	46c0      	nop			; (mov r8, r8)

08000288 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 8000288:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800028a:	6841      	ldr	r1, [r0, #4]
 800028c:	6882      	ldr	r2, [r0, #8]
 800028e:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000290:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 8000292:	6859      	ldr	r1, [r3, #4]
 8000294:	4281      	cmp	r1, r0
 8000296:	d006      	beq.n	80002a6 <uxListRemove+0x1e>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 8000298:	2200      	movs	r2, #0
 800029a:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 800029c:	681a      	ldr	r2, [r3, #0]
 800029e:	3a01      	subs	r2, #1
 80002a0:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 80002a2:	6818      	ldr	r0, [r3, #0]
}
 80002a4:	4770      	bx	lr
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 80002a6:	605a      	str	r2, [r3, #4]
 80002a8:	e7f6      	b.n	8000298 <uxListRemove+0x10>
 80002aa:	46c0      	nop			; (mov r8, r8)

080002ac <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 80002ac:	b570      	push	{r4, r5, r6, lr}
 80002ae:	0016      	movs	r6, r2

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80002b0:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 80002b2:	0004      	movs	r4, r0
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80002b4:	6b85      	ldr	r5, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80002b6:	2a00      	cmp	r2, #0
 80002b8:	d106      	bne.n	80002c8 <prvCopyDataToQueue+0x1c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80002ba:	6806      	ldr	r6, [r0, #0]
 80002bc:	2e00      	cmp	r6, #0
 80002be:	d028      	beq.n	8000312 <prvCopyDataToQueue+0x66>
 80002c0:	3501      	adds	r5, #1
    BaseType_t xReturn = pdFALSE;
 80002c2:	2000      	movs	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80002c4:	63a5      	str	r5, [r4, #56]	; 0x38

    return xReturn;
}
 80002c6:	bd70      	pop	{r4, r5, r6, pc}
    else if( xPosition == queueSEND_TO_BACK )
 80002c8:	2e00      	cmp	r6, #0
 80002ca:	d10e      	bne.n	80002ea <prvCopyDataToQueue+0x3e>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80002cc:	6840      	ldr	r0, [r0, #4]
 80002ce:	f005 fd5b 	bl	8005d88 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80002d2:	6863      	ldr	r3, [r4, #4]
 80002d4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80002d6:	189b      	adds	r3, r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80002d8:	68a2      	ldr	r2, [r4, #8]
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80002da:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80002dc:	4293      	cmp	r3, r2
 80002de:	d3ef      	bcc.n	80002c0 <prvCopyDataToQueue+0x14>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80002e0:	6823      	ldr	r3, [r4, #0]
    BaseType_t xReturn = pdFALSE;
 80002e2:	2000      	movs	r0, #0
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80002e4:	6063      	str	r3, [r4, #4]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80002e6:	3501      	adds	r5, #1
 80002e8:	e7ec      	b.n	80002c4 <prvCopyDataToQueue+0x18>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 80002ea:	68c0      	ldr	r0, [r0, #12]
 80002ec:	f005 fd4c 	bl	8005d88 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80002f0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80002f2:	68e3      	ldr	r3, [r4, #12]
 80002f4:	4251      	negs	r1, r2
 80002f6:	1a9b      	subs	r3, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80002f8:	6822      	ldr	r2, [r4, #0]
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80002fa:	60e3      	str	r3, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80002fc:	4293      	cmp	r3, r2
 80002fe:	d202      	bcs.n	8000306 <prvCopyDataToQueue+0x5a>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8000300:	68a3      	ldr	r3, [r4, #8]
 8000302:	185b      	adds	r3, r3, r1
 8000304:	60e3      	str	r3, [r4, #12]
        if( xPosition == queueOVERWRITE )
 8000306:	2e02      	cmp	r6, #2
 8000308:	d1da      	bne.n	80002c0 <prvCopyDataToQueue+0x14>
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800030a:	2d00      	cmp	r5, #0
 800030c:	d1d9      	bne.n	80002c2 <prvCopyDataToQueue+0x16>
 800030e:	3501      	adds	r5, #1
 8000310:	e7d7      	b.n	80002c2 <prvCopyDataToQueue+0x16>
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8000312:	6880      	ldr	r0, [r0, #8]
 8000314:	f001 ffd0 	bl	80022b8 <xTaskPriorityDisinherit>
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000318:	3501      	adds	r5, #1
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800031a:	60a6      	str	r6, [r4, #8]
 800031c:	e7d2      	b.n	80002c4 <prvCopyDataToQueue+0x18>
 800031e:	46c0      	nop			; (mov r8, r8)

08000320 <xQueueGenericCreate>:
    {
 8000320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000322:	0004      	movs	r4, r0
 8000324:	000d      	movs	r5, r1
 8000326:	0016      	movs	r6, r2
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8000328:	2800      	cmp	r0, #0
 800032a:	d101      	bne.n	8000330 <xQueueGenericCreate+0x10>
 800032c:	b672      	cpsid	i
 800032e:	e7fe      	b.n	800032e <xQueueGenericCreate+0xe>
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000330:	000f      	movs	r7, r1
 8000332:	4347      	muls	r7, r0
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
 8000334:	2900      	cmp	r1, #0
 8000336:	d110      	bne.n	800035a <xQueueGenericCreate+0x3a>
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8000338:	0038      	movs	r0, r7
 800033a:	3050      	adds	r0, #80	; 0x50
 800033c:	f002 fb50 	bl	80029e0 <pvPortMalloc>
        if( pxNewQueue != NULL )
 8000340:	2800      	cmp	r0, #0
 8000342:	d11e      	bne.n	8000382 <xQueueGenericCreate+0x62>
            traceQUEUE_CREATE_FAILED( ucQueueType );
 8000344:	f002 fbec 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000348:	f002 fba4 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 800034c:	4b47      	ldr	r3, [pc, #284]	; (800046c <xQueueGenericCreate+0x14c>)
 800034e:	2700      	movs	r7, #0
 8000350:	881b      	ldrh	r3, [r3, #0]
 8000352:	4203      	tst	r3, r0
 8000354:	d10d      	bne.n	8000372 <xQueueGenericCreate+0x52>
    }
 8000356:	0038      	movs	r0, r7
 8000358:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
 800035a:	0038      	movs	r0, r7
 800035c:	f7ff fed4 	bl	8000108 <__udivsi3>
 8000360:	42a0      	cmp	r0, r4
 8000362:	d001      	beq.n	8000368 <xQueueGenericCreate+0x48>
 8000364:	b672      	cpsid	i
 8000366:	e7fe      	b.n	8000366 <xQueueGenericCreate+0x46>
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
 8000368:	003b      	movs	r3, r7
 800036a:	3351      	adds	r3, #81	; 0x51
 800036c:	d975      	bls.n	800045a <xQueueGenericCreate+0x13a>
 800036e:	b672      	cpsid	i
 8000370:	e7fe      	b.n	8000370 <xQueueGenericCreate+0x50>
            traceQUEUE_CREATE_FAILED( ucQueueType );
 8000372:	4b3f      	ldr	r3, [pc, #252]	; (8000470 <xQueueGenericCreate+0x150>)
 8000374:	2100      	movs	r1, #0
 8000376:	5d98      	ldrb	r0, [r3, r6]
 8000378:	3040      	adds	r0, #64	; 0x40
 800037a:	b2c0      	uxtb	r0, r0
 800037c:	f003 fbea 	bl	8003b54 <prvTraceStoreKernelCallWithNumericParamOnly>
 8000380:	e7e9      	b.n	8000356 <xQueueGenericCreate+0x36>
        if( pxNewQueue != NULL )
 8000382:	0007      	movs	r7, r0
 8000384:	6038      	str	r0, [r7, #0]
    pxNewQueue->uxLength = uxQueueLength;
 8000386:	63fc      	str	r4, [r7, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 8000388:	643d      	str	r5, [r7, #64]	; 0x40
    taskENTER_CRITICAL();
 800038a:	f002 fa91 	bl	80028b0 <vPortEnterCritical>
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800038e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8000390:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000392:	683a      	ldr	r2, [r7, #0]
 8000394:	434b      	muls	r3, r1
 8000396:	18d0      	adds	r0, r2, r3
 8000398:	60b8      	str	r0, [r7, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800039a:	2000      	movs	r0, #0
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800039c:	1a5b      	subs	r3, r3, r1
        pxQueue->pcWriteTo = pxQueue->pcHead;
 800039e:	607a      	str	r2, [r7, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80003a0:	18d2      	adds	r2, r2, r3
 80003a2:	60fa      	str	r2, [r7, #12]
        pxQueue->cRxLock = queueUNLOCKED;
 80003a4:	23ff      	movs	r3, #255	; 0xff
 80003a6:	2244      	movs	r2, #68	; 0x44
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80003a8:	63b8      	str	r0, [r7, #56]	; 0x38
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80003aa:	0038      	movs	r0, r7
        pxQueue->cRxLock = queueUNLOCKED;
 80003ac:	54bb      	strb	r3, [r7, r2]
        pxQueue->cTxLock = queueUNLOCKED;
 80003ae:	3201      	adds	r2, #1
 80003b0:	54bb      	strb	r3, [r7, r2]
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80003b2:	3010      	adds	r0, #16
 80003b4:	f7ff ff34 	bl	8000220 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80003b8:	0038      	movs	r0, r7
 80003ba:	3024      	adds	r0, #36	; 0x24
 80003bc:	f7ff ff30 	bl	8000220 <vListInitialise>
    taskEXIT_CRITICAL();
 80003c0:	f002 fa82 	bl	80028c8 <vPortExitCritical>
            pxNewQueue->ucQueueType = ucQueueType;
 80003c4:	234c      	movs	r3, #76	; 0x4c
    traceQUEUE_CREATE( pxNewQueue );
 80003c6:	0038      	movs	r0, r7
            pxNewQueue->ucQueueType = ucQueueType;
 80003c8:	54fe      	strb	r6, [r7, r3]
    traceQUEUE_CREATE( pxNewQueue );
 80003ca:	f002 fb59 	bl	8002a80 <prvTraceGetQueueType>
 80003ce:	4c28      	ldr	r4, [pc, #160]	; (8000470 <xQueueGenericCreate+0x150>)
 80003d0:	5c20      	ldrb	r0, [r4, r0]
 80003d2:	f004 f979 	bl	80046c8 <prvTraceGetObjectHandle>
 80003d6:	b281      	uxth	r1, r0
 80003d8:	0038      	movs	r0, r7
 80003da:	f002 fb87 	bl	8002aec <prvTraceSetQueueNumberLow16>
 80003de:	4b25      	ldr	r3, [pc, #148]	; (8000474 <xQueueGenericCreate+0x154>)
 80003e0:	0038      	movs	r0, r7
 80003e2:	8819      	ldrh	r1, [r3, #0]
 80003e4:	f002 fb8e 	bl	8002b04 <prvTraceSetQueueNumberHigh16>
 80003e8:	0038      	movs	r0, r7
 80003ea:	f002 fb49 	bl	8002a80 <prvTraceGetQueueType>
 80003ee:	5c25      	ldrb	r5, [r4, r0]
 80003f0:	0038      	movs	r0, r7
 80003f2:	f002 fb6f 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 80003f6:	b2c1      	uxtb	r1, r0
 80003f8:	0028      	movs	r0, r5
 80003fa:	f004 fa23 	bl	8004844 <prvMarkObjectAsUsed>
 80003fe:	f002 fb8f 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000402:	f002 fb47 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000406:	4d19      	ldr	r5, [pc, #100]	; (800046c <xQueueGenericCreate+0x14c>)
 8000408:	882b      	ldrh	r3, [r5, #0]
 800040a:	4203      	tst	r3, r0
 800040c:	d10c      	bne.n	8000428 <xQueueGenericCreate+0x108>
 800040e:	0038      	movs	r0, r7
 8000410:	f002 fb36 	bl	8002a80 <prvTraceGetQueueType>
 8000414:	5c24      	ldrb	r4, [r4, r0]
 8000416:	0038      	movs	r0, r7
 8000418:	f002 fb5c 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 800041c:	2200      	movs	r2, #0
 800041e:	b2c1      	uxtb	r1, r0
 8000420:	0020      	movs	r0, r4
 8000422:	f003 fe49 	bl	80040b8 <prvTraceSetObjectState>
}
 8000426:	e796      	b.n	8000356 <xQueueGenericCreate+0x36>
    traceQUEUE_CREATE( pxNewQueue );
 8000428:	0038      	movs	r0, r7
 800042a:	f002 fb59 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 800042e:	882b      	ldrh	r3, [r5, #0]
 8000430:	4203      	tst	r3, r0
 8000432:	d0ec      	beq.n	800040e <xQueueGenericCreate+0xee>
 8000434:	0038      	movs	r0, r7
 8000436:	f002 fb23 	bl	8002a80 <prvTraceGetQueueType>
 800043a:	5c25      	ldrb	r5, [r4, r0]
 800043c:	0038      	movs	r0, r7
 800043e:	f002 fb1f 	bl	8002a80 <prvTraceGetQueueType>
 8000442:	5c26      	ldrb	r6, [r4, r0]
 8000444:	0038      	movs	r0, r7
 8000446:	f002 fb45 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 800044a:	3518      	adds	r5, #24
 800044c:	b2ed      	uxtb	r5, r5
 800044e:	b2c2      	uxtb	r2, r0
 8000450:	0031      	movs	r1, r6
 8000452:	0028      	movs	r0, r5
 8000454:	f003 f8b6 	bl	80035c4 <prvTraceStoreKernelCall>
 8000458:	e7d9      	b.n	800040e <xQueueGenericCreate+0xee>
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 800045a:	0038      	movs	r0, r7
 800045c:	3050      	adds	r0, #80	; 0x50
 800045e:	f002 fabf 	bl	80029e0 <pvPortMalloc>
 8000462:	0007      	movs	r7, r0
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8000464:	3050      	adds	r0, #80	; 0x50
        if( pxNewQueue != NULL )
 8000466:	2f00      	cmp	r7, #0
 8000468:	d18c      	bne.n	8000384 <xQueueGenericCreate+0x64>
 800046a:	e76b      	b.n	8000344 <xQueueGenericCreate+0x24>
 800046c:	20001d7e 	.word	0x20001d7e
 8000470:	20000008 	.word	0x20000008
 8000474:	20001d7c 	.word	0x20001d7c

08000478 <xQueueGenericSend>:
{
 8000478:	b5f0      	push	{r4, r5, r6, r7, lr}
 800047a:	46de      	mov	lr, fp
 800047c:	4645      	mov	r5, r8
 800047e:	4657      	mov	r7, sl
 8000480:	464e      	mov	r6, r9
 8000482:	b5e0      	push	{r5, r6, r7, lr}
 8000484:	b085      	sub	sp, #20
 8000486:	1e04      	subs	r4, r0, #0
 8000488:	4688      	mov	r8, r1
 800048a:	469b      	mov	fp, r3
 800048c:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
 800048e:	d100      	bne.n	8000492 <xQueueGenericSend+0x1a>
 8000490:	e09b      	b.n	80005ca <xQueueGenericSend+0x152>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000492:	2900      	cmp	r1, #0
 8000494:	d100      	bne.n	8000498 <xQueueGenericSend+0x20>
 8000496:	e092      	b.n	80005be <xQueueGenericSend+0x146>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8000498:	465b      	mov	r3, fp
 800049a:	2b02      	cmp	r3, #2
 800049c:	d104      	bne.n	80004a8 <xQueueGenericSend+0x30>
 800049e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80004a0:	2b01      	cmp	r3, #1
 80004a2:	d001      	beq.n	80004a8 <xQueueGenericSend+0x30>
 80004a4:	b672      	cpsid	i
 80004a6:	e7fe      	b.n	80004a6 <xQueueGenericSend+0x2e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80004a8:	f001 fe7a 	bl	80021a0 <xTaskGetSchedulerState>
 80004ac:	1e06      	subs	r6, r0, #0
 80004ae:	d100      	bne.n	80004b2 <xQueueGenericSend+0x3a>
 80004b0:	e08d      	b.n	80005ce <xQueueGenericSend+0x156>
 80004b2:	2600      	movs	r6, #0
 80004b4:	4bc0      	ldr	r3, [pc, #768]	; (80007b8 <xQueueGenericSend+0x340>)
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80004b6:	0025      	movs	r5, r4
 80004b8:	4699      	mov	r9, r3
 80004ba:	4bc0      	ldr	r3, [pc, #768]	; (80007bc <xQueueGenericSend+0x344>)
 80004bc:	3524      	adds	r5, #36	; 0x24
 80004be:	469a      	mov	sl, r3
        taskENTER_CRITICAL();
 80004c0:	f002 f9f6 	bl	80028b0 <vPortEnterCritical>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80004c4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80004c6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80004c8:	429a      	cmp	r2, r3
 80004ca:	d200      	bcs.n	80004ce <xQueueGenericSend+0x56>
 80004cc:	e0fd      	b.n	80006ca <xQueueGenericSend+0x252>
 80004ce:	465b      	mov	r3, fp
 80004d0:	2b02      	cmp	r3, #2
 80004d2:	d100      	bne.n	80004d6 <xQueueGenericSend+0x5e>
 80004d4:	e0f9      	b.n	80006ca <xQueueGenericSend+0x252>
                if( xTicksToWait == ( TickType_t ) 0 )
 80004d6:	9b01      	ldr	r3, [sp, #4]
 80004d8:	2b00      	cmp	r3, #0
 80004da:	d100      	bne.n	80004de <xQueueGenericSend+0x66>
 80004dc:	e146      	b.n	800076c <xQueueGenericSend+0x2f4>
                else if( xEntryTimeSet == pdFALSE )
 80004de:	2e00      	cmp	r6, #0
 80004e0:	d100      	bne.n	80004e4 <xQueueGenericSend+0x6c>
 80004e2:	e0d4      	b.n	800068e <xQueueGenericSend+0x216>
        taskEXIT_CRITICAL();
 80004e4:	f002 f9f0 	bl	80028c8 <vPortExitCritical>
        vTaskSuspendAll();
 80004e8:	f001 fa50 	bl	800198c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 80004ec:	f002 f9e0 	bl	80028b0 <vPortEnterCritical>
 80004f0:	2244      	movs	r2, #68	; 0x44
 80004f2:	5ca3      	ldrb	r3, [r4, r2]
 80004f4:	b25b      	sxtb	r3, r3
 80004f6:	3301      	adds	r3, #1
 80004f8:	d101      	bne.n	80004fe <xQueueGenericSend+0x86>
 80004fa:	2300      	movs	r3, #0
 80004fc:	54a3      	strb	r3, [r4, r2]
 80004fe:	2245      	movs	r2, #69	; 0x45
 8000500:	5ca3      	ldrb	r3, [r4, r2]
 8000502:	b25b      	sxtb	r3, r3
 8000504:	3301      	adds	r3, #1
 8000506:	d101      	bne.n	800050c <xQueueGenericSend+0x94>
 8000508:	2300      	movs	r3, #0
 800050a:	54a3      	strb	r3, [r4, r2]
 800050c:	f002 f9dc 	bl	80028c8 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000510:	a901      	add	r1, sp, #4
 8000512:	a802      	add	r0, sp, #8
 8000514:	f001 fdf6 	bl	8002104 <xTaskCheckForTimeOut>
 8000518:	2800      	cmp	r0, #0
 800051a:	d000      	beq.n	800051e <xQueueGenericSend+0xa6>
 800051c:	e132      	b.n	8000784 <xQueueGenericSend+0x30c>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 800051e:	f002 f9c7 	bl	80028b0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8000522:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000524:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000526:	429a      	cmp	r2, r3
 8000528:	d057      	beq.n	80005da <xQueueGenericSend+0x162>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 800052a:	f002 f9cd 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 800052e:	f002 f9bf 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000532:	2345      	movs	r3, #69	; 0x45
 8000534:	5ce6      	ldrb	r6, [r4, r3]
 8000536:	b276      	sxtb	r6, r6
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000538:	2e00      	cmp	r6, #0
 800053a:	dc05      	bgt.n	8000548 <xQueueGenericSend+0xd0>
 800053c:	e013      	b.n	8000566 <xQueueGenericSend+0xee>
            --cTxLock;
 800053e:	3e01      	subs	r6, #1
 8000540:	b2f2      	uxtb	r2, r6
 8000542:	b276      	sxtb	r6, r6
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000544:	2a00      	cmp	r2, #0
 8000546:	d00e      	beq.n	8000566 <xQueueGenericSend+0xee>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000548:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800054a:	2b00      	cmp	r3, #0
 800054c:	d00b      	beq.n	8000566 <xQueueGenericSend+0xee>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800054e:	0028      	movs	r0, r5
 8000550:	f001 fd7c 	bl	800204c <xTaskRemoveFromEventList>
 8000554:	2800      	cmp	r0, #0
 8000556:	d0f2      	beq.n	800053e <xQueueGenericSend+0xc6>
                            vTaskMissedYield();
 8000558:	3e01      	subs	r6, #1
 800055a:	f001 fe0b 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 800055e:	b2f2      	uxtb	r2, r6
 8000560:	b276      	sxtb	r6, r6
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000562:	2a00      	cmp	r2, #0
 8000564:	d1f0      	bne.n	8000548 <xQueueGenericSend+0xd0>
        pxQueue->cTxLock = queueUNLOCKED;
 8000566:	2345      	movs	r3, #69	; 0x45
 8000568:	22ff      	movs	r2, #255	; 0xff
 800056a:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800056c:	f002 f9ac 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000570:	f002 f99e 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000574:	2344      	movs	r3, #68	; 0x44
 8000576:	5ce7      	ldrb	r7, [r4, r3]
 8000578:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800057a:	2f00      	cmp	r7, #0
 800057c:	dd16      	ble.n	80005ac <xQueueGenericSend+0x134>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800057e:	0026      	movs	r6, r4
 8000580:	3610      	adds	r6, #16
 8000582:	e004      	b.n	800058e <xQueueGenericSend+0x116>
                --cRxLock;
 8000584:	3f01      	subs	r7, #1
 8000586:	b2fb      	uxtb	r3, r7
 8000588:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800058a:	2b00      	cmp	r3, #0
 800058c:	d00e      	beq.n	80005ac <xQueueGenericSend+0x134>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800058e:	6923      	ldr	r3, [r4, #16]
 8000590:	2b00      	cmp	r3, #0
 8000592:	d00b      	beq.n	80005ac <xQueueGenericSend+0x134>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000594:	0030      	movs	r0, r6
 8000596:	f001 fd59 	bl	800204c <xTaskRemoveFromEventList>
 800059a:	2800      	cmp	r0, #0
 800059c:	d0f2      	beq.n	8000584 <xQueueGenericSend+0x10c>
                    vTaskMissedYield();
 800059e:	3f01      	subs	r7, #1
 80005a0:	f001 fde8 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 80005a4:	b2fb      	uxtb	r3, r7
 80005a6:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80005a8:	2b00      	cmp	r3, #0
 80005aa:	d1f0      	bne.n	800058e <xQueueGenericSend+0x116>
        pxQueue->cRxLock = queueUNLOCKED;
 80005ac:	2344      	movs	r3, #68	; 0x44
 80005ae:	22ff      	movs	r2, #255	; 0xff
 80005b0:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 80005b2:	f002 f989 	bl	80028c8 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 80005b6:	f001 fb7d 	bl	8001cb4 <xTaskResumeAll>
 80005ba:	2601      	movs	r6, #1
 80005bc:	e780      	b.n	80004c0 <xQueueGenericSend+0x48>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80005be:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80005c0:	2b00      	cmp	r3, #0
 80005c2:	d100      	bne.n	80005c6 <xQueueGenericSend+0x14e>
 80005c4:	e768      	b.n	8000498 <xQueueGenericSend+0x20>
 80005c6:	b672      	cpsid	i
 80005c8:	e7fe      	b.n	80005c8 <xQueueGenericSend+0x150>
    configASSERT( pxQueue );
 80005ca:	b672      	cpsid	i
 80005cc:	e7fe      	b.n	80005cc <xQueueGenericSend+0x154>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80005ce:	9b01      	ldr	r3, [sp, #4]
 80005d0:	2b00      	cmp	r3, #0
 80005d2:	d100      	bne.n	80005d6 <xQueueGenericSend+0x15e>
 80005d4:	e76e      	b.n	80004b4 <xQueueGenericSend+0x3c>
 80005d6:	b672      	cpsid	i
 80005d8:	e7fe      	b.n	80005d8 <xQueueGenericSend+0x160>
    taskEXIT_CRITICAL();
 80005da:	f002 f975 	bl	80028c8 <vPortExitCritical>
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 80005de:	f002 fa9f 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 80005e2:	f002 fa57 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80005e6:	464b      	mov	r3, r9
 80005e8:	881b      	ldrh	r3, [r3, #0]
 80005ea:	4203      	tst	r3, r0
 80005ec:	d153      	bne.n	8000696 <xQueueGenericSend+0x21e>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80005ee:	0026      	movs	r6, r4
 80005f0:	3610      	adds	r6, #16
 80005f2:	0030      	movs	r0, r6
 80005f4:	9901      	ldr	r1, [sp, #4]
 80005f6:	f001 fc6d 	bl	8001ed4 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 80005fa:	f002 f959 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80005fe:	2345      	movs	r3, #69	; 0x45
 8000600:	5ce7      	ldrb	r7, [r4, r3]
 8000602:	b27f      	sxtb	r7, r7
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000604:	2f00      	cmp	r7, #0
 8000606:	dc05      	bgt.n	8000614 <xQueueGenericSend+0x19c>
 8000608:	e013      	b.n	8000632 <xQueueGenericSend+0x1ba>
            --cTxLock;
 800060a:	3f01      	subs	r7, #1
 800060c:	b2fa      	uxtb	r2, r7
 800060e:	b27f      	sxtb	r7, r7
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000610:	2a00      	cmp	r2, #0
 8000612:	d00e      	beq.n	8000632 <xQueueGenericSend+0x1ba>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000614:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000616:	2b00      	cmp	r3, #0
 8000618:	d00b      	beq.n	8000632 <xQueueGenericSend+0x1ba>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800061a:	0028      	movs	r0, r5
 800061c:	f001 fd16 	bl	800204c <xTaskRemoveFromEventList>
 8000620:	2800      	cmp	r0, #0
 8000622:	d0f2      	beq.n	800060a <xQueueGenericSend+0x192>
                            vTaskMissedYield();
 8000624:	3f01      	subs	r7, #1
 8000626:	f001 fda5 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 800062a:	b2fa      	uxtb	r2, r7
 800062c:	b27f      	sxtb	r7, r7
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800062e:	2a00      	cmp	r2, #0
 8000630:	d1f0      	bne.n	8000614 <xQueueGenericSend+0x19c>
        pxQueue->cTxLock = queueUNLOCKED;
 8000632:	2345      	movs	r3, #69	; 0x45
 8000634:	22ff      	movs	r2, #255	; 0xff
 8000636:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000638:	f002 f946 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 800063c:	f002 f938 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000640:	2344      	movs	r3, #68	; 0x44
 8000642:	5ce7      	ldrb	r7, [r4, r3]
 8000644:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000646:	2f00      	cmp	r7, #0
 8000648:	dc05      	bgt.n	8000656 <xQueueGenericSend+0x1de>
 800064a:	e013      	b.n	8000674 <xQueueGenericSend+0x1fc>
                --cRxLock;
 800064c:	3f01      	subs	r7, #1
 800064e:	b2fa      	uxtb	r2, r7
 8000650:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000652:	2a00      	cmp	r2, #0
 8000654:	d00e      	beq.n	8000674 <xQueueGenericSend+0x1fc>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000656:	6923      	ldr	r3, [r4, #16]
 8000658:	2b00      	cmp	r3, #0
 800065a:	d00b      	beq.n	8000674 <xQueueGenericSend+0x1fc>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800065c:	0030      	movs	r0, r6
 800065e:	f001 fcf5 	bl	800204c <xTaskRemoveFromEventList>
 8000662:	2800      	cmp	r0, #0
 8000664:	d0f2      	beq.n	800064c <xQueueGenericSend+0x1d4>
                    vTaskMissedYield();
 8000666:	3f01      	subs	r7, #1
 8000668:	f001 fd84 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 800066c:	b2fa      	uxtb	r2, r7
 800066e:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000670:	2a00      	cmp	r2, #0
 8000672:	d1f0      	bne.n	8000656 <xQueueGenericSend+0x1de>
        pxQueue->cRxLock = queueUNLOCKED;
 8000674:	2344      	movs	r3, #68	; 0x44
 8000676:	22ff      	movs	r2, #255	; 0xff
 8000678:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800067a:	f002 f925 	bl	80028c8 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 800067e:	f001 fb19 	bl	8001cb4 <xTaskResumeAll>
 8000682:	2800      	cmp	r0, #0
 8000684:	d199      	bne.n	80005ba <xQueueGenericSend+0x142>
                    portYIELD_WITHIN_API();
 8000686:	f002 f907 	bl	8002898 <vPortYield>
 800068a:	2601      	movs	r6, #1
 800068c:	e718      	b.n	80004c0 <xQueueGenericSend+0x48>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 800068e:	a802      	add	r0, sp, #8
 8000690:	f001 fd2c 	bl	80020ec <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8000694:	e726      	b.n	80004e4 <xQueueGenericSend+0x6c>
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 8000696:	0020      	movs	r0, r4
 8000698:	f002 fa22 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 800069c:	464b      	mov	r3, r9
 800069e:	881b      	ldrh	r3, [r3, #0]
 80006a0:	4203      	tst	r3, r0
 80006a2:	d0a4      	beq.n	80005ee <xQueueGenericSend+0x176>
 80006a4:	465b      	mov	r3, fp
 80006a6:	2775      	movs	r7, #117	; 0x75
 80006a8:	4656      	mov	r6, sl
 80006aa:	2b00      	cmp	r3, #0
 80006ac:	d100      	bne.n	80006b0 <xQueueGenericSend+0x238>
 80006ae:	e0d2      	b.n	8000856 <xQueueGenericSend+0x3de>
 80006b0:	0020      	movs	r0, r4
 80006b2:	f002 f9e5 	bl	8002a80 <prvTraceGetQueueType>
 80006b6:	5c36      	ldrb	r6, [r6, r0]
 80006b8:	0020      	movs	r0, r4
 80006ba:	f002 fa0b 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 80006be:	0031      	movs	r1, r6
 80006c0:	b2c2      	uxtb	r2, r0
 80006c2:	0038      	movs	r0, r7
 80006c4:	f002 ff7e 	bl	80035c4 <prvTraceStoreKernelCall>
 80006c8:	e791      	b.n	80005ee <xQueueGenericSend+0x176>
                traceQUEUE_SEND( pxQueue );
 80006ca:	f002 fa29 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 80006ce:	f002 f9e1 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80006d2:	464b      	mov	r3, r9
 80006d4:	881b      	ldrh	r3, [r3, #0]
 80006d6:	4203      	tst	r3, r0
 80006d8:	d12d      	bne.n	8000736 <xQueueGenericSend+0x2be>
 80006da:	4e38      	ldr	r6, [pc, #224]	; (80007bc <xQueueGenericSend+0x344>)
 80006dc:	0020      	movs	r0, r4
 80006de:	f002 f9cf 	bl	8002a80 <prvTraceGetQueueType>
 80006e2:	5c33      	ldrb	r3, [r6, r0]
 80006e4:	0020      	movs	r0, r4
 80006e6:	4699      	mov	r9, r3
 80006e8:	f002 f9f4 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 80006ec:	b2c5      	uxtb	r5, r0
 80006ee:	0020      	movs	r0, r4
 80006f0:	f002 f9c6 	bl	8002a80 <prvTraceGetQueueType>
 80006f4:	5c33      	ldrb	r3, [r6, r0]
 80006f6:	2b02      	cmp	r3, #2
 80006f8:	d100      	bne.n	80006fc <xQueueGenericSend+0x284>
 80006fa:	e090      	b.n	800081e <xQueueGenericSend+0x3a6>
 80006fc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80006fe:	3201      	adds	r2, #1
 8000700:	b2d2      	uxtb	r2, r2
 8000702:	0029      	movs	r1, r5
 8000704:	4648      	mov	r0, r9
 8000706:	f003 fcd7 	bl	80040b8 <prvTraceSetObjectState>
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800070a:	465a      	mov	r2, fp
 800070c:	4641      	mov	r1, r8
 800070e:	0020      	movs	r0, r4
 8000710:	f7ff fdcc 	bl	80002ac <prvCopyDataToQueue>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000714:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000716:	2b00      	cmp	r3, #0
 8000718:	d000      	beq.n	800071c <xQueueGenericSend+0x2a4>
 800071a:	e07b      	b.n	8000814 <xQueueGenericSend+0x39c>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800071c:	2800      	cmp	r0, #0
 800071e:	d000      	beq.n	8000722 <xQueueGenericSend+0x2aa>
 8000720:	e075      	b.n	800080e <xQueueGenericSend+0x396>
                taskEXIT_CRITICAL();
 8000722:	f002 f8d1 	bl	80028c8 <vPortExitCritical>
                return pdPASS;
 8000726:	2001      	movs	r0, #1
}
 8000728:	b005      	add	sp, #20
 800072a:	bcf0      	pop	{r4, r5, r6, r7}
 800072c:	46bb      	mov	fp, r7
 800072e:	46b2      	mov	sl, r6
 8000730:	46a9      	mov	r9, r5
 8000732:	46a0      	mov	r8, r4
 8000734:	bdf0      	pop	{r4, r5, r6, r7, pc}
                traceQUEUE_SEND( pxQueue );
 8000736:	0020      	movs	r0, r4
 8000738:	f002 f9d2 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 800073c:	464b      	mov	r3, r9
 800073e:	881b      	ldrh	r3, [r3, #0]
 8000740:	4203      	tst	r3, r0
 8000742:	d0ca      	beq.n	80006da <xQueueGenericSend+0x262>
 8000744:	465b      	mov	r3, fp
 8000746:	2b00      	cmp	r3, #0
 8000748:	d100      	bne.n	800074c <xQueueGenericSend+0x2d4>
 800074a:	e094      	b.n	8000876 <xQueueGenericSend+0x3fe>
 800074c:	2525      	movs	r5, #37	; 0x25
 800074e:	4e1b      	ldr	r6, [pc, #108]	; (80007bc <xQueueGenericSend+0x344>)
 8000750:	0020      	movs	r0, r4
 8000752:	f002 f995 	bl	8002a80 <prvTraceGetQueueType>
 8000756:	5c33      	ldrb	r3, [r6, r0]
 8000758:	0020      	movs	r0, r4
 800075a:	4699      	mov	r9, r3
 800075c:	f002 f9ba 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000760:	4649      	mov	r1, r9
 8000762:	b2c2      	uxtb	r2, r0
 8000764:	0028      	movs	r0, r5
 8000766:	f002 ff2d 	bl	80035c4 <prvTraceStoreKernelCall>
 800076a:	e7b7      	b.n	80006dc <xQueueGenericSend+0x264>
                    taskEXIT_CRITICAL();
 800076c:	f002 f8ac 	bl	80028c8 <vPortExitCritical>
            traceQUEUE_SEND_FAILED( pxQueue );
 8000770:	f002 f9d6 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000774:	f002 f98e 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000778:	464b      	mov	r3, r9
 800077a:	881b      	ldrh	r3, [r3, #0]
 800077c:	4203      	tst	r3, r0
 800077e:	d150      	bne.n	8000822 <xQueueGenericSend+0x3aa>
            return errQUEUE_FULL;
 8000780:	2000      	movs	r0, #0
 8000782:	e7d1      	b.n	8000728 <xQueueGenericSend+0x2b0>
    taskENTER_CRITICAL();
 8000784:	f002 f894 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000788:	2345      	movs	r3, #69	; 0x45
 800078a:	5ce5      	ldrb	r5, [r4, r3]
 800078c:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800078e:	2d00      	cmp	r5, #0
 8000790:	dd16      	ble.n	80007c0 <xQueueGenericSend+0x348>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000792:	0026      	movs	r6, r4
 8000794:	3624      	adds	r6, #36	; 0x24
 8000796:	e004      	b.n	80007a2 <xQueueGenericSend+0x32a>
            --cTxLock;
 8000798:	3d01      	subs	r5, #1
 800079a:	b2ea      	uxtb	r2, r5
 800079c:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800079e:	2a00      	cmp	r2, #0
 80007a0:	d00e      	beq.n	80007c0 <xQueueGenericSend+0x348>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80007a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80007a4:	2b00      	cmp	r3, #0
 80007a6:	d00b      	beq.n	80007c0 <xQueueGenericSend+0x348>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80007a8:	0030      	movs	r0, r6
 80007aa:	f001 fc4f 	bl	800204c <xTaskRemoveFromEventList>
 80007ae:	2800      	cmp	r0, #0
 80007b0:	d0f2      	beq.n	8000798 <xQueueGenericSend+0x320>
                            vTaskMissedYield();
 80007b2:	f001 fcdf 	bl	8002174 <vTaskMissedYield>
 80007b6:	e7ef      	b.n	8000798 <xQueueGenericSend+0x320>
 80007b8:	20001d7e 	.word	0x20001d7e
 80007bc:	20000008 	.word	0x20000008
        pxQueue->cTxLock = queueUNLOCKED;
 80007c0:	2345      	movs	r3, #69	; 0x45
 80007c2:	22ff      	movs	r2, #255	; 0xff
 80007c4:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 80007c6:	f002 f87f 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 80007ca:	f002 f871 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80007ce:	2344      	movs	r3, #68	; 0x44
 80007d0:	5ce5      	ldrb	r5, [r4, r3]
 80007d2:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80007d4:	2d00      	cmp	r5, #0
 80007d6:	dd12      	ble.n	80007fe <xQueueGenericSend+0x386>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80007d8:	0026      	movs	r6, r4
 80007da:	3610      	adds	r6, #16
 80007dc:	e004      	b.n	80007e8 <xQueueGenericSend+0x370>
                --cRxLock;
 80007de:	3d01      	subs	r5, #1
 80007e0:	b2ea      	uxtb	r2, r5
 80007e2:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80007e4:	2a00      	cmp	r2, #0
 80007e6:	d00a      	beq.n	80007fe <xQueueGenericSend+0x386>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80007e8:	6923      	ldr	r3, [r4, #16]
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d007      	beq.n	80007fe <xQueueGenericSend+0x386>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80007ee:	0030      	movs	r0, r6
 80007f0:	f001 fc2c 	bl	800204c <xTaskRemoveFromEventList>
 80007f4:	2800      	cmp	r0, #0
 80007f6:	d0f2      	beq.n	80007de <xQueueGenericSend+0x366>
                    vTaskMissedYield();
 80007f8:	f001 fcbc 	bl	8002174 <vTaskMissedYield>
 80007fc:	e7ef      	b.n	80007de <xQueueGenericSend+0x366>
        pxQueue->cRxLock = queueUNLOCKED;
 80007fe:	2344      	movs	r3, #68	; 0x44
 8000800:	22ff      	movs	r2, #255	; 0xff
 8000802:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000804:	f002 f860 	bl	80028c8 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 8000808:	f001 fa54 	bl	8001cb4 <xTaskResumeAll>
 800080c:	e7b0      	b.n	8000770 <xQueueGenericSend+0x2f8>
                                queueYIELD_IF_USING_PREEMPTION();
 800080e:	f002 f843 	bl	8002898 <vPortYield>
 8000812:	e786      	b.n	8000722 <xQueueGenericSend+0x2aa>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000814:	0020      	movs	r0, r4
 8000816:	3024      	adds	r0, #36	; 0x24
 8000818:	f001 fc18 	bl	800204c <xTaskRemoveFromEventList>
 800081c:	e77e      	b.n	800071c <xQueueGenericSend+0x2a4>
                traceQUEUE_SEND( pxQueue );
 800081e:	2200      	movs	r2, #0
 8000820:	e76f      	b.n	8000702 <xQueueGenericSend+0x28a>
            traceQUEUE_SEND_FAILED( pxQueue );
 8000822:	0020      	movs	r0, r4
 8000824:	f002 f95c 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8000828:	464b      	mov	r3, r9
 800082a:	881b      	ldrh	r3, [r3, #0]
 800082c:	4203      	tst	r3, r0
 800082e:	d0a7      	beq.n	8000780 <xQueueGenericSend+0x308>
 8000830:	465b      	mov	r3, fp
 8000832:	2b00      	cmp	r3, #0
 8000834:	d017      	beq.n	8000866 <xQueueGenericSend+0x3ee>
 8000836:	254d      	movs	r5, #77	; 0x4d
 8000838:	4e13      	ldr	r6, [pc, #76]	; (8000888 <xQueueGenericSend+0x410>)
 800083a:	0020      	movs	r0, r4
 800083c:	f002 f920 	bl	8002a80 <prvTraceGetQueueType>
 8000840:	5c36      	ldrb	r6, [r6, r0]
 8000842:	0020      	movs	r0, r4
 8000844:	f002 f946 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000848:	0031      	movs	r1, r6
 800084a:	b2c2      	uxtb	r2, r0
 800084c:	0028      	movs	r0, r5
 800084e:	f002 feb9 	bl	80035c4 <prvTraceStoreKernelCall>
            return errQUEUE_FULL;
 8000852:	2000      	movs	r0, #0
 8000854:	e768      	b.n	8000728 <xQueueGenericSend+0x2b0>
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 8000856:	0020      	movs	r0, r4
 8000858:	f002 f912 	bl	8002a80 <prvTraceGetQueueType>
 800085c:	4e0a      	ldr	r6, [pc, #40]	; (8000888 <xQueueGenericSend+0x410>)
 800085e:	5c33      	ldrb	r3, [r6, r0]
 8000860:	3370      	adds	r3, #112	; 0x70
 8000862:	b2df      	uxtb	r7, r3
 8000864:	e724      	b.n	80006b0 <xQueueGenericSend+0x238>
            traceQUEUE_SEND_FAILED( pxQueue );
 8000866:	0020      	movs	r0, r4
 8000868:	f002 f90a 	bl	8002a80 <prvTraceGetQueueType>
 800086c:	4e06      	ldr	r6, [pc, #24]	; (8000888 <xQueueGenericSend+0x410>)
 800086e:	5c35      	ldrb	r5, [r6, r0]
 8000870:	3548      	adds	r5, #72	; 0x48
 8000872:	b2ed      	uxtb	r5, r5
 8000874:	e7e1      	b.n	800083a <xQueueGenericSend+0x3c2>
                traceQUEUE_SEND( pxQueue );
 8000876:	0020      	movs	r0, r4
 8000878:	f002 f902 	bl	8002a80 <prvTraceGetQueueType>
 800087c:	4e02      	ldr	r6, [pc, #8]	; (8000888 <xQueueGenericSend+0x410>)
 800087e:	5c35      	ldrb	r5, [r6, r0]
 8000880:	3520      	adds	r5, #32
 8000882:	b2ed      	uxtb	r5, r5
 8000884:	e764      	b.n	8000750 <xQueueGenericSend+0x2d8>
 8000886:	46c0      	nop			; (mov r8, r8)
 8000888:	20000008 	.word	0x20000008

0800088c <xQueueCreateMutex>:
    {
 800088c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800088e:	0005      	movs	r5, r0
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8000890:	2050      	movs	r0, #80	; 0x50
 8000892:	f002 f8a5 	bl	80029e0 <pvPortMalloc>
 8000896:	1e04      	subs	r4, r0, #0
        if( pxNewQueue != NULL )
 8000898:	d100      	bne.n	800089c <xQueueCreateMutex+0x10>
 800089a:	e075      	b.n	8000988 <xQueueCreateMutex+0xfc>
    pxNewQueue->uxLength = uxQueueLength;
 800089c:	2301      	movs	r3, #1
    pxNewQueue->uxItemSize = uxItemSize;
 800089e:	2600      	movs	r6, #0
    pxNewQueue->uxLength = uxQueueLength;
 80008a0:	63c3      	str	r3, [r0, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 80008a2:	6406      	str	r6, [r0, #64]	; 0x40
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80008a4:	6000      	str	r0, [r0, #0]
    taskENTER_CRITICAL();
 80008a6:	f002 f803 	bl	80028b0 <vPortEnterCritical>
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80008aa:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80008ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80008ae:	6822      	ldr	r2, [r4, #0]
 80008b0:	434b      	muls	r3, r1
 80008b2:	18d0      	adds	r0, r2, r3
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80008b4:	1a5b      	subs	r3, r3, r1
        pxQueue->pcWriteTo = pxQueue->pcHead;
 80008b6:	6062      	str	r2, [r4, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80008b8:	18d2      	adds	r2, r2, r3
 80008ba:	60e2      	str	r2, [r4, #12]
        pxQueue->cRxLock = queueUNLOCKED;
 80008bc:	23ff      	movs	r3, #255	; 0xff
 80008be:	2244      	movs	r2, #68	; 0x44
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80008c0:	60a0      	str	r0, [r4, #8]
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80008c2:	0020      	movs	r0, r4
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80008c4:	63a6      	str	r6, [r4, #56]	; 0x38
        pxQueue->cRxLock = queueUNLOCKED;
 80008c6:	54a3      	strb	r3, [r4, r2]
        pxQueue->cTxLock = queueUNLOCKED;
 80008c8:	3201      	adds	r2, #1
 80008ca:	54a3      	strb	r3, [r4, r2]
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80008cc:	3010      	adds	r0, #16
 80008ce:	f7ff fca7 	bl	8000220 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80008d2:	0020      	movs	r0, r4
 80008d4:	3024      	adds	r0, #36	; 0x24
 80008d6:	f7ff fca3 	bl	8000220 <vListInitialise>
    taskEXIT_CRITICAL();
 80008da:	f001 fff5 	bl	80028c8 <vPortExitCritical>
            pxNewQueue->ucQueueType = ucQueueType;
 80008de:	234c      	movs	r3, #76	; 0x4c
    traceQUEUE_CREATE( pxNewQueue );
 80008e0:	0020      	movs	r0, r4
            pxNewQueue->ucQueueType = ucQueueType;
 80008e2:	54e5      	strb	r5, [r4, r3]
    traceQUEUE_CREATE( pxNewQueue );
 80008e4:	f002 f8cc 	bl	8002a80 <prvTraceGetQueueType>
 80008e8:	4d2f      	ldr	r5, [pc, #188]	; (80009a8 <xQueueCreateMutex+0x11c>)
 80008ea:	5c28      	ldrb	r0, [r5, r0]
 80008ec:	f003 feec 	bl	80046c8 <prvTraceGetObjectHandle>
 80008f0:	b281      	uxth	r1, r0
 80008f2:	0020      	movs	r0, r4
 80008f4:	f002 f8fa 	bl	8002aec <prvTraceSetQueueNumberLow16>
 80008f8:	4b2c      	ldr	r3, [pc, #176]	; (80009ac <xQueueCreateMutex+0x120>)
 80008fa:	0020      	movs	r0, r4
 80008fc:	8819      	ldrh	r1, [r3, #0]
 80008fe:	f002 f901 	bl	8002b04 <prvTraceSetQueueNumberHigh16>
 8000902:	0020      	movs	r0, r4
 8000904:	f002 f8bc 	bl	8002a80 <prvTraceGetQueueType>
 8000908:	5c2e      	ldrb	r6, [r5, r0]
 800090a:	0020      	movs	r0, r4
 800090c:	f002 f8e2 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000910:	b2c1      	uxtb	r1, r0
 8000912:	0030      	movs	r0, r6
 8000914:	f003 ff96 	bl	8004844 <prvMarkObjectAsUsed>
 8000918:	f002 f902 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 800091c:	f002 f8ba 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000920:	4e23      	ldr	r6, [pc, #140]	; (80009b0 <xQueueCreateMutex+0x124>)
 8000922:	8833      	ldrh	r3, [r6, #0]
 8000924:	4203      	tst	r3, r0
 8000926:	d116      	bne.n	8000956 <xQueueCreateMutex+0xca>
 8000928:	0020      	movs	r0, r4
 800092a:	f002 f8a9 	bl	8002a80 <prvTraceGetQueueType>
 800092e:	5c2d      	ldrb	r5, [r5, r0]
 8000930:	0020      	movs	r0, r4
 8000932:	f002 f8cf 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000936:	2200      	movs	r2, #0
 8000938:	b2c1      	uxtb	r1, r0
 800093a:	0028      	movs	r0, r5
 800093c:	f003 fbbc 	bl	80040b8 <prvTraceSetObjectState>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8000940:	2300      	movs	r3, #0
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8000942:	2200      	movs	r2, #0
 8000944:	2100      	movs	r1, #0
 8000946:	0020      	movs	r0, r4
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8000948:	60a3      	str	r3, [r4, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800094a:	6023      	str	r3, [r4, #0]
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800094c:	60e3      	str	r3, [r4, #12]
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800094e:	f7ff fd93 	bl	8000478 <xQueueGenericSend>
    }
 8000952:	0020      	movs	r0, r4
 8000954:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    traceQUEUE_CREATE( pxNewQueue );
 8000956:	0020      	movs	r0, r4
 8000958:	f002 f8c2 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 800095c:	8833      	ldrh	r3, [r6, #0]
 800095e:	4203      	tst	r3, r0
 8000960:	d0e2      	beq.n	8000928 <xQueueCreateMutex+0x9c>
 8000962:	0020      	movs	r0, r4
 8000964:	f002 f88c 	bl	8002a80 <prvTraceGetQueueType>
 8000968:	5c2e      	ldrb	r6, [r5, r0]
 800096a:	0020      	movs	r0, r4
 800096c:	f002 f888 	bl	8002a80 <prvTraceGetQueueType>
 8000970:	5c2f      	ldrb	r7, [r5, r0]
 8000972:	0020      	movs	r0, r4
 8000974:	f002 f8ae 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000978:	3618      	adds	r6, #24
 800097a:	b2f6      	uxtb	r6, r6
 800097c:	b2c2      	uxtb	r2, r0
 800097e:	0039      	movs	r1, r7
 8000980:	0030      	movs	r0, r6
 8000982:	f002 fe1f 	bl	80035c4 <prvTraceStoreKernelCall>
 8000986:	e7cf      	b.n	8000928 <xQueueCreateMutex+0x9c>
            traceQUEUE_CREATE_FAILED( ucQueueType );
 8000988:	f002 f8ca 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 800098c:	f002 f882 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000990:	4b07      	ldr	r3, [pc, #28]	; (80009b0 <xQueueCreateMutex+0x124>)
 8000992:	881b      	ldrh	r3, [r3, #0]
 8000994:	4203      	tst	r3, r0
 8000996:	d0dc      	beq.n	8000952 <xQueueCreateMutex+0xc6>
 8000998:	4b03      	ldr	r3, [pc, #12]	; (80009a8 <xQueueCreateMutex+0x11c>)
 800099a:	2100      	movs	r1, #0
 800099c:	5d58      	ldrb	r0, [r3, r5]
 800099e:	3040      	adds	r0, #64	; 0x40
 80009a0:	b2c0      	uxtb	r0, r0
 80009a2:	f003 f8d7 	bl	8003b54 <prvTraceStoreKernelCallWithNumericParamOnly>
        return xNewQueue;
 80009a6:	e7d4      	b.n	8000952 <xQueueCreateMutex+0xc6>
 80009a8:	20000008 	.word	0x20000008
 80009ac:	20001d7c 	.word	0x20001d7c
 80009b0:	20001d7e 	.word	0x20001d7e

080009b4 <xQueueGiveFromISR>:
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
 80009b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80009b6:	4645      	mov	r5, r8
 80009b8:	46de      	mov	lr, fp
 80009ba:	4657      	mov	r7, sl
 80009bc:	464e      	mov	r6, r9
 80009be:	0004      	movs	r4, r0
 80009c0:	b5e0      	push	{r5, r6, r7, lr}
 80009c2:	000d      	movs	r5, r1
    configASSERT( pxQueue );
 80009c4:	2800      	cmp	r0, #0
 80009c6:	d039      	beq.n	8000a3c <xQueueGiveFromISR+0x88>
    configASSERT( pxQueue->uxItemSize == 0 );
 80009c8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80009ca:	2b00      	cmp	r3, #0
 80009cc:	d001      	beq.n	80009d2 <xQueueGiveFromISR+0x1e>
 80009ce:	b672      	cpsid	i
 80009d0:	e7fe      	b.n	80009d0 <xQueueGiveFromISR+0x1c>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80009d2:	6803      	ldr	r3, [r0, #0]
 80009d4:	2b00      	cmp	r3, #0
 80009d6:	d033      	beq.n	8000a40 <xQueueGiveFromISR+0x8c>
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80009d8:	f001 ff84 	bl	80028e4 <ulSetInterruptMaskFromISR>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80009dc:	6ba7      	ldr	r7, [r4, #56]	; 0x38
        if( uxMessagesWaiting < pxQueue->uxLength )
 80009de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80009e0:	0006      	movs	r6, r0
        if( uxMessagesWaiting < pxQueue->uxLength )
 80009e2:	429f      	cmp	r7, r3
 80009e4:	d231      	bcs.n	8000a4a <xQueueGiveFromISR+0x96>
            const int8_t cTxLock = pxQueue->cTxLock;
 80009e6:	2345      	movs	r3, #69	; 0x45
 80009e8:	5ce3      	ldrb	r3, [r4, r3]
            traceQUEUE_SEND_FROM_ISR( pxQueue );
 80009ea:	0020      	movs	r0, r4
            const int8_t cTxLock = pxQueue->cTxLock;
 80009ec:	b25b      	sxtb	r3, r3
 80009ee:	4698      	mov	r8, r3
            traceQUEUE_SEND_FROM_ISR( pxQueue );
 80009f0:	f002 f876 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 80009f4:	4b3e      	ldr	r3, [pc, #248]	; (8000af0 <xQueueGiveFromISR+0x13c>)
 80009f6:	881b      	ldrh	r3, [r3, #0]
 80009f8:	4203      	tst	r3, r0
 80009fa:	d14e      	bne.n	8000a9a <xQueueGiveFromISR+0xe6>
 80009fc:	4b3d      	ldr	r3, [pc, #244]	; (8000af4 <xQueueGiveFromISR+0x140>)
 80009fe:	4699      	mov	r9, r3
 8000a00:	0020      	movs	r0, r4
 8000a02:	f002 f83d 	bl	8002a80 <prvTraceGetQueueType>
 8000a06:	464b      	mov	r3, r9
 8000a08:	5c1b      	ldrb	r3, [r3, r0]
 8000a0a:	0020      	movs	r0, r4
 8000a0c:	4699      	mov	r9, r3
 8000a0e:	f002 f861 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000a12:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000a14:	b2c1      	uxtb	r1, r0
 8000a16:	3201      	adds	r2, #1
 8000a18:	4648      	mov	r0, r9
 8000a1a:	b2d2      	uxtb	r2, r2
 8000a1c:	f003 fb4c 	bl	80040b8 <prvTraceSetObjectState>
            if( cTxLock == queueUNLOCKED )
 8000a20:	4643      	mov	r3, r8
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000a22:	3701      	adds	r7, #1
 8000a24:	63a7      	str	r7, [r4, #56]	; 0x38
            if( cTxLock == queueUNLOCKED )
 8000a26:	3301      	adds	r3, #1
 8000a28:	d04f      	beq.n	8000aca <xQueueGiveFromISR+0x116>
                configASSERT( cTxLock != queueINT8_MAX );
 8000a2a:	4643      	mov	r3, r8
 8000a2c:	2b7f      	cmp	r3, #127	; 0x7f
 8000a2e:	d05d      	beq.n	8000aec <xQueueGiveFromISR+0x138>
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8000a30:	2245      	movs	r2, #69	; 0x45
 8000a32:	3301      	adds	r3, #1
 8000a34:	b25b      	sxtb	r3, r3
            xReturn = pdPASS;
 8000a36:	2501      	movs	r5, #1
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8000a38:	54a3      	strb	r3, [r4, r2]
 8000a3a:	e024      	b.n	8000a86 <xQueueGiveFromISR+0xd2>
    configASSERT( pxQueue );
 8000a3c:	b672      	cpsid	i
 8000a3e:	e7fe      	b.n	8000a3e <xQueueGiveFromISR+0x8a>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8000a40:	6883      	ldr	r3, [r0, #8]
 8000a42:	2b00      	cmp	r3, #0
 8000a44:	d0c8      	beq.n	80009d8 <xQueueGiveFromISR+0x24>
 8000a46:	b672      	cpsid	i
 8000a48:	e7fe      	b.n	8000a48 <xQueueGiveFromISR+0x94>
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 8000a4a:	0020      	movs	r0, r4
 8000a4c:	f002 f848 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8000a50:	4b27      	ldr	r3, [pc, #156]	; (8000af0 <xQueueGiveFromISR+0x13c>)
            xReturn = errQUEUE_FULL;
 8000a52:	2500      	movs	r5, #0
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 8000a54:	881b      	ldrh	r3, [r3, #0]
 8000a56:	4203      	tst	r3, r0
 8000a58:	d015      	beq.n	8000a86 <xQueueGiveFromISR+0xd2>
 8000a5a:	0020      	movs	r0, r4
 8000a5c:	f002 f810 	bl	8002a80 <prvTraceGetQueueType>
 8000a60:	4b24      	ldr	r3, [pc, #144]	; (8000af4 <xQueueGiveFromISR+0x140>)
 8000a62:	4698      	mov	r8, r3
 8000a64:	5c1f      	ldrb	r7, [r3, r0]
 8000a66:	0020      	movs	r0, r4
 8000a68:	f002 f80a 	bl	8002a80 <prvTraceGetQueueType>
 8000a6c:	4643      	mov	r3, r8
 8000a6e:	5c1b      	ldrb	r3, [r3, r0]
 8000a70:	0020      	movs	r0, r4
 8000a72:	4698      	mov	r8, r3
 8000a74:	f002 f82e 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000a78:	3758      	adds	r7, #88	; 0x58
 8000a7a:	b2ff      	uxtb	r7, r7
 8000a7c:	b2c2      	uxtb	r2, r0
 8000a7e:	4641      	mov	r1, r8
 8000a80:	0038      	movs	r0, r7
 8000a82:	f002 fd9f 	bl	80035c4 <prvTraceStoreKernelCall>
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8000a86:	0030      	movs	r0, r6
 8000a88:	f001 ff30 	bl	80028ec <vClearInterruptMaskFromISR>
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
 8000a8c:	0028      	movs	r0, r5
 8000a8e:	bcf0      	pop	{r4, r5, r6, r7}
 8000a90:	46bb      	mov	fp, r7
 8000a92:	46b2      	mov	sl, r6
 8000a94:	46a9      	mov	r9, r5
 8000a96:	46a0      	mov	r8, r4
 8000a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            traceQUEUE_SEND_FROM_ISR( pxQueue );
 8000a9a:	0020      	movs	r0, r4
 8000a9c:	f001 fff0 	bl	8002a80 <prvTraceGetQueueType>
 8000aa0:	4b14      	ldr	r3, [pc, #80]	; (8000af4 <xQueueGiveFromISR+0x140>)
 8000aa2:	4699      	mov	r9, r3
 8000aa4:	5c1b      	ldrb	r3, [r3, r0]
 8000aa6:	0020      	movs	r0, r4
 8000aa8:	3330      	adds	r3, #48	; 0x30
 8000aaa:	b2db      	uxtb	r3, r3
 8000aac:	469a      	mov	sl, r3
 8000aae:	f001 ffe7 	bl	8002a80 <prvTraceGetQueueType>
 8000ab2:	464b      	mov	r3, r9
 8000ab4:	5c1b      	ldrb	r3, [r3, r0]
 8000ab6:	0020      	movs	r0, r4
 8000ab8:	469b      	mov	fp, r3
 8000aba:	f002 f80b 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000abe:	4659      	mov	r1, fp
 8000ac0:	b2c2      	uxtb	r2, r0
 8000ac2:	4650      	mov	r0, sl
 8000ac4:	f002 fd7e 	bl	80035c4 <prvTraceStoreKernelCall>
 8000ac8:	e79a      	b.n	8000a00 <xQueueGiveFromISR+0x4c>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000aca:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000acc:	2b00      	cmp	r3, #0
 8000ace:	d101      	bne.n	8000ad4 <xQueueGiveFromISR+0x120>
            xReturn = pdPASS;
 8000ad0:	2501      	movs	r5, #1
 8000ad2:	e7d8      	b.n	8000a86 <xQueueGiveFromISR+0xd2>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000ad4:	0020      	movs	r0, r4
 8000ad6:	3024      	adds	r0, #36	; 0x24
 8000ad8:	f001 fab8 	bl	800204c <xTaskRemoveFromEventList>
 8000adc:	2800      	cmp	r0, #0
 8000ade:	d0f7      	beq.n	8000ad0 <xQueueGiveFromISR+0x11c>
                                if( pxHigherPriorityTaskWoken != NULL )
 8000ae0:	2d00      	cmp	r5, #0
 8000ae2:	d0f5      	beq.n	8000ad0 <xQueueGiveFromISR+0x11c>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8000ae4:	2301      	movs	r3, #1
 8000ae6:	602b      	str	r3, [r5, #0]
            xReturn = pdPASS;
 8000ae8:	2501      	movs	r5, #1
 8000aea:	e7cc      	b.n	8000a86 <xQueueGiveFromISR+0xd2>
                configASSERT( cTxLock != queueINT8_MAX );
 8000aec:	b672      	cpsid	i
 8000aee:	e7fe      	b.n	8000aee <xQueueGiveFromISR+0x13a>
 8000af0:	20001d7e 	.word	0x20001d7e
 8000af4:	20000008 	.word	0x20000008

08000af8 <xQueueReceive>:
{
 8000af8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000afa:	46de      	mov	lr, fp
 8000afc:	4657      	mov	r7, sl
 8000afe:	464e      	mov	r6, r9
 8000b00:	4645      	mov	r5, r8
 8000b02:	b5e0      	push	{r5, r6, r7, lr}
 8000b04:	b085      	sub	sp, #20
 8000b06:	1e04      	subs	r4, r0, #0
 8000b08:	468b      	mov	fp, r1
 8000b0a:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 8000b0c:	d100      	bne.n	8000b10 <xQueueReceive+0x18>
 8000b0e:	e1a7      	b.n	8000e60 <xQueueReceive+0x368>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000b10:	2900      	cmp	r1, #0
 8000b12:	d100      	bne.n	8000b16 <xQueueReceive+0x1e>
 8000b14:	e0c3      	b.n	8000c9e <xQueueReceive+0x1a6>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000b16:	f001 fb43 	bl	80021a0 <xTaskGetSchedulerState>
 8000b1a:	2800      	cmp	r0, #0
 8000b1c:	d100      	bne.n	8000b20 <xQueueReceive+0x28>
 8000b1e:	e0c4      	b.n	8000caa <xQueueReceive+0x1b2>
        taskENTER_CRITICAL();
 8000b20:	f001 fec6 	bl	80028b0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000b24:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000b26:	2d00      	cmp	r5, #0
 8000b28:	d000      	beq.n	8000b2c <xQueueReceive+0x34>
 8000b2a:	e1f2      	b.n	8000f12 <xQueueReceive+0x41a>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000b2c:	9b01      	ldr	r3, [sp, #4]
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	d100      	bne.n	8000b34 <xQueueReceive+0x3c>
 8000b32:	e1f3      	b.n	8000f1c <xQueueReceive+0x424>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8000b34:	a802      	add	r0, sp, #8
 8000b36:	f001 fad9 	bl	80020ec <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8000b3a:	4bb5      	ldr	r3, [pc, #724]	; (8000e10 <xQueueReceive+0x318>)
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b3c:	0026      	movs	r6, r4
 8000b3e:	4698      	mov	r8, r3
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000b40:	4bb4      	ldr	r3, [pc, #720]	; (8000e14 <xQueueReceive+0x31c>)
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b42:	3624      	adds	r6, #36	; 0x24
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000b44:	4699      	mov	r9, r3
        taskEXIT_CRITICAL();
 8000b46:	f001 febf 	bl	80028c8 <vPortExitCritical>
        vTaskSuspendAll();
 8000b4a:	f000 ff1f 	bl	800198c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8000b4e:	f001 feaf 	bl	80028b0 <vPortEnterCritical>
 8000b52:	2244      	movs	r2, #68	; 0x44
 8000b54:	5ca3      	ldrb	r3, [r4, r2]
 8000b56:	b25b      	sxtb	r3, r3
 8000b58:	3301      	adds	r3, #1
 8000b5a:	d101      	bne.n	8000b60 <xQueueReceive+0x68>
 8000b5c:	2300      	movs	r3, #0
 8000b5e:	54a3      	strb	r3, [r4, r2]
 8000b60:	2245      	movs	r2, #69	; 0x45
 8000b62:	5ca3      	ldrb	r3, [r4, r2]
 8000b64:	b25b      	sxtb	r3, r3
 8000b66:	3301      	adds	r3, #1
 8000b68:	d101      	bne.n	8000b6e <xQueueReceive+0x76>
 8000b6a:	2300      	movs	r3, #0
 8000b6c:	54a3      	strb	r3, [r4, r2]
 8000b6e:	f001 feab 	bl	80028c8 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000b72:	a901      	add	r1, sp, #4
 8000b74:	a802      	add	r0, sp, #8
 8000b76:	f001 fac5 	bl	8002104 <xTaskCheckForTimeOut>
 8000b7a:	2800      	cmp	r0, #0
 8000b7c:	d000      	beq.n	8000b80 <xQueueReceive+0x88>
 8000b7e:	e09a      	b.n	8000cb6 <xQueueReceive+0x1be>
    taskENTER_CRITICAL();
 8000b80:	f001 fe96 	bl	80028b0 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8000b84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000b86:	2b00      	cmp	r3, #0
 8000b88:	d100      	bne.n	8000b8c <xQueueReceive+0x94>
 8000b8a:	e0fe      	b.n	8000d8a <xQueueReceive+0x292>
    taskEXIT_CRITICAL();
 8000b8c:	f001 fe9c 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000b90:	f001 fe8e 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000b94:	2345      	movs	r3, #69	; 0x45
 8000b96:	5ce5      	ldrb	r5, [r4, r3]
 8000b98:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000b9a:	2d00      	cmp	r5, #0
 8000b9c:	dc05      	bgt.n	8000baa <xQueueReceive+0xb2>
 8000b9e:	e013      	b.n	8000bc8 <xQueueReceive+0xd0>
            --cTxLock;
 8000ba0:	3d01      	subs	r5, #1
 8000ba2:	b2ea      	uxtb	r2, r5
 8000ba4:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000ba6:	2a00      	cmp	r2, #0
 8000ba8:	d00e      	beq.n	8000bc8 <xQueueReceive+0xd0>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000baa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000bac:	2b00      	cmp	r3, #0
 8000bae:	d00b      	beq.n	8000bc8 <xQueueReceive+0xd0>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000bb0:	0030      	movs	r0, r6
 8000bb2:	f001 fa4b 	bl	800204c <xTaskRemoveFromEventList>
 8000bb6:	2800      	cmp	r0, #0
 8000bb8:	d0f2      	beq.n	8000ba0 <xQueueReceive+0xa8>
                            vTaskMissedYield();
 8000bba:	3d01      	subs	r5, #1
 8000bbc:	f001 fada 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 8000bc0:	b2ea      	uxtb	r2, r5
 8000bc2:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000bc4:	2a00      	cmp	r2, #0
 8000bc6:	d1f0      	bne.n	8000baa <xQueueReceive+0xb2>
        pxQueue->cTxLock = queueUNLOCKED;
 8000bc8:	2345      	movs	r3, #69	; 0x45
 8000bca:	22ff      	movs	r2, #255	; 0xff
 8000bcc:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000bce:	f001 fe7b 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000bd2:	f001 fe6d 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000bd6:	2344      	movs	r3, #68	; 0x44
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000bd8:	0027      	movs	r7, r4
        int8_t cRxLock = pxQueue->cRxLock;
 8000bda:	5ce5      	ldrb	r5, [r4, r3]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000bdc:	3710      	adds	r7, #16
        int8_t cRxLock = pxQueue->cRxLock;
 8000bde:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000be0:	2d00      	cmp	r5, #0
 8000be2:	dc05      	bgt.n	8000bf0 <xQueueReceive+0xf8>
 8000be4:	e013      	b.n	8000c0e <xQueueReceive+0x116>
                --cRxLock;
 8000be6:	3d01      	subs	r5, #1
 8000be8:	b2ea      	uxtb	r2, r5
 8000bea:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000bec:	2a00      	cmp	r2, #0
 8000bee:	d00e      	beq.n	8000c0e <xQueueReceive+0x116>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000bf0:	6923      	ldr	r3, [r4, #16]
 8000bf2:	2b00      	cmp	r3, #0
 8000bf4:	d00b      	beq.n	8000c0e <xQueueReceive+0x116>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000bf6:	0038      	movs	r0, r7
 8000bf8:	f001 fa28 	bl	800204c <xTaskRemoveFromEventList>
 8000bfc:	2800      	cmp	r0, #0
 8000bfe:	d0f2      	beq.n	8000be6 <xQueueReceive+0xee>
                    vTaskMissedYield();
 8000c00:	3d01      	subs	r5, #1
 8000c02:	f001 fab7 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 8000c06:	b2ea      	uxtb	r2, r5
 8000c08:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000c0a:	2a00      	cmp	r2, #0
 8000c0c:	d1f0      	bne.n	8000bf0 <xQueueReceive+0xf8>
        pxQueue->cRxLock = queueUNLOCKED;
 8000c0e:	2344      	movs	r3, #68	; 0x44
 8000c10:	22ff      	movs	r2, #255	; 0xff
 8000c12:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000c14:	f001 fe58 	bl	80028c8 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 8000c18:	f001 f84c 	bl	8001cb4 <xTaskResumeAll>
        taskENTER_CRITICAL();
 8000c1c:	f001 fe48 	bl	80028b0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000c20:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000c22:	2d00      	cmp	r5, #0
 8000c24:	d100      	bne.n	8000c28 <xQueueReceive+0x130>
 8000c26:	e099      	b.n	8000d5c <xQueueReceive+0x264>
 8000c28:	4b7a      	ldr	r3, [pc, #488]	; (8000e14 <xQueueReceive+0x31c>)
 8000c2a:	469a      	mov	sl, r3
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000c2c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000c2e:	2a00      	cmp	r2, #0
 8000c30:	d00a      	beq.n	8000c48 <xQueueReceive+0x150>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000c32:	68e1      	ldr	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000c34:	68a3      	ldr	r3, [r4, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000c36:	1889      	adds	r1, r1, r2
 8000c38:	60e1      	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000c3a:	4299      	cmp	r1, r3
 8000c3c:	d301      	bcc.n	8000c42 <xQueueReceive+0x14a>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8000c3e:	6821      	ldr	r1, [r4, #0]
 8000c40:	60e1      	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8000c42:	4658      	mov	r0, fp
 8000c44:	f005 f8a0 	bl	8005d88 <memcpy>
                traceQUEUE_RECEIVE( pxQueue );
 8000c48:	f001 ff6a 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000c4c:	f001 ff22 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000c50:	4643      	mov	r3, r8
 8000c52:	881b      	ldrh	r3, [r3, #0]
 8000c54:	4203      	tst	r3, r0
 8000c56:	d000      	beq.n	8000c5a <xQueueReceive+0x162>
 8000c58:	e163      	b.n	8000f22 <xQueueReceive+0x42a>
 8000c5a:	0020      	movs	r0, r4
 8000c5c:	f001 ff10 	bl	8002a80 <prvTraceGetQueueType>
 8000c60:	4653      	mov	r3, sl
 8000c62:	5c1f      	ldrb	r7, [r3, r0]
 8000c64:	0020      	movs	r0, r4
 8000c66:	f001 ff35 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000c6a:	b2c6      	uxtb	r6, r0
 8000c6c:	0020      	movs	r0, r4
 8000c6e:	f001 ff07 	bl	8002a80 <prvTraceGetQueueType>
 8000c72:	4653      	mov	r3, sl
 8000c74:	5c1b      	ldrb	r3, [r3, r0]
 8000c76:	2b02      	cmp	r3, #2
 8000c78:	d100      	bne.n	8000c7c <xQueueReceive+0x184>
 8000c7a:	e16f      	b.n	8000f5c <xQueueReceive+0x464>
 8000c7c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000c7e:	3a01      	subs	r2, #1
 8000c80:	b2d2      	uxtb	r2, r2
 8000c82:	0031      	movs	r1, r6
 8000c84:	0038      	movs	r0, r7
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8000c86:	3d01      	subs	r5, #1
                traceQUEUE_RECEIVE( pxQueue );
 8000c88:	f003 fa16 	bl	80040b8 <prvTraceSetObjectState>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8000c8c:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000c8e:	6923      	ldr	r3, [r4, #16]
 8000c90:	2b00      	cmp	r3, #0
 8000c92:	d000      	beq.n	8000c96 <xQueueReceive+0x19e>
 8000c94:	e133      	b.n	8000efe <xQueueReceive+0x406>
                taskEXIT_CRITICAL();
 8000c96:	f001 fe17 	bl	80028c8 <vPortExitCritical>
                return pdPASS;
 8000c9a:	2001      	movs	r0, #1
 8000c9c:	e06e      	b.n	8000d7c <xQueueReceive+0x284>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000c9e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000ca0:	2b00      	cmp	r3, #0
 8000ca2:	d100      	bne.n	8000ca6 <xQueueReceive+0x1ae>
 8000ca4:	e737      	b.n	8000b16 <xQueueReceive+0x1e>
 8000ca6:	b672      	cpsid	i
 8000ca8:	e7fe      	b.n	8000ca8 <xQueueReceive+0x1b0>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000caa:	9b01      	ldr	r3, [sp, #4]
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	d100      	bne.n	8000cb2 <xQueueReceive+0x1ba>
 8000cb0:	e736      	b.n	8000b20 <xQueueReceive+0x28>
 8000cb2:	b672      	cpsid	i
 8000cb4:	e7fe      	b.n	8000cb4 <xQueueReceive+0x1bc>
    taskENTER_CRITICAL();
 8000cb6:	f001 fdfb 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000cba:	2345      	movs	r3, #69	; 0x45
 8000cbc:	5ce5      	ldrb	r5, [r4, r3]
 8000cbe:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000cc0:	2d00      	cmp	r5, #0
 8000cc2:	dc05      	bgt.n	8000cd0 <xQueueReceive+0x1d8>
 8000cc4:	e013      	b.n	8000cee <xQueueReceive+0x1f6>
            --cTxLock;
 8000cc6:	3d01      	subs	r5, #1
 8000cc8:	b2ea      	uxtb	r2, r5
 8000cca:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000ccc:	2a00      	cmp	r2, #0
 8000cce:	d00e      	beq.n	8000cee <xQueueReceive+0x1f6>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000cd0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000cd2:	2b00      	cmp	r3, #0
 8000cd4:	d00b      	beq.n	8000cee <xQueueReceive+0x1f6>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000cd6:	0030      	movs	r0, r6
 8000cd8:	f001 f9b8 	bl	800204c <xTaskRemoveFromEventList>
 8000cdc:	2800      	cmp	r0, #0
 8000cde:	d0f2      	beq.n	8000cc6 <xQueueReceive+0x1ce>
                            vTaskMissedYield();
 8000ce0:	3d01      	subs	r5, #1
 8000ce2:	f001 fa47 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 8000ce6:	b2ea      	uxtb	r2, r5
 8000ce8:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000cea:	2a00      	cmp	r2, #0
 8000cec:	d1f0      	bne.n	8000cd0 <xQueueReceive+0x1d8>
        pxQueue->cTxLock = queueUNLOCKED;
 8000cee:	2345      	movs	r3, #69	; 0x45
 8000cf0:	22ff      	movs	r2, #255	; 0xff
 8000cf2:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000cf4:	f001 fde8 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000cf8:	f001 fdda 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000cfc:	2344      	movs	r3, #68	; 0x44
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000cfe:	0027      	movs	r7, r4
        int8_t cRxLock = pxQueue->cRxLock;
 8000d00:	5ce5      	ldrb	r5, [r4, r3]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d02:	3710      	adds	r7, #16
        int8_t cRxLock = pxQueue->cRxLock;
 8000d04:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d06:	2d00      	cmp	r5, #0
 8000d08:	dc05      	bgt.n	8000d16 <xQueueReceive+0x21e>
 8000d0a:	e013      	b.n	8000d34 <xQueueReceive+0x23c>
                --cRxLock;
 8000d0c:	3d01      	subs	r5, #1
 8000d0e:	b2ea      	uxtb	r2, r5
 8000d10:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d12:	2a00      	cmp	r2, #0
 8000d14:	d00e      	beq.n	8000d34 <xQueueReceive+0x23c>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d16:	6923      	ldr	r3, [r4, #16]
 8000d18:	2b00      	cmp	r3, #0
 8000d1a:	d00b      	beq.n	8000d34 <xQueueReceive+0x23c>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d1c:	0038      	movs	r0, r7
 8000d1e:	f001 f995 	bl	800204c <xTaskRemoveFromEventList>
 8000d22:	2800      	cmp	r0, #0
 8000d24:	d0f2      	beq.n	8000d0c <xQueueReceive+0x214>
                    vTaskMissedYield();
 8000d26:	3d01      	subs	r5, #1
 8000d28:	f001 fa24 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 8000d2c:	b2ea      	uxtb	r2, r5
 8000d2e:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d30:	2a00      	cmp	r2, #0
 8000d32:	d1f0      	bne.n	8000d16 <xQueueReceive+0x21e>
        pxQueue->cRxLock = queueUNLOCKED;
 8000d34:	2344      	movs	r3, #68	; 0x44
 8000d36:	22ff      	movs	r2, #255	; 0xff
 8000d38:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000d3a:	f001 fdc5 	bl	80028c8 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 8000d3e:	f000 ffb9 	bl	8001cb4 <xTaskResumeAll>
    taskENTER_CRITICAL();
 8000d42:	f001 fdb5 	bl	80028b0 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8000d46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000d48:	2b00      	cmp	r3, #0
 8000d4a:	d00b      	beq.n	8000d64 <xQueueReceive+0x26c>
    taskEXIT_CRITICAL();
 8000d4c:	f001 fdbc 	bl	80028c8 <vPortExitCritical>
        taskENTER_CRITICAL();
 8000d50:	f001 fdae 	bl	80028b0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000d54:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000d56:	2d00      	cmp	r5, #0
 8000d58:	d000      	beq.n	8000d5c <xQueueReceive+0x264>
 8000d5a:	e765      	b.n	8000c28 <xQueueReceive+0x130>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000d5c:	9b01      	ldr	r3, [sp, #4]
 8000d5e:	2b00      	cmp	r3, #0
 8000d60:	d000      	beq.n	8000d64 <xQueueReceive+0x26c>
 8000d62:	e6f0      	b.n	8000b46 <xQueueReceive+0x4e>
    taskEXIT_CRITICAL();
 8000d64:	f001 fdb0 	bl	80028c8 <vPortExitCritical>
                traceQUEUE_RECEIVE_FAILED( pxQueue );
 8000d68:	f001 feda 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000d6c:	f001 fe92 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000d70:	4643      	mov	r3, r8
 8000d72:	881b      	ldrh	r3, [r3, #0]
 8000d74:	4203      	tst	r3, r0
 8000d76:	d000      	beq.n	8000d7a <xQueueReceive+0x282>
 8000d78:	e084      	b.n	8000e84 <xQueueReceive+0x38c>
                return errQUEUE_EMPTY;
 8000d7a:	2000      	movs	r0, #0
}
 8000d7c:	b005      	add	sp, #20
 8000d7e:	bcf0      	pop	{r4, r5, r6, r7}
 8000d80:	46bb      	mov	fp, r7
 8000d82:	46b2      	mov	sl, r6
 8000d84:	46a9      	mov	r9, r5
 8000d86:	46a0      	mov	r8, r4
 8000d88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    taskEXIT_CRITICAL();
 8000d8a:	f001 fd9d 	bl	80028c8 <vPortExitCritical>
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000d8e:	f001 fec7 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000d92:	f001 fe7f 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000d96:	4643      	mov	r3, r8
 8000d98:	881b      	ldrh	r3, [r3, #0]
 8000d9a:	4203      	tst	r3, r0
 8000d9c:	d000      	beq.n	8000da0 <xQueueReceive+0x2a8>
 8000d9e:	e090      	b.n	8000ec2 <xQueueReceive+0x3ca>
 8000da0:	4b1c      	ldr	r3, [pc, #112]	; (8000e14 <xQueueReceive+0x31c>)
 8000da2:	469a      	mov	sl, r3
 8000da4:	0020      	movs	r0, r4
 8000da6:	f001 fe6b 	bl	8002a80 <prvTraceGetQueueType>
 8000daa:	4653      	mov	r3, sl
 8000dac:	5c1b      	ldrb	r3, [r3, r0]
 8000dae:	2b02      	cmp	r3, #2
 8000db0:	d158      	bne.n	8000e64 <xQueueReceive+0x36c>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8000db2:	0030      	movs	r0, r6
 8000db4:	9901      	ldr	r1, [sp, #4]
 8000db6:	f001 f88d 	bl	8001ed4 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 8000dba:	f001 fd79 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000dbe:	2345      	movs	r3, #69	; 0x45
 8000dc0:	5ce5      	ldrb	r5, [r4, r3]
 8000dc2:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000dc4:	2d00      	cmp	r5, #0
 8000dc6:	dc05      	bgt.n	8000dd4 <xQueueReceive+0x2dc>
 8000dc8:	e013      	b.n	8000df2 <xQueueReceive+0x2fa>
            --cTxLock;
 8000dca:	3d01      	subs	r5, #1
 8000dcc:	b2ea      	uxtb	r2, r5
 8000dce:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000dd0:	2a00      	cmp	r2, #0
 8000dd2:	d00e      	beq.n	8000df2 <xQueueReceive+0x2fa>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000dd4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000dd6:	2b00      	cmp	r3, #0
 8000dd8:	d00b      	beq.n	8000df2 <xQueueReceive+0x2fa>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000dda:	0030      	movs	r0, r6
 8000ddc:	f001 f936 	bl	800204c <xTaskRemoveFromEventList>
 8000de0:	2800      	cmp	r0, #0
 8000de2:	d0f2      	beq.n	8000dca <xQueueReceive+0x2d2>
                            vTaskMissedYield();
 8000de4:	3d01      	subs	r5, #1
 8000de6:	f001 f9c5 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 8000dea:	b2ea      	uxtb	r2, r5
 8000dec:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000dee:	2a00      	cmp	r2, #0
 8000df0:	d1f0      	bne.n	8000dd4 <xQueueReceive+0x2dc>
        pxQueue->cTxLock = queueUNLOCKED;
 8000df2:	2345      	movs	r3, #69	; 0x45
 8000df4:	22ff      	movs	r2, #255	; 0xff
 8000df6:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000df8:	f001 fd66 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000dfc:	f001 fd58 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000e00:	2344      	movs	r3, #68	; 0x44
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000e02:	0025      	movs	r5, r4
        int8_t cRxLock = pxQueue->cRxLock;
 8000e04:	5ce7      	ldrb	r7, [r4, r3]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000e06:	3510      	adds	r5, #16
        int8_t cRxLock = pxQueue->cRxLock;
 8000e08:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000e0a:	2f00      	cmp	r7, #0
 8000e0c:	dc09      	bgt.n	8000e22 <xQueueReceive+0x32a>
 8000e0e:	e017      	b.n	8000e40 <xQueueReceive+0x348>
 8000e10:	20001d7e 	.word	0x20001d7e
 8000e14:	20000008 	.word	0x20000008
                --cRxLock;
 8000e18:	3f01      	subs	r7, #1
 8000e1a:	b2fa      	uxtb	r2, r7
 8000e1c:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000e1e:	2a00      	cmp	r2, #0
 8000e20:	d00e      	beq.n	8000e40 <xQueueReceive+0x348>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000e22:	6923      	ldr	r3, [r4, #16]
 8000e24:	2b00      	cmp	r3, #0
 8000e26:	d00b      	beq.n	8000e40 <xQueueReceive+0x348>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000e28:	0028      	movs	r0, r5
 8000e2a:	f001 f90f 	bl	800204c <xTaskRemoveFromEventList>
 8000e2e:	2800      	cmp	r0, #0
 8000e30:	d0f2      	beq.n	8000e18 <xQueueReceive+0x320>
                    vTaskMissedYield();
 8000e32:	3f01      	subs	r7, #1
 8000e34:	f001 f99e 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 8000e38:	b2fa      	uxtb	r2, r7
 8000e3a:	b27f      	sxtb	r7, r7
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000e3c:	2a00      	cmp	r2, #0
 8000e3e:	d1f0      	bne.n	8000e22 <xQueueReceive+0x32a>
        pxQueue->cRxLock = queueUNLOCKED;
 8000e40:	2344      	movs	r3, #68	; 0x44
 8000e42:	22ff      	movs	r2, #255	; 0xff
 8000e44:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 8000e46:	f001 fd3f 	bl	80028c8 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 8000e4a:	f000 ff33 	bl	8001cb4 <xTaskResumeAll>
 8000e4e:	2800      	cmp	r0, #0
 8000e50:	d034      	beq.n	8000ebc <xQueueReceive+0x3c4>
        taskENTER_CRITICAL();
 8000e52:	f001 fd2d 	bl	80028b0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000e56:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000e58:	2d00      	cmp	r5, #0
 8000e5a:	d100      	bne.n	8000e5e <xQueueReceive+0x366>
 8000e5c:	e77e      	b.n	8000d5c <xQueueReceive+0x264>
 8000e5e:	e6e5      	b.n	8000c2c <xQueueReceive+0x134>
    configASSERT( ( pxQueue ) );
 8000e60:	b672      	cpsid	i
 8000e62:	e7fe      	b.n	8000e62 <xQueueReceive+0x36a>
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000e64:	f001 fe5c 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000e68:	f001 fe14 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8000e6c:	4643      	mov	r3, r8
 8000e6e:	881b      	ldrh	r3, [r3, #0]
 8000e70:	4203      	tst	r3, r0
 8000e72:	d09e      	beq.n	8000db2 <xQueueReceive+0x2ba>
 8000e74:	f001 fe54 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000e78:	f001 fe06 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8000e7c:	b2c0      	uxtb	r0, r0
 8000e7e:	f003 f9cb 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8000e82:	e796      	b.n	8000db2 <xQueueReceive+0x2ba>
                traceQUEUE_RECEIVE_FAILED( pxQueue );
 8000e84:	0020      	movs	r0, r4
 8000e86:	f001 fe2b 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8000e8a:	4643      	mov	r3, r8
 8000e8c:	881b      	ldrh	r3, [r3, #0]
 8000e8e:	4203      	tst	r3, r0
 8000e90:	d100      	bne.n	8000e94 <xQueueReceive+0x39c>
 8000e92:	e772      	b.n	8000d7a <xQueueReceive+0x282>
 8000e94:	0020      	movs	r0, r4
 8000e96:	f001 fdf3 	bl	8002a80 <prvTraceGetQueueType>
 8000e9a:	4e33      	ldr	r6, [pc, #204]	; (8000f68 <xQueueReceive+0x470>)
 8000e9c:	5c35      	ldrb	r5, [r6, r0]
 8000e9e:	0020      	movs	r0, r4
 8000ea0:	f001 fdee 	bl	8002a80 <prvTraceGetQueueType>
 8000ea4:	5c36      	ldrb	r6, [r6, r0]
 8000ea6:	0020      	movs	r0, r4
 8000ea8:	f001 fe14 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000eac:	3550      	adds	r5, #80	; 0x50
 8000eae:	b2ed      	uxtb	r5, r5
 8000eb0:	b2c2      	uxtb	r2, r0
 8000eb2:	0031      	movs	r1, r6
 8000eb4:	0028      	movs	r0, r5
 8000eb6:	f002 fb85 	bl	80035c4 <prvTraceStoreKernelCall>
 8000eba:	e75e      	b.n	8000d7a <xQueueReceive+0x282>
                    portYIELD_WITHIN_API();
 8000ebc:	f001 fcec 	bl	8002898 <vPortYield>
 8000ec0:	e7c7      	b.n	8000e52 <xQueueReceive+0x35a>
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000ec2:	0020      	movs	r0, r4
 8000ec4:	f001 fe0c 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8000ec8:	4643      	mov	r3, r8
 8000eca:	881b      	ldrh	r3, [r3, #0]
 8000ecc:	4203      	tst	r3, r0
 8000ece:	d100      	bne.n	8000ed2 <xQueueReceive+0x3da>
 8000ed0:	e766      	b.n	8000da0 <xQueueReceive+0x2a8>
 8000ed2:	0020      	movs	r0, r4
 8000ed4:	f001 fdd4 	bl	8002a80 <prvTraceGetQueueType>
 8000ed8:	464b      	mov	r3, r9
 8000eda:	5c1d      	ldrb	r5, [r3, r0]
 8000edc:	0020      	movs	r0, r4
 8000ede:	f001 fdcf 	bl	8002a80 <prvTraceGetQueueType>
 8000ee2:	464b      	mov	r3, r9
 8000ee4:	5c1f      	ldrb	r7, [r3, r0]
 8000ee6:	0020      	movs	r0, r4
 8000ee8:	f001 fdf4 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000eec:	3568      	adds	r5, #104	; 0x68
 8000eee:	b2ed      	uxtb	r5, r5
 8000ef0:	b2c2      	uxtb	r2, r0
 8000ef2:	0039      	movs	r1, r7
 8000ef4:	0028      	movs	r0, r5
 8000ef6:	46ca      	mov	sl, r9
 8000ef8:	f002 fb64 	bl	80035c4 <prvTraceStoreKernelCall>
 8000efc:	e752      	b.n	8000da4 <xQueueReceive+0x2ac>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000efe:	0020      	movs	r0, r4
 8000f00:	3010      	adds	r0, #16
 8000f02:	f001 f8a3 	bl	800204c <xTaskRemoveFromEventList>
 8000f06:	2800      	cmp	r0, #0
 8000f08:	d100      	bne.n	8000f0c <xQueueReceive+0x414>
 8000f0a:	e6c4      	b.n	8000c96 <xQueueReceive+0x19e>
                        queueYIELD_IF_USING_PREEMPTION();
 8000f0c:	f001 fcc4 	bl	8002898 <vPortYield>
 8000f10:	e6c1      	b.n	8000c96 <xQueueReceive+0x19e>
 8000f12:	4b16      	ldr	r3, [pc, #88]	; (8000f6c <xQueueReceive+0x474>)
 8000f14:	4698      	mov	r8, r3
 8000f16:	4b14      	ldr	r3, [pc, #80]	; (8000f68 <xQueueReceive+0x470>)
 8000f18:	469a      	mov	sl, r3
 8000f1a:	e687      	b.n	8000c2c <xQueueReceive+0x134>
 8000f1c:	4b13      	ldr	r3, [pc, #76]	; (8000f6c <xQueueReceive+0x474>)
 8000f1e:	4698      	mov	r8, r3
 8000f20:	e720      	b.n	8000d64 <xQueueReceive+0x26c>
                traceQUEUE_RECEIVE( pxQueue );
 8000f22:	0020      	movs	r0, r4
 8000f24:	f001 fddc 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8000f28:	4643      	mov	r3, r8
 8000f2a:	881b      	ldrh	r3, [r3, #0]
 8000f2c:	4203      	tst	r3, r0
 8000f2e:	d100      	bne.n	8000f32 <xQueueReceive+0x43a>
 8000f30:	e693      	b.n	8000c5a <xQueueReceive+0x162>
 8000f32:	0020      	movs	r0, r4
 8000f34:	f001 fda4 	bl	8002a80 <prvTraceGetQueueType>
 8000f38:	4653      	mov	r3, sl
 8000f3a:	5c1e      	ldrb	r6, [r3, r0]
 8000f3c:	0020      	movs	r0, r4
 8000f3e:	f001 fd9f 	bl	8002a80 <prvTraceGetQueueType>
 8000f42:	4653      	mov	r3, sl
 8000f44:	5c1f      	ldrb	r7, [r3, r0]
 8000f46:	0020      	movs	r0, r4
 8000f48:	f001 fdc4 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8000f4c:	3628      	adds	r6, #40	; 0x28
 8000f4e:	b2f6      	uxtb	r6, r6
 8000f50:	b2c2      	uxtb	r2, r0
 8000f52:	0039      	movs	r1, r7
 8000f54:	0030      	movs	r0, r6
 8000f56:	f002 fb35 	bl	80035c4 <prvTraceStoreKernelCall>
 8000f5a:	e67e      	b.n	8000c5a <xQueueReceive+0x162>
 8000f5c:	f001 fde0 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8000f60:	f001 fd92 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8000f64:	b2c2      	uxtb	r2, r0
 8000f66:	e68c      	b.n	8000c82 <xQueueReceive+0x18a>
 8000f68:	20000008 	.word	0x20000008
 8000f6c:	20001d7e 	.word	0x20001d7e

08000f70 <xQueueSemaphoreTake>:
{
 8000f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f72:	46de      	mov	lr, fp
 8000f74:	4657      	mov	r7, sl
 8000f76:	464e      	mov	r6, r9
 8000f78:	4645      	mov	r5, r8
 8000f7a:	b5e0      	push	{r5, r6, r7, lr}
 8000f7c:	b085      	sub	sp, #20
 8000f7e:	1e04      	subs	r4, r0, #0
 8000f80:	9101      	str	r1, [sp, #4]
    configASSERT( ( pxQueue ) );
 8000f82:	d05d      	beq.n	8001040 <xQueueSemaphoreTake+0xd0>
    configASSERT( pxQueue->uxItemSize == 0 );
 8000f84:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000f86:	2b00      	cmp	r3, #0
 8000f88:	d001      	beq.n	8000f8e <xQueueSemaphoreTake+0x1e>
 8000f8a:	b672      	cpsid	i
 8000f8c:	e7fe      	b.n	8000f8c <xQueueSemaphoreTake+0x1c>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000f8e:	f001 f907 	bl	80021a0 <xTaskGetSchedulerState>
 8000f92:	1e05      	subs	r5, r0, #0
 8000f94:	d056      	beq.n	8001044 <xQueueSemaphoreTake+0xd4>
 8000f96:	2300      	movs	r3, #0
 8000f98:	2500      	movs	r5, #0
 8000f9a:	469b      	mov	fp, r3
 8000f9c:	4bbd      	ldr	r3, [pc, #756]	; (8001294 <xQueueSemaphoreTake+0x324>)
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000f9e:	0026      	movs	r6, r4
 8000fa0:	4698      	mov	r8, r3
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000fa2:	4bbd      	ldr	r3, [pc, #756]	; (8001298 <xQueueSemaphoreTake+0x328>)
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000fa4:	3624      	adds	r6, #36	; 0x24
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 8000fa6:	469a      	mov	sl, r3
        taskENTER_CRITICAL();
 8000fa8:	f001 fc82 	bl	80028b0 <vPortEnterCritical>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8000fac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000fae:	4699      	mov	r9, r3
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8000fb0:	2b00      	cmp	r3, #0
 8000fb2:	d000      	beq.n	8000fb6 <xQueueSemaphoreTake+0x46>
 8000fb4:	e1ab      	b.n	800130e <xQueueSemaphoreTake+0x39e>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000fb6:	9b01      	ldr	r3, [sp, #4]
 8000fb8:	2b00      	cmp	r3, #0
 8000fba:	d100      	bne.n	8000fbe <xQueueSemaphoreTake+0x4e>
 8000fbc:	e1a2      	b.n	8001304 <xQueueSemaphoreTake+0x394>
                else if( xEntryTimeSet == pdFALSE )
 8000fbe:	2d00      	cmp	r5, #0
 8000fc0:	d100      	bne.n	8000fc4 <xQueueSemaphoreTake+0x54>
 8000fc2:	e094      	b.n	80010ee <xQueueSemaphoreTake+0x17e>
        taskEXIT_CRITICAL();
 8000fc4:	f001 fc80 	bl	80028c8 <vPortExitCritical>
        vTaskSuspendAll();
 8000fc8:	f000 fce0 	bl	800198c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8000fcc:	f001 fc70 	bl	80028b0 <vPortEnterCritical>
 8000fd0:	2244      	movs	r2, #68	; 0x44
 8000fd2:	5ca3      	ldrb	r3, [r4, r2]
 8000fd4:	b25b      	sxtb	r3, r3
 8000fd6:	3301      	adds	r3, #1
 8000fd8:	d101      	bne.n	8000fde <xQueueSemaphoreTake+0x6e>
 8000fda:	2300      	movs	r3, #0
 8000fdc:	54a3      	strb	r3, [r4, r2]
 8000fde:	2245      	movs	r2, #69	; 0x45
 8000fe0:	5ca3      	ldrb	r3, [r4, r2]
 8000fe2:	b25b      	sxtb	r3, r3
 8000fe4:	3301      	adds	r3, #1
 8000fe6:	d101      	bne.n	8000fec <xQueueSemaphoreTake+0x7c>
 8000fe8:	2300      	movs	r3, #0
 8000fea:	54a3      	strb	r3, [r4, r2]
 8000fec:	f001 fc6c 	bl	80028c8 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000ff0:	a901      	add	r1, sp, #4
 8000ff2:	a802      	add	r0, sp, #8
 8000ff4:	f001 f886 	bl	8002104 <xTaskCheckForTimeOut>
 8000ff8:	2800      	cmp	r0, #0
 8000ffa:	d129      	bne.n	8001050 <xQueueSemaphoreTake+0xe0>
    taskENTER_CRITICAL();
 8000ffc:	f001 fc58 	bl	80028b0 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8001000:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001002:	2b00      	cmp	r3, #0
 8001004:	d100      	bne.n	8001008 <xQueueSemaphoreTake+0x98>
 8001006:	e0b7      	b.n	8001178 <xQueueSemaphoreTake+0x208>
    taskEXIT_CRITICAL();
 8001008:	f001 fc5e 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 800100c:	f001 fc50 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8001010:	2345      	movs	r3, #69	; 0x45
 8001012:	5ce5      	ldrb	r5, [r4, r3]
 8001014:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001016:	2d00      	cmp	r5, #0
 8001018:	dc06      	bgt.n	8001028 <xQueueSemaphoreTake+0xb8>
 800101a:	e085      	b.n	8001128 <xQueueSemaphoreTake+0x1b8>
            --cTxLock;
 800101c:	3d01      	subs	r5, #1
 800101e:	b2ea      	uxtb	r2, r5
 8001020:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001022:	2a00      	cmp	r2, #0
 8001024:	d100      	bne.n	8001028 <xQueueSemaphoreTake+0xb8>
 8001026:	e07f      	b.n	8001128 <xQueueSemaphoreTake+0x1b8>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001028:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800102a:	2b00      	cmp	r3, #0
 800102c:	d100      	bne.n	8001030 <xQueueSemaphoreTake+0xc0>
 800102e:	e07b      	b.n	8001128 <xQueueSemaphoreTake+0x1b8>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001030:	0030      	movs	r0, r6
 8001032:	f001 f80b 	bl	800204c <xTaskRemoveFromEventList>
 8001036:	2800      	cmp	r0, #0
 8001038:	d0f0      	beq.n	800101c <xQueueSemaphoreTake+0xac>
                            vTaskMissedYield();
 800103a:	f001 f89b 	bl	8002174 <vTaskMissedYield>
 800103e:	e7ed      	b.n	800101c <xQueueSemaphoreTake+0xac>
    configASSERT( ( pxQueue ) );
 8001040:	b672      	cpsid	i
 8001042:	e7fe      	b.n	8001042 <xQueueSemaphoreTake+0xd2>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001044:	9b01      	ldr	r3, [sp, #4]
 8001046:	2b00      	cmp	r3, #0
 8001048:	d100      	bne.n	800104c <xQueueSemaphoreTake+0xdc>
 800104a:	e0fb      	b.n	8001244 <xQueueSemaphoreTake+0x2d4>
 800104c:	b672      	cpsid	i
 800104e:	e7fe      	b.n	800104e <xQueueSemaphoreTake+0xde>
    taskENTER_CRITICAL();
 8001050:	f001 fc2e 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8001054:	2345      	movs	r3, #69	; 0x45
 8001056:	5ce5      	ldrb	r5, [r4, r3]
 8001058:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800105a:	2d00      	cmp	r5, #0
 800105c:	dc05      	bgt.n	800106a <xQueueSemaphoreTake+0xfa>
 800105e:	e013      	b.n	8001088 <xQueueSemaphoreTake+0x118>
            --cTxLock;
 8001060:	3d01      	subs	r5, #1
 8001062:	b2ea      	uxtb	r2, r5
 8001064:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001066:	2a00      	cmp	r2, #0
 8001068:	d00e      	beq.n	8001088 <xQueueSemaphoreTake+0x118>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800106a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800106c:	2b00      	cmp	r3, #0
 800106e:	d00b      	beq.n	8001088 <xQueueSemaphoreTake+0x118>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001070:	0030      	movs	r0, r6
 8001072:	f000 ffeb 	bl	800204c <xTaskRemoveFromEventList>
 8001076:	2800      	cmp	r0, #0
 8001078:	d0f2      	beq.n	8001060 <xQueueSemaphoreTake+0xf0>
                            vTaskMissedYield();
 800107a:	3d01      	subs	r5, #1
 800107c:	f001 f87a 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 8001080:	b2ea      	uxtb	r2, r5
 8001082:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001084:	2a00      	cmp	r2, #0
 8001086:	d1f0      	bne.n	800106a <xQueueSemaphoreTake+0xfa>
        pxQueue->cTxLock = queueUNLOCKED;
 8001088:	2345      	movs	r3, #69	; 0x45
 800108a:	22ff      	movs	r2, #255	; 0xff
 800108c:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800108e:	f001 fc1b 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001092:	f001 fc0d 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001096:	2344      	movs	r3, #68	; 0x44
 8001098:	5ce5      	ldrb	r5, [r4, r3]
 800109a:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800109c:	2d00      	cmp	r5, #0
 800109e:	dd16      	ble.n	80010ce <xQueueSemaphoreTake+0x15e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010a0:	0027      	movs	r7, r4
 80010a2:	3710      	adds	r7, #16
 80010a4:	e004      	b.n	80010b0 <xQueueSemaphoreTake+0x140>
                --cRxLock;
 80010a6:	3d01      	subs	r5, #1
 80010a8:	b2ea      	uxtb	r2, r5
 80010aa:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80010ac:	2a00      	cmp	r2, #0
 80010ae:	d00e      	beq.n	80010ce <xQueueSemaphoreTake+0x15e>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80010b0:	6923      	ldr	r3, [r4, #16]
 80010b2:	2b00      	cmp	r3, #0
 80010b4:	d00b      	beq.n	80010ce <xQueueSemaphoreTake+0x15e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010b6:	0038      	movs	r0, r7
 80010b8:	f000 ffc8 	bl	800204c <xTaskRemoveFromEventList>
 80010bc:	2800      	cmp	r0, #0
 80010be:	d0f2      	beq.n	80010a6 <xQueueSemaphoreTake+0x136>
                    vTaskMissedYield();
 80010c0:	3d01      	subs	r5, #1
 80010c2:	f001 f857 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 80010c6:	b2ea      	uxtb	r2, r5
 80010c8:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80010ca:	2a00      	cmp	r2, #0
 80010cc:	d1f0      	bne.n	80010b0 <xQueueSemaphoreTake+0x140>
        pxQueue->cRxLock = queueUNLOCKED;
 80010ce:	2344      	movs	r3, #68	; 0x44
 80010d0:	22ff      	movs	r2, #255	; 0xff
 80010d2:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 80010d4:	f001 fbf8 	bl	80028c8 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 80010d8:	f000 fdec 	bl	8001cb4 <xTaskResumeAll>
    taskENTER_CRITICAL();
 80010dc:	f001 fbe8 	bl	80028b0 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80010e0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80010e2:	2b00      	cmp	r3, #0
 80010e4:	d007      	beq.n	80010f6 <xQueueSemaphoreTake+0x186>
    taskEXIT_CRITICAL();
 80010e6:	f001 fbef 	bl	80028c8 <vPortExitCritical>
    return xReturn;
 80010ea:	2501      	movs	r5, #1
 80010ec:	e75c      	b.n	8000fa8 <xQueueSemaphoreTake+0x38>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 80010ee:	a802      	add	r0, sp, #8
 80010f0:	f000 fffc 	bl	80020ec <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 80010f4:	e766      	b.n	8000fc4 <xQueueSemaphoreTake+0x54>
    taskEXIT_CRITICAL();
 80010f6:	f001 fbe7 	bl	80028c8 <vPortExitCritical>
                        if( xInheritanceOccurred != pdFALSE )
 80010fa:	465b      	mov	r3, fp
 80010fc:	2b00      	cmp	r3, #0
 80010fe:	d000      	beq.n	8001102 <xQueueSemaphoreTake+0x192>
 8001100:	e0e8      	b.n	80012d4 <xQueueSemaphoreTake+0x364>
                traceQUEUE_RECEIVE_FAILED( pxQueue );
 8001102:	f001 fd0d 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001106:	f001 fcc5 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 800110a:	4643      	mov	r3, r8
 800110c:	881b      	ldrh	r3, [r3, #0]
 800110e:	4203      	tst	r3, r0
 8001110:	d000      	beq.n	8001114 <xQueueSemaphoreTake+0x1a4>
 8001112:	e0c3      	b.n	800129c <xQueueSemaphoreTake+0x32c>
                return errQUEUE_EMPTY;
 8001114:	2300      	movs	r3, #0
 8001116:	469b      	mov	fp, r3
}
 8001118:	4658      	mov	r0, fp
 800111a:	b005      	add	sp, #20
 800111c:	bcf0      	pop	{r4, r5, r6, r7}
 800111e:	46bb      	mov	fp, r7
 8001120:	46b2      	mov	sl, r6
 8001122:	46a9      	mov	r9, r5
 8001124:	46a0      	mov	r8, r4
 8001126:	bdf0      	pop	{r4, r5, r6, r7, pc}
        pxQueue->cTxLock = queueUNLOCKED;
 8001128:	2345      	movs	r3, #69	; 0x45
 800112a:	22ff      	movs	r2, #255	; 0xff
 800112c:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800112e:	f001 fbcb 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001132:	f001 fbbd 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001136:	2344      	movs	r3, #68	; 0x44
 8001138:	5ce5      	ldrb	r5, [r4, r3]
 800113a:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800113c:	2d00      	cmp	r5, #0
 800113e:	dd12      	ble.n	8001166 <xQueueSemaphoreTake+0x1f6>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001140:	0027      	movs	r7, r4
 8001142:	3710      	adds	r7, #16
 8001144:	e004      	b.n	8001150 <xQueueSemaphoreTake+0x1e0>
                --cRxLock;
 8001146:	3d01      	subs	r5, #1
 8001148:	b2ea      	uxtb	r2, r5
 800114a:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800114c:	2a00      	cmp	r2, #0
 800114e:	d00a      	beq.n	8001166 <xQueueSemaphoreTake+0x1f6>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001150:	6923      	ldr	r3, [r4, #16]
 8001152:	2b00      	cmp	r3, #0
 8001154:	d007      	beq.n	8001166 <xQueueSemaphoreTake+0x1f6>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001156:	0038      	movs	r0, r7
 8001158:	f000 ff78 	bl	800204c <xTaskRemoveFromEventList>
 800115c:	2800      	cmp	r0, #0
 800115e:	d0f2      	beq.n	8001146 <xQueueSemaphoreTake+0x1d6>
                    vTaskMissedYield();
 8001160:	f001 f808 	bl	8002174 <vTaskMissedYield>
 8001164:	e7ef      	b.n	8001146 <xQueueSemaphoreTake+0x1d6>
        pxQueue->cRxLock = queueUNLOCKED;
 8001166:	2344      	movs	r3, #68	; 0x44
 8001168:	22ff      	movs	r2, #255	; 0xff
 800116a:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800116c:	f001 fbac 	bl	80028c8 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 8001170:	2501      	movs	r5, #1
 8001172:	f000 fd9f 	bl	8001cb4 <xTaskResumeAll>
 8001176:	e717      	b.n	8000fa8 <xQueueSemaphoreTake+0x38>
    taskEXIT_CRITICAL();
 8001178:	f001 fba6 	bl	80028c8 <vPortExitCritical>
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 800117c:	f001 fcd0 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001180:	f001 fc88 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001184:	4643      	mov	r3, r8
 8001186:	881b      	ldrh	r3, [r3, #0]
 8001188:	4203      	tst	r3, r0
 800118a:	d15e      	bne.n	800124a <xQueueSemaphoreTake+0x2da>
 800118c:	4d42      	ldr	r5, [pc, #264]	; (8001298 <xQueueSemaphoreTake+0x328>)
 800118e:	0020      	movs	r0, r4
 8001190:	f001 fc76 	bl	8002a80 <prvTraceGetQueueType>
 8001194:	5c2b      	ldrb	r3, [r5, r0]
 8001196:	2b02      	cmp	r3, #2
 8001198:	d007      	beq.n	80011aa <xQueueSemaphoreTake+0x23a>
 800119a:	f001 fcc1 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 800119e:	f001 fc79 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80011a2:	4643      	mov	r3, r8
 80011a4:	881b      	ldrh	r3, [r3, #0]
 80011a6:	4203      	tst	r3, r0
 80011a8:	d16b      	bne.n	8001282 <xQueueSemaphoreTake+0x312>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80011aa:	6823      	ldr	r3, [r4, #0]
 80011ac:	2b00      	cmp	r3, #0
 80011ae:	d100      	bne.n	80011b2 <xQueueSemaphoreTake+0x242>
 80011b0:	e09f      	b.n	80012f2 <xQueueSemaphoreTake+0x382>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80011b2:	0030      	movs	r0, r6
 80011b4:	9901      	ldr	r1, [sp, #4]
 80011b6:	f000 fe8d 	bl	8001ed4 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 80011ba:	f001 fb79 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80011be:	2345      	movs	r3, #69	; 0x45
 80011c0:	5ce5      	ldrb	r5, [r4, r3]
 80011c2:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80011c4:	2d00      	cmp	r5, #0
 80011c6:	dc05      	bgt.n	80011d4 <xQueueSemaphoreTake+0x264>
 80011c8:	e00f      	b.n	80011ea <xQueueSemaphoreTake+0x27a>
            --cTxLock;
 80011ca:	3d01      	subs	r5, #1
 80011cc:	b2ea      	uxtb	r2, r5
 80011ce:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80011d0:	2a00      	cmp	r2, #0
 80011d2:	d00a      	beq.n	80011ea <xQueueSemaphoreTake+0x27a>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80011d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80011d6:	2b00      	cmp	r3, #0
 80011d8:	d007      	beq.n	80011ea <xQueueSemaphoreTake+0x27a>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80011da:	0030      	movs	r0, r6
 80011dc:	f000 ff36 	bl	800204c <xTaskRemoveFromEventList>
 80011e0:	2800      	cmp	r0, #0
 80011e2:	d0f2      	beq.n	80011ca <xQueueSemaphoreTake+0x25a>
                            vTaskMissedYield();
 80011e4:	f000 ffc6 	bl	8002174 <vTaskMissedYield>
 80011e8:	e7ef      	b.n	80011ca <xQueueSemaphoreTake+0x25a>
        pxQueue->cTxLock = queueUNLOCKED;
 80011ea:	2345      	movs	r3, #69	; 0x45
 80011ec:	22ff      	movs	r2, #255	; 0xff
 80011ee:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 80011f0:	f001 fb6a 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 80011f4:	f001 fb5c 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80011f8:	2344      	movs	r3, #68	; 0x44
 80011fa:	5ce5      	ldrb	r5, [r4, r3]
 80011fc:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80011fe:	2d00      	cmp	r5, #0
 8001200:	dd12      	ble.n	8001228 <xQueueSemaphoreTake+0x2b8>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001202:	0027      	movs	r7, r4
 8001204:	3710      	adds	r7, #16
 8001206:	e004      	b.n	8001212 <xQueueSemaphoreTake+0x2a2>
                --cRxLock;
 8001208:	3d01      	subs	r5, #1
 800120a:	b2ea      	uxtb	r2, r5
 800120c:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800120e:	2a00      	cmp	r2, #0
 8001210:	d00a      	beq.n	8001228 <xQueueSemaphoreTake+0x2b8>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001212:	6923      	ldr	r3, [r4, #16]
 8001214:	2b00      	cmp	r3, #0
 8001216:	d007      	beq.n	8001228 <xQueueSemaphoreTake+0x2b8>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001218:	0038      	movs	r0, r7
 800121a:	f000 ff17 	bl	800204c <xTaskRemoveFromEventList>
 800121e:	2800      	cmp	r0, #0
 8001220:	d0f2      	beq.n	8001208 <xQueueSemaphoreTake+0x298>
                    vTaskMissedYield();
 8001222:	f000 ffa7 	bl	8002174 <vTaskMissedYield>
 8001226:	e7ef      	b.n	8001208 <xQueueSemaphoreTake+0x298>
        pxQueue->cRxLock = queueUNLOCKED;
 8001228:	2344      	movs	r3, #68	; 0x44
 800122a:	22ff      	movs	r2, #255	; 0xff
 800122c:	54e2      	strb	r2, [r4, r3]
    taskEXIT_CRITICAL();
 800122e:	f001 fb4b 	bl	80028c8 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 8001232:	f000 fd3f 	bl	8001cb4 <xTaskResumeAll>
 8001236:	2800      	cmp	r0, #0
 8001238:	d000      	beq.n	800123c <xQueueSemaphoreTake+0x2cc>
 800123a:	e756      	b.n	80010ea <xQueueSemaphoreTake+0x17a>
                    portYIELD_WITHIN_API();
 800123c:	f001 fb2c 	bl	8002898 <vPortYield>
 8001240:	2501      	movs	r5, #1
 8001242:	e6b1      	b.n	8000fa8 <xQueueSemaphoreTake+0x38>
 8001244:	2300      	movs	r3, #0
 8001246:	469b      	mov	fp, r3
 8001248:	e6a8      	b.n	8000f9c <xQueueSemaphoreTake+0x2c>
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 800124a:	0020      	movs	r0, r4
 800124c:	f001 fc48 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 8001250:	4643      	mov	r3, r8
 8001252:	881b      	ldrh	r3, [r3, #0]
 8001254:	4203      	tst	r3, r0
 8001256:	d099      	beq.n	800118c <xQueueSemaphoreTake+0x21c>
 8001258:	0020      	movs	r0, r4
 800125a:	f001 fc11 	bl	8002a80 <prvTraceGetQueueType>
 800125e:	4655      	mov	r5, sl
 8001260:	5c2b      	ldrb	r3, [r5, r0]
 8001262:	0020      	movs	r0, r4
 8001264:	3368      	adds	r3, #104	; 0x68
 8001266:	b2df      	uxtb	r7, r3
 8001268:	f001 fc0a 	bl	8002a80 <prvTraceGetQueueType>
 800126c:	5c2b      	ldrb	r3, [r5, r0]
 800126e:	0020      	movs	r0, r4
 8001270:	4699      	mov	r9, r3
 8001272:	f001 fc2f 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 8001276:	4649      	mov	r1, r9
 8001278:	b2c2      	uxtb	r2, r0
 800127a:	0038      	movs	r0, r7
 800127c:	f002 f9a2 	bl	80035c4 <prvTraceStoreKernelCall>
 8001280:	e785      	b.n	800118e <xQueueSemaphoreTake+0x21e>
 8001282:	f001 fc4d 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001286:	f001 fbff 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800128a:	b2c0      	uxtb	r0, r0
 800128c:	f002 ffc4 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001290:	e78b      	b.n	80011aa <xQueueSemaphoreTake+0x23a>
 8001292:	46c0      	nop			; (mov r8, r8)
 8001294:	20001d7e 	.word	0x20001d7e
 8001298:	20000008 	.word	0x20000008
                traceQUEUE_RECEIVE_FAILED( pxQueue );
 800129c:	0020      	movs	r0, r4
 800129e:	f001 fc1f 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 80012a2:	4643      	mov	r3, r8
 80012a4:	881b      	ldrh	r3, [r3, #0]
 80012a6:	4203      	tst	r3, r0
 80012a8:	d100      	bne.n	80012ac <xQueueSemaphoreTake+0x33c>
 80012aa:	e733      	b.n	8001114 <xQueueSemaphoreTake+0x1a4>
 80012ac:	0020      	movs	r0, r4
 80012ae:	f001 fbe7 	bl	8002a80 <prvTraceGetQueueType>
 80012b2:	4e57      	ldr	r6, [pc, #348]	; (8001410 <xQueueSemaphoreTake+0x4a0>)
 80012b4:	5c35      	ldrb	r5, [r6, r0]
 80012b6:	0020      	movs	r0, r4
 80012b8:	f001 fbe2 	bl	8002a80 <prvTraceGetQueueType>
 80012bc:	5c36      	ldrb	r6, [r6, r0]
 80012be:	0020      	movs	r0, r4
 80012c0:	f001 fc08 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 80012c4:	3550      	adds	r5, #80	; 0x50
 80012c6:	b2ed      	uxtb	r5, r5
 80012c8:	b2c2      	uxtb	r2, r0
 80012ca:	0031      	movs	r1, r6
 80012cc:	0028      	movs	r0, r5
 80012ce:	f002 f979 	bl	80035c4 <prvTraceStoreKernelCall>
 80012d2:	e71f      	b.n	8001114 <xQueueSemaphoreTake+0x1a4>
                            taskENTER_CRITICAL();
 80012d4:	f001 faec 	bl	80028b0 <vPortEnterCritical>
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 80012d8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80012da:	2900      	cmp	r1, #0
 80012dc:	d003      	beq.n	80012e6 <xQueueSemaphoreTake+0x376>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 80012de:	2105      	movs	r1, #5
 80012e0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80012e2:	681b      	ldr	r3, [r3, #0]
 80012e4:	1ac9      	subs	r1, r1, r3
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 80012e6:	68a0      	ldr	r0, [r4, #8]
 80012e8:	f001 f84e 	bl	8002388 <vTaskPriorityDisinheritAfterTimeout>
                            taskEXIT_CRITICAL();
 80012ec:	f001 faec 	bl	80028c8 <vPortExitCritical>
 80012f0:	e707      	b.n	8001102 <xQueueSemaphoreTake+0x192>
                            taskENTER_CRITICAL();
 80012f2:	f001 fadd 	bl	80028b0 <vPortEnterCritical>
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 80012f6:	68a0      	ldr	r0, [r4, #8]
 80012f8:	f000 ff62 	bl	80021c0 <xTaskPriorityInherit>
 80012fc:	4683      	mov	fp, r0
                            taskEXIT_CRITICAL();
 80012fe:	f001 fae3 	bl	80028c8 <vPortExitCritical>
 8001302:	e756      	b.n	80011b2 <xQueueSemaphoreTake+0x242>
                            configASSERT( xInheritanceOccurred == pdFALSE );
 8001304:	465b      	mov	r3, fp
 8001306:	2b00      	cmp	r3, #0
 8001308:	d048      	beq.n	800139c <xQueueSemaphoreTake+0x42c>
 800130a:	b672      	cpsid	i
 800130c:	e7fe      	b.n	800130c <xQueueSemaphoreTake+0x39c>
                traceQUEUE_RECEIVE( pxQueue );
 800130e:	f001 fc07 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001312:	f001 fbbf 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001316:	4643      	mov	r3, r8
 8001318:	881b      	ldrh	r3, [r3, #0]
 800131a:	4203      	tst	r3, r0
 800131c:	d123      	bne.n	8001366 <xQueueSemaphoreTake+0x3f6>
 800131e:	4d3c      	ldr	r5, [pc, #240]	; (8001410 <xQueueSemaphoreTake+0x4a0>)
 8001320:	0020      	movs	r0, r4
 8001322:	f001 fbad 	bl	8002a80 <prvTraceGetQueueType>
 8001326:	5c2f      	ldrb	r7, [r5, r0]
 8001328:	0020      	movs	r0, r4
 800132a:	f001 fbd3 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 800132e:	b2c6      	uxtb	r6, r0
 8001330:	0020      	movs	r0, r4
 8001332:	f001 fba5 	bl	8002a80 <prvTraceGetQueueType>
 8001336:	5c2b      	ldrb	r3, [r5, r0]
 8001338:	2b02      	cmp	r3, #2
 800133a:	d063      	beq.n	8001404 <xQueueSemaphoreTake+0x494>
 800133c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800133e:	3a01      	subs	r2, #1
 8001340:	b2d2      	uxtb	r2, r2
 8001342:	0031      	movs	r1, r6
 8001344:	0038      	movs	r0, r7
 8001346:	f002 feb7 	bl	80040b8 <prvTraceSetObjectState>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800134a:	464b      	mov	r3, r9
 800134c:	3b01      	subs	r3, #1
 800134e:	63a3      	str	r3, [r4, #56]	; 0x38
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001350:	6823      	ldr	r3, [r4, #0]
 8001352:	2b00      	cmp	r3, #0
 8001354:	d052      	beq.n	80013fc <xQueueSemaphoreTake+0x48c>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001356:	6923      	ldr	r3, [r4, #16]
 8001358:	2b00      	cmp	r3, #0
 800135a:	d146      	bne.n	80013ea <xQueueSemaphoreTake+0x47a>
                taskEXIT_CRITICAL();
 800135c:	f001 fab4 	bl	80028c8 <vPortExitCritical>
                return pdPASS;
 8001360:	2301      	movs	r3, #1
 8001362:	469b      	mov	fp, r3
 8001364:	e6d8      	b.n	8001118 <xQueueSemaphoreTake+0x1a8>
                traceQUEUE_RECEIVE( pxQueue );
 8001366:	0020      	movs	r0, r4
 8001368:	f001 fbba 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 800136c:	4643      	mov	r3, r8
 800136e:	881b      	ldrh	r3, [r3, #0]
 8001370:	4203      	tst	r3, r0
 8001372:	d0d4      	beq.n	800131e <xQueueSemaphoreTake+0x3ae>
 8001374:	0020      	movs	r0, r4
 8001376:	f001 fb83 	bl	8002a80 <prvTraceGetQueueType>
 800137a:	4d25      	ldr	r5, [pc, #148]	; (8001410 <xQueueSemaphoreTake+0x4a0>)
 800137c:	5c2e      	ldrb	r6, [r5, r0]
 800137e:	0020      	movs	r0, r4
 8001380:	f001 fb7e 	bl	8002a80 <prvTraceGetQueueType>
 8001384:	5c2f      	ldrb	r7, [r5, r0]
 8001386:	0020      	movs	r0, r4
 8001388:	f001 fba4 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 800138c:	3628      	adds	r6, #40	; 0x28
 800138e:	b2f6      	uxtb	r6, r6
 8001390:	b2c2      	uxtb	r2, r0
 8001392:	0039      	movs	r1, r7
 8001394:	0030      	movs	r0, r6
 8001396:	f002 f915 	bl	80035c4 <prvTraceStoreKernelCall>
 800139a:	e7c1      	b.n	8001320 <xQueueSemaphoreTake+0x3b0>
                    taskEXIT_CRITICAL();
 800139c:	f001 fa94 	bl	80028c8 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
 80013a0:	f001 fbbe 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 80013a4:	f001 fb76 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80013a8:	4643      	mov	r3, r8
 80013aa:	881b      	ldrh	r3, [r3, #0]
 80013ac:	4203      	tst	r3, r0
 80013ae:	d100      	bne.n	80013b2 <xQueueSemaphoreTake+0x442>
 80013b0:	e6b0      	b.n	8001114 <xQueueSemaphoreTake+0x1a4>
 80013b2:	0020      	movs	r0, r4
 80013b4:	f001 fb94 	bl	8002ae0 <prvTraceGetQueueNumberHigh16>
 80013b8:	4643      	mov	r3, r8
 80013ba:	881b      	ldrh	r3, [r3, #0]
 80013bc:	4203      	tst	r3, r0
 80013be:	d100      	bne.n	80013c2 <xQueueSemaphoreTake+0x452>
 80013c0:	e6a8      	b.n	8001114 <xQueueSemaphoreTake+0x1a4>
 80013c2:	0020      	movs	r0, r4
 80013c4:	f001 fb5c 	bl	8002a80 <prvTraceGetQueueType>
 80013c8:	4e11      	ldr	r6, [pc, #68]	; (8001410 <xQueueSemaphoreTake+0x4a0>)
 80013ca:	5c35      	ldrb	r5, [r6, r0]
 80013cc:	0020      	movs	r0, r4
 80013ce:	f001 fb57 	bl	8002a80 <prvTraceGetQueueType>
 80013d2:	5c36      	ldrb	r6, [r6, r0]
 80013d4:	0020      	movs	r0, r4
 80013d6:	f001 fb7d 	bl	8002ad4 <prvTraceGetQueueNumberLow16>
 80013da:	3550      	adds	r5, #80	; 0x50
 80013dc:	b2ed      	uxtb	r5, r5
 80013de:	b2c2      	uxtb	r2, r0
 80013e0:	0031      	movs	r1, r6
 80013e2:	0028      	movs	r0, r5
 80013e4:	f002 f8ee 	bl	80035c4 <prvTraceStoreKernelCall>
 80013e8:	e696      	b.n	8001118 <xQueueSemaphoreTake+0x1a8>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80013ea:	0020      	movs	r0, r4
 80013ec:	3010      	adds	r0, #16
 80013ee:	f000 fe2d 	bl	800204c <xTaskRemoveFromEventList>
 80013f2:	2800      	cmp	r0, #0
 80013f4:	d0b2      	beq.n	800135c <xQueueSemaphoreTake+0x3ec>
                        queueYIELD_IF_USING_PREEMPTION();
 80013f6:	f001 fa4f 	bl	8002898 <vPortYield>
 80013fa:	e7af      	b.n	800135c <xQueueSemaphoreTake+0x3ec>
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 80013fc:	f001 f834 	bl	8002468 <pvTaskIncrementMutexHeldCount>
 8001400:	60a0      	str	r0, [r4, #8]
 8001402:	e7a8      	b.n	8001356 <xQueueSemaphoreTake+0x3e6>
                traceQUEUE_RECEIVE( pxQueue );
 8001404:	f001 fb8c 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001408:	f001 fb3e 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800140c:	b2c2      	uxtb	r2, r0
 800140e:	e798      	b.n	8001342 <xQueueSemaphoreTake+0x3d2>
 8001410:	20000008 	.word	0x20000008

08001414 <uxQueueGetQueueNumber>:
        return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 8001414:	6c80      	ldr	r0, [r0, #72]	; 0x48
    }
 8001416:	4770      	bx	lr

08001418 <vQueueSetQueueNumber>:
        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 8001418:	6481      	str	r1, [r0, #72]	; 0x48
    }
 800141a:	4770      	bx	lr

0800141c <ucQueueGetQueueType>:
        return ( ( Queue_t * ) xQueue )->ucQueueType;
 800141c:	234c      	movs	r3, #76	; 0x4c
 800141e:	5cc0      	ldrb	r0, [r0, r3]
    }
 8001420:	4770      	bx	lr
 8001422:	46c0      	nop			; (mov r8, r8)

08001424 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 8001424:	b570      	push	{r4, r5, r6, lr}
 8001426:	0005      	movs	r5, r0
 8001428:	0016      	movs	r6, r2
 800142a:	000c      	movs	r4, r1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 800142c:	f001 fa40 	bl	80028b0 <vPortEnterCritical>
 8001430:	2244      	movs	r2, #68	; 0x44
 8001432:	5cab      	ldrb	r3, [r5, r2]
 8001434:	b25b      	sxtb	r3, r3
 8001436:	3301      	adds	r3, #1
 8001438:	d101      	bne.n	800143e <vQueueWaitForMessageRestricted+0x1a>
 800143a:	2300      	movs	r3, #0
 800143c:	54ab      	strb	r3, [r5, r2]
 800143e:	2245      	movs	r2, #69	; 0x45
 8001440:	5cab      	ldrb	r3, [r5, r2]
 8001442:	b25b      	sxtb	r3, r3
 8001444:	3301      	adds	r3, #1
 8001446:	d101      	bne.n	800144c <vQueueWaitForMessageRestricted+0x28>
 8001448:	2300      	movs	r3, #0
 800144a:	54ab      	strb	r3, [r5, r2]
 800144c:	f001 fa3c 	bl	80028c8 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8001450:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001452:	2b00      	cmp	r3, #0
 8001454:	d046      	beq.n	80014e4 <vQueueWaitForMessageRestricted+0xc0>
    taskENTER_CRITICAL();
 8001456:	f001 fa2b 	bl	80028b0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 800145a:	2345      	movs	r3, #69	; 0x45
 800145c:	5cec      	ldrb	r4, [r5, r3]
 800145e:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001460:	2c00      	cmp	r4, #0
 8001462:	dd16      	ble.n	8001492 <vQueueWaitForMessageRestricted+0x6e>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001464:	002e      	movs	r6, r5
 8001466:	3624      	adds	r6, #36	; 0x24
 8001468:	e004      	b.n	8001474 <vQueueWaitForMessageRestricted+0x50>
            --cTxLock;
 800146a:	3c01      	subs	r4, #1
 800146c:	b2e2      	uxtb	r2, r4
 800146e:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001470:	2a00      	cmp	r2, #0
 8001472:	d00e      	beq.n	8001492 <vQueueWaitForMessageRestricted+0x6e>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001474:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8001476:	2b00      	cmp	r3, #0
 8001478:	d00b      	beq.n	8001492 <vQueueWaitForMessageRestricted+0x6e>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800147a:	0030      	movs	r0, r6
 800147c:	f000 fde6 	bl	800204c <xTaskRemoveFromEventList>
 8001480:	2800      	cmp	r0, #0
 8001482:	d0f2      	beq.n	800146a <vQueueWaitForMessageRestricted+0x46>
                            vTaskMissedYield();
 8001484:	3c01      	subs	r4, #1
 8001486:	f000 fe75 	bl	8002174 <vTaskMissedYield>
            --cTxLock;
 800148a:	b2e2      	uxtb	r2, r4
 800148c:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800148e:	2a00      	cmp	r2, #0
 8001490:	d1f0      	bne.n	8001474 <vQueueWaitForMessageRestricted+0x50>
        pxQueue->cTxLock = queueUNLOCKED;
 8001492:	2345      	movs	r3, #69	; 0x45
 8001494:	22ff      	movs	r2, #255	; 0xff
 8001496:	54ea      	strb	r2, [r5, r3]
    taskEXIT_CRITICAL();
 8001498:	f001 fa16 	bl	80028c8 <vPortExitCritical>
    taskENTER_CRITICAL();
 800149c:	f001 fa08 	bl	80028b0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80014a0:	2344      	movs	r3, #68	; 0x44
 80014a2:	5cec      	ldrb	r4, [r5, r3]
 80014a4:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80014a6:	2c00      	cmp	r4, #0
 80014a8:	dd16      	ble.n	80014d8 <vQueueWaitForMessageRestricted+0xb4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80014aa:	002e      	movs	r6, r5
 80014ac:	3610      	adds	r6, #16
 80014ae:	e004      	b.n	80014ba <vQueueWaitForMessageRestricted+0x96>
                --cRxLock;
 80014b0:	3c01      	subs	r4, #1
 80014b2:	b2e2      	uxtb	r2, r4
 80014b4:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80014b6:	2a00      	cmp	r2, #0
 80014b8:	d00e      	beq.n	80014d8 <vQueueWaitForMessageRestricted+0xb4>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80014ba:	692b      	ldr	r3, [r5, #16]
 80014bc:	2b00      	cmp	r3, #0
 80014be:	d00b      	beq.n	80014d8 <vQueueWaitForMessageRestricted+0xb4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80014c0:	0030      	movs	r0, r6
 80014c2:	f000 fdc3 	bl	800204c <xTaskRemoveFromEventList>
 80014c6:	2800      	cmp	r0, #0
 80014c8:	d0f2      	beq.n	80014b0 <vQueueWaitForMessageRestricted+0x8c>
                    vTaskMissedYield();
 80014ca:	3c01      	subs	r4, #1
 80014cc:	f000 fe52 	bl	8002174 <vTaskMissedYield>
                --cRxLock;
 80014d0:	b2e2      	uxtb	r2, r4
 80014d2:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80014d4:	2a00      	cmp	r2, #0
 80014d6:	d1f0      	bne.n	80014ba <vQueueWaitForMessageRestricted+0x96>
        pxQueue->cRxLock = queueUNLOCKED;
 80014d8:	2344      	movs	r3, #68	; 0x44
 80014da:	22ff      	movs	r2, #255	; 0xff
 80014dc:	54ea      	strb	r2, [r5, r3]
    taskEXIT_CRITICAL();
 80014de:	f001 f9f3 	bl	80028c8 <vPortExitCritical>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    }
 80014e2:	bd70      	pop	{r4, r5, r6, pc}
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 80014e4:	0028      	movs	r0, r5
 80014e6:	0032      	movs	r2, r6
 80014e8:	0021      	movs	r1, r4
 80014ea:	3024      	adds	r0, #36	; 0x24
 80014ec:	f000 fd30 	bl	8001f50 <vTaskPlaceOnEventListRestricted>
 80014f0:	e7b1      	b.n	8001456 <vQueueWaitForMessageRestricted+0x32>
 80014f2:	46c0      	nop			; (mov r8, r8)

080014f4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80014f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80014f6:	46c6      	mov	lr, r8
 80014f8:	4b12      	ldr	r3, [pc, #72]	; (8001544 <prvIdleTask+0x50>)
 80014fa:	b500      	push	{lr}
 80014fc:	4698      	mov	r8, r3
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80014fe:	4d12      	ldr	r5, [pc, #72]	; (8001548 <prvIdleTask+0x54>)
 8001500:	4f12      	ldr	r7, [pc, #72]	; (800154c <prvIdleTask+0x58>)
 8001502:	4e13      	ldr	r6, [pc, #76]	; (8001550 <prvIdleTask+0x5c>)
 8001504:	e014      	b.n	8001530 <prvIdleTask+0x3c>
            {
                taskENTER_CRITICAL();
 8001506:	f001 f9d3 	bl	80028b0 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800150a:	68fb      	ldr	r3, [r7, #12]
 800150c:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800150e:	1d20      	adds	r0, r4, #4
 8001510:	f7fe feba 	bl	8000288 <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8001514:	6833      	ldr	r3, [r6, #0]
 8001516:	3b01      	subs	r3, #1
 8001518:	6033      	str	r3, [r6, #0]
                    --uxDeletedTasksWaitingCleanUp;
 800151a:	682b      	ldr	r3, [r5, #0]
 800151c:	3b01      	subs	r3, #1
 800151e:	602b      	str	r3, [r5, #0]
                }
                taskEXIT_CRITICAL();
 8001520:	f001 f9d2 	bl	80028c8 <vPortExitCritical>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
 8001524:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001526:	f001 faa5 	bl	8002a74 <vPortFree>
                vPortFree( pxTCB );
 800152a:	0020      	movs	r0, r4
 800152c:	f001 faa2 	bl	8002a74 <vPortFree>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001530:	682b      	ldr	r3, [r5, #0]
 8001532:	2b00      	cmp	r3, #0
 8001534:	d1e7      	bne.n	8001506 <prvIdleTask+0x12>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8001536:	4643      	mov	r3, r8
 8001538:	681b      	ldr	r3, [r3, #0]
 800153a:	2b01      	cmp	r3, #1
 800153c:	d9f8      	bls.n	8001530 <prvIdleTask+0x3c>
                    taskYIELD();
 800153e:	f001 f9ab 	bl	8002898 <vPortYield>
 8001542:	e7f5      	b.n	8001530 <prvIdleTask+0x3c>
 8001544:	20000040 	.word	0x20000040
 8001548:	200000a8 	.word	0x200000a8
 800154c:	2000011c 	.word	0x2000011c
 8001550:	200000a4 	.word	0x200000a4

08001554 <vTaskSwitchContext.part.0>:
        xYieldPending = pdFALSE;
 8001554:	2200      	movs	r2, #0
 8001556:	4b31      	ldr	r3, [pc, #196]	; (800161c <vTaskSwitchContext.part.0+0xc8>)
void vTaskSwitchContext( void )
 8001558:	b570      	push	{r4, r5, r6, lr}
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800155a:	4c31      	ldr	r4, [pc, #196]	; (8001620 <vTaskSwitchContext.part.0+0xcc>)
        xYieldPending = pdFALSE;
 800155c:	601a      	str	r2, [r3, #0]
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800155e:	6822      	ldr	r2, [r4, #0]
 8001560:	4930      	ldr	r1, [pc, #192]	; (8001624 <vTaskSwitchContext.part.0+0xd0>)
 8001562:	0093      	lsls	r3, r2, #2
 8001564:	1898      	adds	r0, r3, r2
 8001566:	0080      	lsls	r0, r0, #2
 8001568:	5808      	ldr	r0, [r1, r0]
 800156a:	2800      	cmp	r0, #0
 800156c:	d12f      	bne.n	80015ce <vTaskSwitchContext.part.0+0x7a>
 800156e:	2a00      	cmp	r2, #0
 8001570:	d02a      	beq.n	80015c8 <vTaskSwitchContext.part.0+0x74>
 8001572:	1e50      	subs	r0, r2, #1
 8001574:	0083      	lsls	r3, r0, #2
 8001576:	181d      	adds	r5, r3, r0
 8001578:	00ad      	lsls	r5, r5, #2
 800157a:	594d      	ldr	r5, [r1, r5]
 800157c:	2d00      	cmp	r5, #0
 800157e:	d125      	bne.n	80015cc <vTaskSwitchContext.part.0+0x78>
 8001580:	2800      	cmp	r0, #0
 8001582:	d021      	beq.n	80015c8 <vTaskSwitchContext.part.0+0x74>
 8001584:	1e90      	subs	r0, r2, #2
 8001586:	0083      	lsls	r3, r0, #2
 8001588:	181d      	adds	r5, r3, r0
 800158a:	00ad      	lsls	r5, r5, #2
 800158c:	594d      	ldr	r5, [r1, r5]
 800158e:	2d00      	cmp	r5, #0
 8001590:	d11c      	bne.n	80015cc <vTaskSwitchContext.part.0+0x78>
 8001592:	2800      	cmp	r0, #0
 8001594:	d018      	beq.n	80015c8 <vTaskSwitchContext.part.0+0x74>
 8001596:	1ed0      	subs	r0, r2, #3
 8001598:	0083      	lsls	r3, r0, #2
 800159a:	181d      	adds	r5, r3, r0
 800159c:	00ad      	lsls	r5, r5, #2
 800159e:	594d      	ldr	r5, [r1, r5]
 80015a0:	2d00      	cmp	r5, #0
 80015a2:	d113      	bne.n	80015cc <vTaskSwitchContext.part.0+0x78>
 80015a4:	2800      	cmp	r0, #0
 80015a6:	d00f      	beq.n	80015c8 <vTaskSwitchContext.part.0+0x74>
 80015a8:	1f10      	subs	r0, r2, #4
 80015aa:	0083      	lsls	r3, r0, #2
 80015ac:	181d      	adds	r5, r3, r0
 80015ae:	00ad      	lsls	r5, r5, #2
 80015b0:	594d      	ldr	r5, [r1, r5]
 80015b2:	2d00      	cmp	r5, #0
 80015b4:	d10a      	bne.n	80015cc <vTaskSwitchContext.part.0+0x78>
 80015b6:	2800      	cmp	r0, #0
 80015b8:	d006      	beq.n	80015c8 <vTaskSwitchContext.part.0+0x74>
 80015ba:	3a05      	subs	r2, #5
 80015bc:	0093      	lsls	r3, r2, #2
 80015be:	1898      	adds	r0, r3, r2
 80015c0:	0080      	lsls	r0, r0, #2
 80015c2:	5808      	ldr	r0, [r1, r0]
 80015c4:	2800      	cmp	r0, #0
 80015c6:	d102      	bne.n	80015ce <vTaskSwitchContext.part.0+0x7a>
 80015c8:	b672      	cpsid	i
 80015ca:	e7fe      	b.n	80015ca <vTaskSwitchContext.part.0+0x76>
 80015cc:	0002      	movs	r2, r0
 80015ce:	189b      	adds	r3, r3, r2
 80015d0:	009b      	lsls	r3, r3, #2
 80015d2:	18cd      	adds	r5, r1, r3
 80015d4:	6868      	ldr	r0, [r5, #4]
 80015d6:	3308      	adds	r3, #8
 80015d8:	6840      	ldr	r0, [r0, #4]
 80015da:	18c9      	adds	r1, r1, r3
 80015dc:	6068      	str	r0, [r5, #4]
 80015de:	4288      	cmp	r0, r1
 80015e0:	d019      	beq.n	8001616 <vTaskSwitchContext.part.0+0xc2>
 80015e2:	68c1      	ldr	r1, [r0, #12]
 80015e4:	4b10      	ldr	r3, [pc, #64]	; (8001628 <vTaskSwitchContext.part.0+0xd4>)
 80015e6:	6019      	str	r1, [r3, #0]
        traceTASK_SWITCHED_IN();
 80015e8:	2301      	movs	r3, #1
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80015ea:	6022      	str	r2, [r4, #0]
        traceTASK_SWITCHED_IN();
 80015ec:	4c0f      	ldr	r4, [pc, #60]	; (800162c <vTaskSwitchContext.part.0+0xd8>)
 80015ee:	6023      	str	r3, [r4, #0]
 80015f0:	f001 fa96 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 80015f4:	f001 fa4e 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80015f8:	4b0d      	ldr	r3, [pc, #52]	; (8001630 <vTaskSwitchContext.part.0+0xdc>)
 80015fa:	881b      	ldrh	r3, [r3, #0]
 80015fc:	4203      	tst	r3, r0
 80015fe:	d102      	bne.n	8001606 <vTaskSwitchContext.part.0+0xb2>
 8001600:	2302      	movs	r3, #2
 8001602:	6023      	str	r3, [r4, #0]
}
 8001604:	bd70      	pop	{r4, r5, r6, pc}
        traceTASK_SWITCHED_IN();
 8001606:	f001 fa8b 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 800160a:	f001 fa3d 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800160e:	b2c0      	uxtb	r0, r0
 8001610:	f002 fef6 	bl	8004400 <prvTraceStoreTaskswitch>
 8001614:	e7f4      	b.n	8001600 <vTaskSwitchContext.part.0+0xac>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001616:	6840      	ldr	r0, [r0, #4]
 8001618:	6068      	str	r0, [r5, #4]
 800161a:	e7e2      	b.n	80015e2 <vTaskSwitchContext.part.0+0x8e>
 800161c:	20000134 	.word	0x20000134
 8001620:	200000b4 	.word	0x200000b4
 8001624:	20000040 	.word	0x20000040
 8001628:	20000034 	.word	0x20000034
 800162c:	20003490 	.word	0x20003490
 8001630:	20001d7e 	.word	0x20001d7e

08001634 <xTaskCreate>:
    {
 8001634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001636:	464e      	mov	r6, r9
 8001638:	4645      	mov	r5, r8
 800163a:	46de      	mov	lr, fp
 800163c:	4657      	mov	r7, sl
 800163e:	b5e0      	push	{r5, r6, r7, lr}
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001640:	0096      	lsls	r6, r2, #2
    {
 8001642:	4680      	mov	r8, r0
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001644:	0030      	movs	r0, r6
    {
 8001646:	000d      	movs	r5, r1
 8001648:	4699      	mov	r9, r3
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 800164a:	f001 f9c9 	bl	80029e0 <pvPortMalloc>
 800164e:	1e07      	subs	r7, r0, #0
                if( pxStack != NULL )
 8001650:	d100      	bne.n	8001654 <xTaskCreate+0x20>
 8001652:	e0da      	b.n	800180a <xTaskCreate+0x1d6>
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8001654:	2058      	movs	r0, #88	; 0x58
 8001656:	f001 f9c3 	bl	80029e0 <pvPortMalloc>
 800165a:	1e04      	subs	r4, r0, #0
                    if( pxNewTCB != NULL )
 800165c:	d100      	bne.n	8001660 <xTaskCreate+0x2c>
 800165e:	e0f0      	b.n	8001842 <xTaskCreate+0x20e>
                        pxNewTCB->pxStack = pxStack;
 8001660:	6307      	str	r7, [r0, #48]	; 0x30
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8001662:	0032      	movs	r2, r6
 8001664:	21a5      	movs	r1, #165	; 0xa5
 8001666:	0038      	movs	r0, r7
 8001668:	f004 fb62 	bl	8005d30 <memset>
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800166c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800166e:	469a      	mov	sl, r3
    if( pcName != NULL )
 8001670:	2d00      	cmp	r5, #0
 8001672:	d100      	bne.n	8001676 <xTaskCreate+0x42>
 8001674:	e0f3      	b.n	800185e <xTaskCreate+0x22a>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001676:	2234      	movs	r2, #52	; 0x34
 8001678:	782b      	ldrb	r3, [r5, #0]
 800167a:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 800167c:	2b00      	cmp	r3, #0
 800167e:	d02a      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001680:	786b      	ldrb	r3, [r5, #1]
 8001682:	3201      	adds	r2, #1
 8001684:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 8001686:	2b00      	cmp	r3, #0
 8001688:	d025      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800168a:	78ab      	ldrb	r3, [r5, #2]
 800168c:	3201      	adds	r2, #1
 800168e:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 8001690:	2b00      	cmp	r3, #0
 8001692:	d020      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001694:	78eb      	ldrb	r3, [r5, #3]
 8001696:	3201      	adds	r2, #1
 8001698:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 800169a:	2b00      	cmp	r3, #0
 800169c:	d01b      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800169e:	792b      	ldrb	r3, [r5, #4]
 80016a0:	3201      	adds	r2, #1
 80016a2:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 80016a4:	2b00      	cmp	r3, #0
 80016a6:	d016      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80016a8:	796b      	ldrb	r3, [r5, #5]
 80016aa:	3201      	adds	r2, #1
 80016ac:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 80016ae:	2b00      	cmp	r3, #0
 80016b0:	d011      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80016b2:	79ab      	ldrb	r3, [r5, #6]
 80016b4:	3201      	adds	r2, #1
 80016b6:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 80016b8:	2b00      	cmp	r3, #0
 80016ba:	d00c      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80016bc:	79eb      	ldrb	r3, [r5, #7]
 80016be:	3201      	adds	r2, #1
 80016c0:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 80016c2:	2b00      	cmp	r3, #0
 80016c4:	d007      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80016c6:	7a2b      	ldrb	r3, [r5, #8]
 80016c8:	3201      	adds	r2, #1
 80016ca:	54a3      	strb	r3, [r4, r2]
            if( pcName[ x ] == ( char ) 0x00 )
 80016cc:	2b00      	cmp	r3, #0
 80016ce:	d002      	beq.n	80016d6 <xTaskCreate+0xa2>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80016d0:	233d      	movs	r3, #61	; 0x3d
 80016d2:	7a6a      	ldrb	r2, [r5, #9]
 80016d4:	54e2      	strb	r2, [r4, r3]
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80016d6:	233d      	movs	r3, #61	; 0x3d
 80016d8:	2200      	movs	r2, #0
 80016da:	54e2      	strb	r2, [r4, r3]
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80016dc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80016de:	2f04      	cmp	r7, #4
 80016e0:	d900      	bls.n	80016e4 <xTaskCreate+0xb0>
 80016e2:	e095      	b.n	8001810 <xTaskCreate+0x1dc>
            pxNewTCB->uxMutexesHeld = 0;
 80016e4:	2300      	movs	r3, #0
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80016e6:	1d25      	adds	r5, r4, #4
            pxNewTCB->uxMutexesHeld = 0;
 80016e8:	64e3      	str	r3, [r4, #76]	; 0x4c
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80016ea:	0028      	movs	r0, r5
    pxNewTCB->uxPriority = uxPriority;
 80016ec:	62e7      	str	r7, [r4, #44]	; 0x2c
            pxNewTCB->uxBasePriority = uxPriority;
 80016ee:	64a7      	str	r7, [r4, #72]	; 0x48
            pxNewTCB->uxMutexesHeld = 0;
 80016f0:	469b      	mov	fp, r3
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80016f2:	f7fe fda1 	bl	8000238 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80016f6:	0020      	movs	r0, r4
 80016f8:	3018      	adds	r0, #24
 80016fa:	f7fe fd9d 	bl	8000238 <vListInitialiseItem>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80016fe:	2305      	movs	r3, #5
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001700:	0020      	movs	r0, r4
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001702:	1bdb      	subs	r3, r3, r7
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001704:	2204      	movs	r2, #4
 8001706:	2100      	movs	r1, #0
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001708:	61a3      	str	r3, [r4, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800170a:	6124      	str	r4, [r4, #16]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800170c:	6264      	str	r4, [r4, #36]	; 0x24
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 800170e:	3050      	adds	r0, #80	; 0x50
 8001710:	f004 fb0e 	bl	8005d30 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 8001714:	0023      	movs	r3, r4
 8001716:	465a      	mov	r2, fp
 8001718:	3354      	adds	r3, #84	; 0x54
 800171a:	701a      	strb	r2, [r3, #0]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 800171c:	2307      	movs	r3, #7
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800171e:	1f30      	subs	r0, r6, #4
 8001720:	4450      	add	r0, sl
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8001722:	4398      	bics	r0, r3
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001724:	464a      	mov	r2, r9
 8001726:	4641      	mov	r1, r8
 8001728:	f001 f8a4 	bl	8002874 <pxPortInitialiseStack>
    if( pxCreatedTask != NULL )
 800172c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800172e:	6020      	str	r0, [r4, #0]
    if( pxCreatedTask != NULL )
 8001730:	2b00      	cmp	r3, #0
 8001732:	d000      	beq.n	8001736 <xTaskCreate+0x102>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8001734:	601c      	str	r4, [r3, #0]
    taskENTER_CRITICAL();
 8001736:	f001 f8bb 	bl	80028b0 <vPortEnterCritical>
        uxCurrentNumberOfTasks++;
 800173a:	4a5f      	ldr	r2, [pc, #380]	; (80018b8 <xTaskCreate+0x284>)
        if( pxCurrentTCB == NULL )
 800173c:	4f5f      	ldr	r7, [pc, #380]	; (80018bc <xTaskCreate+0x288>)
        uxCurrentNumberOfTasks++;
 800173e:	6813      	ldr	r3, [r2, #0]
 8001740:	3301      	adds	r3, #1
 8001742:	6013      	str	r3, [r2, #0]
        if( pxCurrentTCB == NULL )
 8001744:	683b      	ldr	r3, [r7, #0]
 8001746:	2b00      	cmp	r3, #0
 8001748:	d100      	bne.n	800174c <xTaskCreate+0x118>
 800174a:	e080      	b.n	800184e <xTaskCreate+0x21a>
            if( xSchedulerRunning == pdFALSE )
 800174c:	4b5c      	ldr	r3, [pc, #368]	; (80018c0 <xTaskCreate+0x28c>)
 800174e:	4698      	mov	r8, r3
 8001750:	681b      	ldr	r3, [r3, #0]
 8001752:	2b00      	cmp	r3, #0
 8001754:	d105      	bne.n	8001762 <xTaskCreate+0x12e>
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001756:	683b      	ldr	r3, [r7, #0]
 8001758:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800175a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800175c:	429a      	cmp	r2, r3
 800175e:	d800      	bhi.n	8001762 <xTaskCreate+0x12e>
                    pxCurrentTCB = pxNewTCB;
 8001760:	603c      	str	r4, [r7, #0]
 8001762:	4e58      	ldr	r6, [pc, #352]	; (80018c4 <xTaskCreate+0x290>)
        uxTaskNumber++;
 8001764:	4a58      	ldr	r2, [pc, #352]	; (80018c8 <xTaskCreate+0x294>)
        traceTASK_CREATE( pxNewTCB );
 8001766:	2003      	movs	r0, #3
        uxTaskNumber++;
 8001768:	6813      	ldr	r3, [r2, #0]
 800176a:	3301      	adds	r3, #1
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 800176c:	6423      	str	r3, [r4, #64]	; 0x40
        uxTaskNumber++;
 800176e:	6013      	str	r3, [r2, #0]
        traceTASK_CREATE( pxNewTCB );
 8001770:	f002 ffaa 	bl	80046c8 <prvTraceGetObjectHandle>
 8001774:	b281      	uxth	r1, r0
 8001776:	0020      	movs	r0, r4
 8001778:	f001 f992 	bl	8002aa0 <prvTraceSetTaskNumberLow16>
 800177c:	4b53      	ldr	r3, [pc, #332]	; (80018cc <xTaskCreate+0x298>)
 800177e:	0020      	movs	r0, r4
 8001780:	8819      	ldrh	r1, [r3, #0]
 8001782:	f001 f999 	bl	8002ab8 <prvTraceSetTaskNumberHigh16>
 8001786:	0020      	movs	r0, r4
 8001788:	f001 f97e 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800178c:	0022      	movs	r2, r4
 800178e:	b2c1      	uxtb	r1, r0
 8001790:	3234      	adds	r2, #52	; 0x34
 8001792:	2003      	movs	r0, #3
 8001794:	f003 f8ee 	bl	8004974 <prvTraceSetObjectName>
 8001798:	0020      	movs	r0, r4
 800179a:	f001 f975 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800179e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80017a0:	b2c1      	uxtb	r1, r0
 80017a2:	b2d2      	uxtb	r2, r2
 80017a4:	2003      	movs	r0, #3
 80017a6:	f002 fb27 	bl	8003df8 <prvTraceSetPriorityProperty>
 80017aa:	f001 f9b9 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 80017ae:	f001 f971 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80017b2:	4b47      	ldr	r3, [pc, #284]	; (80018d0 <xTaskCreate+0x29c>)
 80017b4:	4699      	mov	r9, r3
 80017b6:	881b      	ldrh	r3, [r3, #0]
 80017b8:	4203      	tst	r3, r0
 80017ba:	d132      	bne.n	8001822 <xTaskCreate+0x1ee>
        prvAddTaskToReadyList( pxNewTCB );
 80017bc:	0020      	movs	r0, r4
 80017be:	f001 f969 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80017c2:	464b      	mov	r3, r9
 80017c4:	881b      	ldrh	r3, [r3, #0]
 80017c6:	4203      	tst	r3, r0
 80017c8:	d124      	bne.n	8001814 <xTaskCreate+0x1e0>
 80017ca:	4b42      	ldr	r3, [pc, #264]	; (80018d4 <xTaskCreate+0x2a0>)
 80017cc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80017ce:	6819      	ldr	r1, [r3, #0]
 80017d0:	428a      	cmp	r2, r1
 80017d2:	d900      	bls.n	80017d6 <xTaskCreate+0x1a2>
 80017d4:	601a      	str	r2, [r3, #0]
 80017d6:	0093      	lsls	r3, r2, #2
 80017d8:	189b      	adds	r3, r3, r2
 80017da:	0098      	lsls	r0, r3, #2
 80017dc:	0029      	movs	r1, r5
 80017de:	1830      	adds	r0, r6, r0
 80017e0:	f7fe fd2e 	bl	8000240 <vListInsertEnd>
    taskEXIT_CRITICAL();
 80017e4:	f001 f870 	bl	80028c8 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 80017e8:	4643      	mov	r3, r8
 80017ea:	681b      	ldr	r3, [r3, #0]
            xReturn = pdPASS;
 80017ec:	2501      	movs	r5, #1
    if( xSchedulerRunning != pdFALSE )
 80017ee:	2b00      	cmp	r3, #0
 80017f0:	d004      	beq.n	80017fc <xTaskCreate+0x1c8>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80017f2:	683b      	ldr	r3, [r7, #0]
 80017f4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80017f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80017f8:	429a      	cmp	r2, r3
 80017fa:	d333      	bcc.n	8001864 <xTaskCreate+0x230>
    }
 80017fc:	0028      	movs	r0, r5
 80017fe:	bcf0      	pop	{r4, r5, r6, r7}
 8001800:	46bb      	mov	fp, r7
 8001802:	46b2      	mov	sl, r6
 8001804:	46a9      	mov	r9, r5
 8001806:	46a0      	mov	r8, r4
 8001808:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800180a:	2501      	movs	r5, #1
 800180c:	426d      	negs	r5, r5
 800180e:	e7f5      	b.n	80017fc <xTaskCreate+0x1c8>
 8001810:	2704      	movs	r7, #4
 8001812:	e767      	b.n	80016e4 <xTaskCreate+0xb0>
        prvAddTaskToReadyList( pxNewTCB );
 8001814:	0020      	movs	r0, r4
 8001816:	f001 f937 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800181a:	b2c0      	uxtb	r0, r0
 800181c:	f001 fc3e 	bl	800309c <prvTraceStoreTaskReady>
 8001820:	e7d3      	b.n	80017ca <xTaskCreate+0x196>
        traceTASK_CREATE( pxNewTCB );
 8001822:	0020      	movs	r0, r4
 8001824:	f001 f936 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001828:	464b      	mov	r3, r9
 800182a:	881b      	ldrh	r3, [r3, #0]
 800182c:	4203      	tst	r3, r0
 800182e:	d0c5      	beq.n	80017bc <xTaskCreate+0x188>
 8001830:	0020      	movs	r0, r4
 8001832:	f001 f929 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001836:	2103      	movs	r1, #3
 8001838:	b2c2      	uxtb	r2, r0
 800183a:	201b      	movs	r0, #27
 800183c:	f001 fec2 	bl	80035c4 <prvTraceStoreKernelCall>
 8001840:	e7bc      	b.n	80017bc <xTaskCreate+0x188>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001842:	2501      	movs	r5, #1
                        vPortFree( pxStack );
 8001844:	0038      	movs	r0, r7
 8001846:	f001 f915 	bl	8002a74 <vPortFree>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800184a:	426d      	negs	r5, r5
 800184c:	e7d6      	b.n	80017fc <xTaskCreate+0x1c8>
            pxCurrentTCB = pxNewTCB;
 800184e:	603c      	str	r4, [r7, #0]
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001850:	6813      	ldr	r3, [r2, #0]
 8001852:	4e1c      	ldr	r6, [pc, #112]	; (80018c4 <xTaskCreate+0x290>)
 8001854:	2b01      	cmp	r3, #1
 8001856:	d008      	beq.n	800186a <xTaskCreate+0x236>
 8001858:	4b19      	ldr	r3, [pc, #100]	; (80018c0 <xTaskCreate+0x28c>)
 800185a:	4698      	mov	r8, r3
}
 800185c:	e782      	b.n	8001764 <xTaskCreate+0x130>
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800185e:	2334      	movs	r3, #52	; 0x34
 8001860:	54e5      	strb	r5, [r4, r3]
 8001862:	e73b      	b.n	80016dc <xTaskCreate+0xa8>
            taskYIELD_IF_USING_PREEMPTION();
 8001864:	f001 f818 	bl	8002898 <vPortYield>
 8001868:	e7c8      	b.n	80017fc <xTaskCreate+0x1c8>
 800186a:	2364      	movs	r3, #100	; 0x64
 800186c:	4699      	mov	r9, r3
 800186e:	46b0      	mov	r8, r6
 8001870:	44b1      	add	r9, r6
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001872:	4640      	mov	r0, r8
 8001874:	f7fe fcd4 	bl	8000220 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8001878:	2314      	movs	r3, #20
 800187a:	469c      	mov	ip, r3
 800187c:	44e0      	add	r8, ip
 800187e:	45c1      	cmp	r9, r8
 8001880:	d1f7      	bne.n	8001872 <xTaskCreate+0x23e>
    vListInitialise( &xDelayedTaskList1 );
 8001882:	4b15      	ldr	r3, [pc, #84]	; (80018d8 <xTaskCreate+0x2a4>)
 8001884:	4699      	mov	r9, r3
 8001886:	0018      	movs	r0, r3
 8001888:	f7fe fcca 	bl	8000220 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 800188c:	4b13      	ldr	r3, [pc, #76]	; (80018dc <xTaskCreate+0x2a8>)
 800188e:	0018      	movs	r0, r3
 8001890:	4698      	mov	r8, r3
 8001892:	f7fe fcc5 	bl	8000220 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8001896:	4812      	ldr	r0, [pc, #72]	; (80018e0 <xTaskCreate+0x2ac>)
 8001898:	f7fe fcc2 	bl	8000220 <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
 800189c:	4811      	ldr	r0, [pc, #68]	; (80018e4 <xTaskCreate+0x2b0>)
 800189e:	f7fe fcbf 	bl	8000220 <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
 80018a2:	4811      	ldr	r0, [pc, #68]	; (80018e8 <xTaskCreate+0x2b4>)
 80018a4:	f7fe fcbc 	bl	8000220 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
 80018a8:	464a      	mov	r2, r9
 80018aa:	4b10      	ldr	r3, [pc, #64]	; (80018ec <xTaskCreate+0x2b8>)
 80018ac:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80018ae:	4642      	mov	r2, r8
 80018b0:	4b0f      	ldr	r3, [pc, #60]	; (80018f0 <xTaskCreate+0x2bc>)
 80018b2:	601a      	str	r2, [r3, #0]
 80018b4:	e7d0      	b.n	8001858 <xTaskCreate+0x224>
 80018b6:	46c0      	nop			; (mov r8, r8)
 80018b8:	200000a4 	.word	0x200000a4
 80018bc:	20000034 	.word	0x20000034
 80018c0:	20000104 	.word	0x20000104
 80018c4:	20000040 	.word	0x20000040
 80018c8:	200000b0 	.word	0x200000b0
 80018cc:	20001d7c 	.word	0x20001d7c
 80018d0:	20001d7e 	.word	0x20001d7e
 80018d4:	200000b4 	.word	0x200000b4
 80018d8:	200000b8 	.word	0x200000b8
 80018dc:	200000cc 	.word	0x200000cc
 80018e0:	200000f0 	.word	0x200000f0
 80018e4:	2000011c 	.word	0x2000011c
 80018e8:	20000108 	.word	0x20000108
 80018ec:	20000038 	.word	0x20000038
 80018f0:	2000003c 	.word	0x2000003c

080018f4 <vTaskStartScheduler>:
{
 80018f4:	b510      	push	{r4, lr}
            xReturn = xTaskCreate( prvIdleTask,
 80018f6:	2400      	movs	r4, #0
 80018f8:	4b1b      	ldr	r3, [pc, #108]	; (8001968 <vTaskStartScheduler+0x74>)
{
 80018fa:	b082      	sub	sp, #8
            xReturn = xTaskCreate( prvIdleTask,
 80018fc:	9301      	str	r3, [sp, #4]
 80018fe:	2246      	movs	r2, #70	; 0x46
 8001900:	2300      	movs	r3, #0
 8001902:	491a      	ldr	r1, [pc, #104]	; (800196c <vTaskStartScheduler+0x78>)
 8001904:	481a      	ldr	r0, [pc, #104]	; (8001970 <vTaskStartScheduler+0x7c>)
 8001906:	9400      	str	r4, [sp, #0]
 8001908:	f7ff fe94 	bl	8001634 <xTaskCreate>
            if( xReturn == pdPASS )
 800190c:	2801      	cmp	r0, #1
 800190e:	d007      	beq.n	8001920 <vTaskStartScheduler+0x2c>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001910:	3001      	adds	r0, #1
 8001912:	d003      	beq.n	800191c <vTaskStartScheduler+0x28>
    ( void ) uxTopUsedPriority;
 8001914:	4b17      	ldr	r3, [pc, #92]	; (8001974 <vTaskStartScheduler+0x80>)
 8001916:	681b      	ldr	r3, [r3, #0]
}
 8001918:	b002      	add	sp, #8
 800191a:	bd10      	pop	{r4, pc}
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800191c:	b672      	cpsid	i
 800191e:	e7fe      	b.n	800191e <vTaskStartScheduler+0x2a>
                xReturn = xTimerCreateTimerTask();
 8001920:	f000 ff38 	bl	8002794 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 8001924:	2801      	cmp	r0, #1
 8001926:	d1f3      	bne.n	8001910 <vTaskStartScheduler+0x1c>
        portDISABLE_INTERRUPTS();
 8001928:	b672      	cpsid	i
        xNextTaskUnblockTime = portMAX_DELAY;
 800192a:	2201      	movs	r2, #1
 800192c:	4b12      	ldr	r3, [pc, #72]	; (8001978 <vTaskStartScheduler+0x84>)
 800192e:	4252      	negs	r2, r2
 8001930:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8001932:	4b12      	ldr	r3, [pc, #72]	; (800197c <vTaskStartScheduler+0x88>)
 8001934:	6018      	str	r0, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8001936:	4b12      	ldr	r3, [pc, #72]	; (8001980 <vTaskStartScheduler+0x8c>)
 8001938:	601c      	str	r4, [r3, #0]
        traceTASK_SWITCHED_IN();
 800193a:	4c12      	ldr	r4, [pc, #72]	; (8001984 <vTaskStartScheduler+0x90>)
 800193c:	6020      	str	r0, [r4, #0]
 800193e:	f001 f8ef 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001942:	f001 f8a7 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001946:	4b10      	ldr	r3, [pc, #64]	; (8001988 <vTaskStartScheduler+0x94>)
 8001948:	881b      	ldrh	r3, [r3, #0]
 800194a:	4203      	tst	r3, r0
 800194c:	d104      	bne.n	8001958 <vTaskStartScheduler+0x64>
 800194e:	2302      	movs	r3, #2
 8001950:	6023      	str	r3, [r4, #0]
        if( xPortStartScheduler() != pdFALSE )
 8001952:	f001 f81d 	bl	8002990 <xPortStartScheduler>
 8001956:	e7dd      	b.n	8001914 <vTaskStartScheduler+0x20>
        traceTASK_SWITCHED_IN();
 8001958:	f001 f8e2 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 800195c:	f001 f894 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001960:	b2c0      	uxtb	r0, r0
 8001962:	f002 fd4d 	bl	8004400 <prvTraceStoreTaskswitch>
 8001966:	e7f2      	b.n	800194e <vTaskStartScheduler+0x5a>
 8001968:	200000e0 	.word	0x200000e0
 800196c:	08005db4 	.word	0x08005db4
 8001970:	080014f5 	.word	0x080014f5
 8001974:	20000000 	.word	0x20000000
 8001978:	200000e4 	.word	0x200000e4
 800197c:	20000104 	.word	0x20000104
 8001980:	20000130 	.word	0x20000130
 8001984:	20003490 	.word	0x20003490
 8001988:	20001d7e 	.word	0x20001d7e

0800198c <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 800198c:	4a02      	ldr	r2, [pc, #8]	; (8001998 <vTaskSuspendAll+0xc>)
 800198e:	6813      	ldr	r3, [r2, #0]
 8001990:	3301      	adds	r3, #1
 8001992:	6013      	str	r3, [r2, #0]
}
 8001994:	4770      	bx	lr
 8001996:	46c0      	nop			; (mov r8, r8)
 8001998:	200000ac 	.word	0x200000ac

0800199c <xTaskGetTickCount>:
        xTicks = xTickCount;
 800199c:	4b01      	ldr	r3, [pc, #4]	; (80019a4 <xTaskGetTickCount+0x8>)
 800199e:	6818      	ldr	r0, [r3, #0]
}
 80019a0:	4770      	bx	lr
 80019a2:	46c0      	nop			; (mov r8, r8)
 80019a4:	20000130 	.word	0x20000130

080019a8 <xTaskIncrementTick>:
{
 80019a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019aa:	46de      	mov	lr, fp
 80019ac:	4657      	mov	r7, sl
 80019ae:	464e      	mov	r6, r9
 80019b0:	4645      	mov	r5, r8
 80019b2:	b5e0      	push	{r5, r6, r7, lr}
    traceTASK_INCREMENT_TICK( xTickCount );
 80019b4:	4c64      	ldr	r4, [pc, #400]	; (8001b48 <xTaskIncrementTick+0x1a0>)
{
 80019b6:	b083      	sub	sp, #12
    traceTASK_INCREMENT_TICK( xTickCount );
 80019b8:	6823      	ldr	r3, [r4, #0]
 80019ba:	2b01      	cmp	r3, #1
 80019bc:	d062      	beq.n	8001a84 <xTaskIncrementTick+0xdc>
 80019be:	4b63      	ldr	r3, [pc, #396]	; (8001b4c <xTaskIncrementTick+0x1a4>)
 80019c0:	681b      	ldr	r3, [r3, #0]
 80019c2:	2b00      	cmp	r3, #0
 80019c4:	d05e      	beq.n	8001a84 <xTaskIncrementTick+0xdc>
 80019c6:	6823      	ldr	r3, [r4, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80019c8:	6823      	ldr	r3, [r4, #0]
 80019ca:	2b00      	cmp	r3, #0
 80019cc:	d165      	bne.n	8001a9a <xTaskIncrementTick+0xf2>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80019ce:	4b60      	ldr	r3, [pc, #384]	; (8001b50 <xTaskIncrementTick+0x1a8>)
 80019d0:	681e      	ldr	r6, [r3, #0]
 80019d2:	3601      	adds	r6, #1
        xTickCount = xConstTickCount;
 80019d4:	601e      	str	r6, [r3, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 80019d6:	2e00      	cmp	r6, #0
 80019d8:	d06d      	beq.n	8001ab6 <xTaskIncrementTick+0x10e>
 80019da:	4b5e      	ldr	r3, [pc, #376]	; (8001b54 <xTaskIncrementTick+0x1ac>)
 80019dc:	469a      	mov	sl, r3
        if( xConstTickCount >= xNextTaskUnblockTime )
 80019de:	4653      	mov	r3, sl
 80019e0:	681b      	ldr	r3, [r3, #0]
 80019e2:	429e      	cmp	r6, r3
 80019e4:	d200      	bcs.n	80019e8 <xTaskIncrementTick+0x40>
 80019e6:	e07f      	b.n	8001ae8 <xTaskIncrementTick+0x140>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80019e8:	4f5b      	ldr	r7, [pc, #364]	; (8001b58 <xTaskIncrementTick+0x1b0>)
 80019ea:	683b      	ldr	r3, [r7, #0]
 80019ec:	681b      	ldr	r3, [r3, #0]
 80019ee:	2b00      	cmp	r3, #0
 80019f0:	d100      	bne.n	80019f4 <xTaskIncrementTick+0x4c>
 80019f2:	e094      	b.n	8001b1e <xTaskIncrementTick+0x176>
    BaseType_t xSwitchRequired = pdFALSE;
 80019f4:	2300      	movs	r3, #0
 80019f6:	4698      	mov	r8, r3
 80019f8:	4b58      	ldr	r3, [pc, #352]	; (8001b5c <xTaskIncrementTick+0x1b4>)
 80019fa:	9300      	str	r3, [sp, #0]
 80019fc:	4b58      	ldr	r3, [pc, #352]	; (8001b60 <xTaskIncrementTick+0x1b8>)
 80019fe:	469b      	mov	fp, r3
                    prvAddTaskToReadyList( pxTCB );
 8001a00:	4b58      	ldr	r3, [pc, #352]	; (8001b64 <xTaskIncrementTick+0x1bc>)
 8001a02:	9301      	str	r3, [sp, #4]
 8001a04:	4b58      	ldr	r3, [pc, #352]	; (8001b68 <xTaskIncrementTick+0x1c0>)
 8001a06:	4699      	mov	r9, r3
 8001a08:	e01c      	b.n	8001a44 <xTaskIncrementTick+0x9c>
 8001a0a:	464a      	mov	r2, r9
 8001a0c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001a0e:	6812      	ldr	r2, [r2, #0]
 8001a10:	4293      	cmp	r3, r2
 8001a12:	d901      	bls.n	8001a18 <xTaskIncrementTick+0x70>
 8001a14:	464a      	mov	r2, r9
 8001a16:	6013      	str	r3, [r2, #0]
 8001a18:	0098      	lsls	r0, r3, #2
 8001a1a:	18c0      	adds	r0, r0, r3
 8001a1c:	9b00      	ldr	r3, [sp, #0]
 8001a1e:	0080      	lsls	r0, r0, #2
 8001a20:	469c      	mov	ip, r3
 8001a22:	0029      	movs	r1, r5
 8001a24:	4460      	add	r0, ip
 8001a26:	f7fe fc0b 	bl	8000240 <vListInsertEnd>
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001a2a:	465b      	mov	r3, fp
 8001a2c:	681b      	ldr	r3, [r3, #0]
 8001a2e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001a32:	429a      	cmp	r2, r3
 8001a34:	d301      	bcc.n	8001a3a <xTaskIncrementTick+0x92>
                                xSwitchRequired = pdTRUE;
 8001a36:	2301      	movs	r3, #1
 8001a38:	4698      	mov	r8, r3
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001a3a:	683b      	ldr	r3, [r7, #0]
 8001a3c:	681b      	ldr	r3, [r3, #0]
 8001a3e:	2b00      	cmp	r3, #0
 8001a40:	d100      	bne.n	8001a44 <xTaskIncrementTick+0x9c>
 8001a42:	e072      	b.n	8001b2a <xTaskIncrementTick+0x182>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001a44:	683b      	ldr	r3, [r7, #0]
 8001a46:	68db      	ldr	r3, [r3, #12]
 8001a48:	68dc      	ldr	r4, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001a4a:	6863      	ldr	r3, [r4, #4]
                    if( xConstTickCount < xItemValue )
 8001a4c:	429e      	cmp	r6, r3
 8001a4e:	d200      	bcs.n	8001a52 <xTaskIncrementTick+0xaa>
 8001a50:	e070      	b.n	8001b34 <xTaskIncrementTick+0x18c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001a52:	1d25      	adds	r5, r4, #4
 8001a54:	0028      	movs	r0, r5
 8001a56:	f7fe fc17 	bl	8000288 <uxListRemove>
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001a5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001a5c:	2b00      	cmp	r3, #0
 8001a5e:	d003      	beq.n	8001a68 <xTaskIncrementTick+0xc0>
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001a60:	0020      	movs	r0, r4
 8001a62:	3018      	adds	r0, #24
 8001a64:	f7fe fc10 	bl	8000288 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001a68:	0020      	movs	r0, r4
 8001a6a:	f001 f813 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001a6e:	9b01      	ldr	r3, [sp, #4]
 8001a70:	881b      	ldrh	r3, [r3, #0]
 8001a72:	4203      	tst	r3, r0
 8001a74:	d0c9      	beq.n	8001a0a <xTaskIncrementTick+0x62>
 8001a76:	0020      	movs	r0, r4
 8001a78:	f001 f806 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001a7c:	b2c0      	uxtb	r0, r0
 8001a7e:	f001 fb0d 	bl	800309c <prvTraceStoreTaskReady>
 8001a82:	e7c2      	b.n	8001a0a <xTaskIncrementTick+0x62>
    traceTASK_INCREMENT_TICK( xTickCount );
 8001a84:	4a39      	ldr	r2, [pc, #228]	; (8001b6c <xTaskIncrementTick+0x1c4>)
 8001a86:	2000      	movs	r0, #0
 8001a88:	6813      	ldr	r3, [r2, #0]
 8001a8a:	3301      	adds	r3, #1
 8001a8c:	6013      	str	r3, [r2, #0]
 8001a8e:	f003 f8fb 	bl	8004c88 <prvTracePortGetTimeStamp>
 8001a92:	6823      	ldr	r3, [r4, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001a94:	6823      	ldr	r3, [r4, #0]
 8001a96:	2b00      	cmp	r3, #0
 8001a98:	d099      	beq.n	80019ce <xTaskIncrementTick+0x26>
        ++xPendedTicks;
 8001a9a:	4a2c      	ldr	r2, [pc, #176]	; (8001b4c <xTaskIncrementTick+0x1a4>)
 8001a9c:	6813      	ldr	r3, [r2, #0]
 8001a9e:	3301      	adds	r3, #1
 8001aa0:	6013      	str	r3, [r2, #0]
    BaseType_t xSwitchRequired = pdFALSE;
 8001aa2:	2300      	movs	r3, #0
 8001aa4:	4698      	mov	r8, r3
}
 8001aa6:	4640      	mov	r0, r8
 8001aa8:	b003      	add	sp, #12
 8001aaa:	bcf0      	pop	{r4, r5, r6, r7}
 8001aac:	46bb      	mov	fp, r7
 8001aae:	46b2      	mov	sl, r6
 8001ab0:	46a9      	mov	r9, r5
 8001ab2:	46a0      	mov	r8, r4
 8001ab4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            taskSWITCH_DELAYED_LISTS();
 8001ab6:	4b28      	ldr	r3, [pc, #160]	; (8001b58 <xTaskIncrementTick+0x1b0>)
 8001ab8:	681a      	ldr	r2, [r3, #0]
 8001aba:	6812      	ldr	r2, [r2, #0]
 8001abc:	2a00      	cmp	r2, #0
 8001abe:	d12c      	bne.n	8001b1a <xTaskIncrementTick+0x172>
 8001ac0:	4a2b      	ldr	r2, [pc, #172]	; (8001b70 <xTaskIncrementTick+0x1c8>)
 8001ac2:	6819      	ldr	r1, [r3, #0]
 8001ac4:	6810      	ldr	r0, [r2, #0]
 8001ac6:	6018      	str	r0, [r3, #0]
 8001ac8:	6011      	str	r1, [r2, #0]
 8001aca:	492a      	ldr	r1, [pc, #168]	; (8001b74 <xTaskIncrementTick+0x1cc>)
 8001acc:	680a      	ldr	r2, [r1, #0]
 8001ace:	3201      	adds	r2, #1
 8001ad0:	600a      	str	r2, [r1, #0]
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001ad2:	681a      	ldr	r2, [r3, #0]
 8001ad4:	6812      	ldr	r2, [r2, #0]
 8001ad6:	2a00      	cmp	r2, #0
 8001ad8:	d12f      	bne.n	8001b3a <xTaskIncrementTick+0x192>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 8001ada:	4b1e      	ldr	r3, [pc, #120]	; (8001b54 <xTaskIncrementTick+0x1ac>)
 8001adc:	469a      	mov	sl, r3
 8001ade:	2301      	movs	r3, #1
 8001ae0:	4652      	mov	r2, sl
 8001ae2:	425b      	negs	r3, r3
 8001ae4:	6013      	str	r3, [r2, #0]
 8001ae6:	e77a      	b.n	80019de <xTaskIncrementTick+0x36>
    BaseType_t xSwitchRequired = pdFALSE;
 8001ae8:	2300      	movs	r3, #0
 8001aea:	4698      	mov	r8, r3
 8001aec:	4b1b      	ldr	r3, [pc, #108]	; (8001b5c <xTaskIncrementTick+0x1b4>)
 8001aee:	9300      	str	r3, [sp, #0]
 8001af0:	4b1b      	ldr	r3, [pc, #108]	; (8001b60 <xTaskIncrementTick+0x1b8>)
 8001af2:	469b      	mov	fp, r3
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001af4:	465b      	mov	r3, fp
 8001af6:	681b      	ldr	r3, [r3, #0]
 8001af8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001afa:	0093      	lsls	r3, r2, #2
 8001afc:	189b      	adds	r3, r3, r2
 8001afe:	9a00      	ldr	r2, [sp, #0]
 8001b00:	009b      	lsls	r3, r3, #2
 8001b02:	58d3      	ldr	r3, [r2, r3]
 8001b04:	2b01      	cmp	r3, #1
 8001b06:	d901      	bls.n	8001b0c <xTaskIncrementTick+0x164>
                    xSwitchRequired = pdTRUE;
 8001b08:	2301      	movs	r3, #1
 8001b0a:	4698      	mov	r8, r3
                if( xYieldPending != pdFALSE )
 8001b0c:	4b1a      	ldr	r3, [pc, #104]	; (8001b78 <xTaskIncrementTick+0x1d0>)
 8001b0e:	681b      	ldr	r3, [r3, #0]
 8001b10:	2b00      	cmp	r3, #0
 8001b12:	d0c8      	beq.n	8001aa6 <xTaskIncrementTick+0xfe>
                    xSwitchRequired = pdTRUE;
 8001b14:	2301      	movs	r3, #1
 8001b16:	4698      	mov	r8, r3
 8001b18:	e7c5      	b.n	8001aa6 <xTaskIncrementTick+0xfe>
            taskSWITCH_DELAYED_LISTS();
 8001b1a:	b672      	cpsid	i
 8001b1c:	e7fe      	b.n	8001b1c <xTaskIncrementTick+0x174>
    BaseType_t xSwitchRequired = pdFALSE;
 8001b1e:	2300      	movs	r3, #0
 8001b20:	4698      	mov	r8, r3
 8001b22:	4b0e      	ldr	r3, [pc, #56]	; (8001b5c <xTaskIncrementTick+0x1b4>)
 8001b24:	9300      	str	r3, [sp, #0]
 8001b26:	4b0e      	ldr	r3, [pc, #56]	; (8001b60 <xTaskIncrementTick+0x1b8>)
 8001b28:	469b      	mov	fp, r3
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001b2a:	2301      	movs	r3, #1
 8001b2c:	4652      	mov	r2, sl
 8001b2e:	425b      	negs	r3, r3
 8001b30:	6013      	str	r3, [r2, #0]
                    break;
 8001b32:	e7df      	b.n	8001af4 <xTaskIncrementTick+0x14c>
                        xNextTaskUnblockTime = xItemValue;
 8001b34:	4652      	mov	r2, sl
 8001b36:	6013      	str	r3, [r2, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8001b38:	e7dc      	b.n	8001af4 <xTaskIncrementTick+0x14c>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001b3a:	681b      	ldr	r3, [r3, #0]
 8001b3c:	4a05      	ldr	r2, [pc, #20]	; (8001b54 <xTaskIncrementTick+0x1ac>)
 8001b3e:	68db      	ldr	r3, [r3, #12]
 8001b40:	4692      	mov	sl, r2
 8001b42:	681b      	ldr	r3, [r3, #0]
 8001b44:	6013      	str	r3, [r2, #0]
    }
}
 8001b46:	e74a      	b.n	80019de <xTaskIncrementTick+0x36>
 8001b48:	200000ac 	.word	0x200000ac
 8001b4c:	200000ec 	.word	0x200000ec
 8001b50:	20000130 	.word	0x20000130
 8001b54:	200000e4 	.word	0x200000e4
 8001b58:	20000038 	.word	0x20000038
 8001b5c:	20000040 	.word	0x20000040
 8001b60:	20000034 	.word	0x20000034
 8001b64:	20001d7e 	.word	0x20001d7e
 8001b68:	200000b4 	.word	0x200000b4
 8001b6c:	20003494 	.word	0x20003494
 8001b70:	2000003c 	.word	0x2000003c
 8001b74:	200000e8 	.word	0x200000e8
 8001b78:	20000134 	.word	0x20000134

08001b7c <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 8001b7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001b7e:	46de      	mov	lr, fp
 8001b80:	4657      	mov	r7, sl
 8001b82:	464e      	mov	r6, r9
 8001b84:	4645      	mov	r5, r8
 8001b86:	b5e0      	push	{r5, r6, r7, lr}
    taskENTER_CRITICAL();
 8001b88:	f000 fe92 	bl	80028b0 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8001b8c:	4b3e      	ldr	r3, [pc, #248]	; (8001c88 <xTaskResumeAll.part.0+0x10c>)
 8001b8e:	681a      	ldr	r2, [r3, #0]
 8001b90:	3a01      	subs	r2, #1
 8001b92:	601a      	str	r2, [r3, #0]
        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001b94:	681b      	ldr	r3, [r3, #0]
 8001b96:	2b00      	cmp	r3, #0
 8001b98:	d15a      	bne.n	8001c50 <xTaskResumeAll.part.0+0xd4>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8001b9a:	4b3c      	ldr	r3, [pc, #240]	; (8001c8c <xTaskResumeAll.part.0+0x110>)
 8001b9c:	681b      	ldr	r3, [r3, #0]
 8001b9e:	2b00      	cmp	r3, #0
 8001ba0:	d056      	beq.n	8001c50 <xTaskResumeAll.part.0+0xd4>
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001ba2:	4e3b      	ldr	r6, [pc, #236]	; (8001c90 <xTaskResumeAll.part.0+0x114>)
 8001ba4:	6833      	ldr	r3, [r6, #0]
 8001ba6:	2b00      	cmp	r3, #0
 8001ba8:	d06b      	beq.n	8001c82 <xTaskResumeAll.part.0+0x106>
 8001baa:	4b3a      	ldr	r3, [pc, #232]	; (8001c94 <xTaskResumeAll.part.0+0x118>)
 8001bac:	4f3a      	ldr	r7, [pc, #232]	; (8001c98 <xTaskResumeAll.part.0+0x11c>)
 8001bae:	469a      	mov	sl, r3
 8001bb0:	4b3a      	ldr	r3, [pc, #232]	; (8001c9c <xTaskResumeAll.part.0+0x120>)
 8001bb2:	4699      	mov	r9, r3
 8001bb4:	4b3a      	ldr	r3, [pc, #232]	; (8001ca0 <xTaskResumeAll.part.0+0x124>)
 8001bb6:	4698      	mov	r8, r3
 8001bb8:	4b3a      	ldr	r3, [pc, #232]	; (8001ca4 <xTaskResumeAll.part.0+0x128>)
 8001bba:	469b      	mov	fp, r3
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001bbc:	68f3      	ldr	r3, [r6, #12]
 8001bbe:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001bc0:	0020      	movs	r0, r4
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001bc2:	1d25      	adds	r5, r4, #4
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001bc4:	3018      	adds	r0, #24
 8001bc6:	f7fe fb5f 	bl	8000288 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001bca:	0028      	movs	r0, r5
 8001bcc:	f7fe fb5c 	bl	8000288 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001bd0:	0020      	movs	r0, r4
 8001bd2:	f000 ff5f 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001bd6:	4653      	mov	r3, sl
 8001bd8:	881b      	ldrh	r3, [r3, #0]
 8001bda:	4203      	tst	r3, r0
 8001bdc:	d146      	bne.n	8001c6c <xTaskResumeAll.part.0+0xf0>
 8001bde:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001be0:	683a      	ldr	r2, [r7, #0]
 8001be2:	4293      	cmp	r3, r2
 8001be4:	d900      	bls.n	8001be8 <xTaskResumeAll.part.0+0x6c>
 8001be6:	603b      	str	r3, [r7, #0]
 8001be8:	0098      	lsls	r0, r3, #2
 8001bea:	18c0      	adds	r0, r0, r3
 8001bec:	0080      	lsls	r0, r0, #2
 8001bee:	0029      	movs	r1, r5
 8001bf0:	4448      	add	r0, r9
 8001bf2:	f7fe fb25 	bl	8000240 <vListInsertEnd>
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001bf6:	4643      	mov	r3, r8
 8001bf8:	681b      	ldr	r3, [r3, #0]
 8001bfa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001bfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001bfe:	429a      	cmp	r2, r3
 8001c00:	d330      	bcc.n	8001c64 <xTaskResumeAll.part.0+0xe8>
                        xYieldPending = pdTRUE;
 8001c02:	465b      	mov	r3, fp
 8001c04:	2201      	movs	r2, #1
 8001c06:	601a      	str	r2, [r3, #0]
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001c08:	6833      	ldr	r3, [r6, #0]
 8001c0a:	2b00      	cmp	r3, #0
 8001c0c:	d1d6      	bne.n	8001bbc <xTaskResumeAll.part.0+0x40>
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001c0e:	4b26      	ldr	r3, [pc, #152]	; (8001ca8 <xTaskResumeAll.part.0+0x12c>)
 8001c10:	681a      	ldr	r2, [r3, #0]
 8001c12:	6812      	ldr	r2, [r2, #0]
 8001c14:	2a00      	cmp	r2, #0
 8001c16:	d030      	beq.n	8001c7a <xTaskResumeAll.part.0+0xfe>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001c18:	681b      	ldr	r3, [r3, #0]
 8001c1a:	68db      	ldr	r3, [r3, #12]
 8001c1c:	681a      	ldr	r2, [r3, #0]
 8001c1e:	4b23      	ldr	r3, [pc, #140]	; (8001cac <xTaskResumeAll.part.0+0x130>)
 8001c20:	601a      	str	r2, [r3, #0]
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8001c22:	4e23      	ldr	r6, [pc, #140]	; (8001cb0 <xTaskResumeAll.part.0+0x134>)
 8001c24:	6834      	ldr	r4, [r6, #0]
                    if( xPendedCounts > ( TickType_t ) 0U )
 8001c26:	2c00      	cmp	r4, #0
 8001c28:	d00a      	beq.n	8001c40 <xTaskResumeAll.part.0+0xc4>
                                xYieldPending = pdTRUE;
 8001c2a:	2501      	movs	r5, #1
                            if( xTaskIncrementTick() != pdFALSE )
 8001c2c:	f7ff febc 	bl	80019a8 <xTaskIncrementTick>
 8001c30:	2800      	cmp	r0, #0
 8001c32:	d001      	beq.n	8001c38 <xTaskResumeAll.part.0+0xbc>
                                xYieldPending = pdTRUE;
 8001c34:	465b      	mov	r3, fp
 8001c36:	601d      	str	r5, [r3, #0]
                            --xPendedCounts;
 8001c38:	3c01      	subs	r4, #1
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8001c3a:	2c00      	cmp	r4, #0
 8001c3c:	d1f6      	bne.n	8001c2c <xTaskResumeAll.part.0+0xb0>
                        xPendedTicks = 0;
 8001c3e:	6034      	str	r4, [r6, #0]
                if( xYieldPending != pdFALSE )
 8001c40:	465b      	mov	r3, fp
 8001c42:	681b      	ldr	r3, [r3, #0]
 8001c44:	2b00      	cmp	r3, #0
 8001c46:	d003      	beq.n	8001c50 <xTaskResumeAll.part.0+0xd4>
                    taskYIELD_IF_USING_PREEMPTION();
 8001c48:	f000 fe26 	bl	8002898 <vPortYield>
                            xAlreadyYielded = pdTRUE;
 8001c4c:	2401      	movs	r4, #1
 8001c4e:	e000      	b.n	8001c52 <xTaskResumeAll.part.0+0xd6>
    BaseType_t xAlreadyYielded = pdFALSE;
 8001c50:	2400      	movs	r4, #0
    taskEXIT_CRITICAL();
 8001c52:	f000 fe39 	bl	80028c8 <vPortExitCritical>
}
 8001c56:	0020      	movs	r0, r4
 8001c58:	bcf0      	pop	{r4, r5, r6, r7}
 8001c5a:	46bb      	mov	fp, r7
 8001c5c:	46b2      	mov	sl, r6
 8001c5e:	46a9      	mov	r9, r5
 8001c60:	46a0      	mov	r8, r4
 8001c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001c64:	6833      	ldr	r3, [r6, #0]
 8001c66:	2b00      	cmp	r3, #0
 8001c68:	d1a8      	bne.n	8001bbc <xTaskResumeAll.part.0+0x40>
 8001c6a:	e7d0      	b.n	8001c0e <xTaskResumeAll.part.0+0x92>
                    prvAddTaskToReadyList( pxTCB );
 8001c6c:	0020      	movs	r0, r4
 8001c6e:	f000 ff0b 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001c72:	b2c0      	uxtb	r0, r0
 8001c74:	f001 fa12 	bl	800309c <prvTraceStoreTaskReady>
 8001c78:	e7b1      	b.n	8001bde <xTaskResumeAll.part.0+0x62>
        xNextTaskUnblockTime = portMAX_DELAY;
 8001c7a:	4b0c      	ldr	r3, [pc, #48]	; (8001cac <xTaskResumeAll.part.0+0x130>)
 8001c7c:	3a01      	subs	r2, #1
 8001c7e:	601a      	str	r2, [r3, #0]
 8001c80:	e7cf      	b.n	8001c22 <xTaskResumeAll.part.0+0xa6>
 8001c82:	4b08      	ldr	r3, [pc, #32]	; (8001ca4 <xTaskResumeAll.part.0+0x128>)
 8001c84:	469b      	mov	fp, r3
 8001c86:	e7cc      	b.n	8001c22 <xTaskResumeAll.part.0+0xa6>
 8001c88:	200000ac 	.word	0x200000ac
 8001c8c:	200000a4 	.word	0x200000a4
 8001c90:	200000f0 	.word	0x200000f0
 8001c94:	20001d7e 	.word	0x20001d7e
 8001c98:	200000b4 	.word	0x200000b4
 8001c9c:	20000040 	.word	0x20000040
 8001ca0:	20000034 	.word	0x20000034
 8001ca4:	20000134 	.word	0x20000134
 8001ca8:	20000038 	.word	0x20000038
 8001cac:	200000e4 	.word	0x200000e4
 8001cb0:	200000ec 	.word	0x200000ec

08001cb4 <xTaskResumeAll>:
    configASSERT( uxSchedulerSuspended );
 8001cb4:	4b04      	ldr	r3, [pc, #16]	; (8001cc8 <xTaskResumeAll+0x14>)
{
 8001cb6:	b510      	push	{r4, lr}
    configASSERT( uxSchedulerSuspended );
 8001cb8:	681b      	ldr	r3, [r3, #0]
 8001cba:	2b00      	cmp	r3, #0
 8001cbc:	d101      	bne.n	8001cc2 <xTaskResumeAll+0xe>
 8001cbe:	b672      	cpsid	i
 8001cc0:	e7fe      	b.n	8001cc0 <xTaskResumeAll+0xc>
 8001cc2:	f7ff ff5b 	bl	8001b7c <xTaskResumeAll.part.0>
}
 8001cc6:	bd10      	pop	{r4, pc}
 8001cc8:	200000ac 	.word	0x200000ac

08001ccc <xTaskDelayUntil>:
    {
 8001ccc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cce:	46ce      	mov	lr, r9
 8001cd0:	4647      	mov	r7, r8
 8001cd2:	b580      	push	{r7, lr}
        configASSERT( pxPreviousWakeTime );
 8001cd4:	2800      	cmp	r0, #0
 8001cd6:	d019      	beq.n	8001d0c <xTaskDelayUntil+0x40>
        configASSERT( ( xTimeIncrement > 0U ) );
 8001cd8:	2900      	cmp	r1, #0
 8001cda:	d101      	bne.n	8001ce0 <xTaskDelayUntil+0x14>
 8001cdc:	b672      	cpsid	i
 8001cde:	e7fe      	b.n	8001cde <xTaskDelayUntil+0x12>
        configASSERT( uxSchedulerSuspended == 0 );
 8001ce0:	4d3a      	ldr	r5, [pc, #232]	; (8001dcc <xTaskDelayUntil+0x100>)
 8001ce2:	682b      	ldr	r3, [r5, #0]
 8001ce4:	2b00      	cmp	r3, #0
 8001ce6:	d113      	bne.n	8001d10 <xTaskDelayUntil+0x44>
    ++uxSchedulerSuspended;
 8001ce8:	682b      	ldr	r3, [r5, #0]
 8001cea:	3301      	adds	r3, #1
 8001cec:	602b      	str	r3, [r5, #0]
            const TickType_t xConstTickCount = xTickCount;
 8001cee:	4f38      	ldr	r7, [pc, #224]	; (8001dd0 <xTaskDelayUntil+0x104>)
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8001cf0:	6803      	ldr	r3, [r0, #0]
            const TickType_t xConstTickCount = xTickCount;
 8001cf2:	683e      	ldr	r6, [r7, #0]
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8001cf4:	185c      	adds	r4, r3, r1
            if( xConstTickCount < *pxPreviousWakeTime )
 8001cf6:	42b3      	cmp	r3, r6
 8001cf8:	d90c      	bls.n	8001d14 <xTaskDelayUntil+0x48>
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8001cfa:	42a3      	cmp	r3, r4
 8001cfc:	d80c      	bhi.n	8001d18 <xTaskDelayUntil+0x4c>
            *pxPreviousWakeTime = xTimeToWake;
 8001cfe:	6004      	str	r4, [r0, #0]
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 8001d00:	2400      	movs	r4, #0
    configASSERT( uxSchedulerSuspended );
 8001d02:	682b      	ldr	r3, [r5, #0]
 8001d04:	2b00      	cmp	r3, #0
 8001d06:	d137      	bne.n	8001d78 <xTaskDelayUntil+0xac>
 8001d08:	b672      	cpsid	i
 8001d0a:	e7fe      	b.n	8001d0a <xTaskDelayUntil+0x3e>
        configASSERT( pxPreviousWakeTime );
 8001d0c:	b672      	cpsid	i
 8001d0e:	e7fe      	b.n	8001d0e <xTaskDelayUntil+0x42>
        configASSERT( uxSchedulerSuspended == 0 );
 8001d10:	b672      	cpsid	i
 8001d12:	e7fe      	b.n	8001d12 <xTaskDelayUntil+0x46>
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 8001d14:	42a3      	cmp	r3, r4
 8001d16:	d801      	bhi.n	8001d1c <xTaskDelayUntil+0x50>
 8001d18:	42a6      	cmp	r6, r4
 8001d1a:	d2f0      	bcs.n	8001cfe <xTaskDelayUntil+0x32>
                traceTASK_DELAY_UNTIL( xTimeToWake );
 8001d1c:	4b2d      	ldr	r3, [pc, #180]	; (8001dd4 <xTaskDelayUntil+0x108>)
            *pxPreviousWakeTime = xTimeToWake;
 8001d1e:	6004      	str	r4, [r0, #0]
                traceTASK_DELAY_UNTIL( xTimeToWake );
 8001d20:	6818      	ldr	r0, [r3, #0]
 8001d22:	4698      	mov	r8, r3
 8001d24:	f000 feb6 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001d28:	4b2b      	ldr	r3, [pc, #172]	; (8001dd8 <xTaskDelayUntil+0x10c>)
 8001d2a:	4699      	mov	r9, r3
 8001d2c:	881b      	ldrh	r3, [r3, #0]
 8001d2e:	4203      	tst	r3, r0
 8001d30:	d13f      	bne.n	8001db2 <xTaskDelayUntil+0xe6>
 8001d32:	f000 fef5 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001d36:	f000 fead 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001d3a:	464b      	mov	r3, r9
 8001d3c:	881b      	ldrh	r3, [r3, #0]
 8001d3e:	4203      	tst	r3, r0
 8001d40:	d12f      	bne.n	8001da2 <xTaskDelayUntil+0xd6>
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001d42:	4643      	mov	r3, r8
    const TickType_t xConstTickCount = xTickCount;
 8001d44:	683f      	ldr	r7, [r7, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001d46:	6818      	ldr	r0, [r3, #0]
 8001d48:	1bbe      	subs	r6, r7, r6
 8001d4a:	3004      	adds	r0, #4
 8001d4c:	f7fe fa9c 	bl	8000288 <uxListRemove>
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001d50:	4643      	mov	r3, r8
 8001d52:	681b      	ldr	r3, [r3, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001d54:	19a6      	adds	r6, r4, r6
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001d56:	605e      	str	r6, [r3, #4]

                if( xTimeToWake < xConstTickCount )
 8001d58:	42b7      	cmp	r7, r6
 8001d5a:	d816      	bhi.n	8001d8a <xTaskDelayUntil+0xbe>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001d5c:	4b1f      	ldr	r3, [pc, #124]	; (8001ddc <xTaskDelayUntil+0x110>)
 8001d5e:	2401      	movs	r4, #1
 8001d60:	6818      	ldr	r0, [r3, #0]
 8001d62:	4643      	mov	r3, r8
 8001d64:	6819      	ldr	r1, [r3, #0]
 8001d66:	3104      	adds	r1, #4
 8001d68:	f7fe fa76 	bl	8000258 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001d6c:	4b1c      	ldr	r3, [pc, #112]	; (8001de0 <xTaskDelayUntil+0x114>)
 8001d6e:	681a      	ldr	r2, [r3, #0]
 8001d70:	4296      	cmp	r6, r2
 8001d72:	d2c6      	bcs.n	8001d02 <xTaskDelayUntil+0x36>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
 8001d74:	601e      	str	r6, [r3, #0]
 8001d76:	e7c4      	b.n	8001d02 <xTaskDelayUntil+0x36>
 8001d78:	f7ff ff00 	bl	8001b7c <xTaskResumeAll.part.0>
        if( xAlreadyYielded == pdFALSE )
 8001d7c:	2800      	cmp	r0, #0
 8001d7e:	d00d      	beq.n	8001d9c <xTaskDelayUntil+0xd0>
    }
 8001d80:	0020      	movs	r0, r4
 8001d82:	bcc0      	pop	{r6, r7}
 8001d84:	46b9      	mov	r9, r7
 8001d86:	46b0      	mov	r8, r6
 8001d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001d8a:	4b16      	ldr	r3, [pc, #88]	; (8001de4 <xTaskDelayUntil+0x118>)
 8001d8c:	2401      	movs	r4, #1
 8001d8e:	6818      	ldr	r0, [r3, #0]
 8001d90:	4643      	mov	r3, r8
 8001d92:	6819      	ldr	r1, [r3, #0]
 8001d94:	3104      	adds	r1, #4
 8001d96:	f7fe fa5f 	bl	8000258 <vListInsert>
 8001d9a:	e7b2      	b.n	8001d02 <xTaskDelayUntil+0x36>
            portYIELD_WITHIN_API();
 8001d9c:	f000 fd7c 	bl	8002898 <vPortYield>
        return xShouldDelay;
 8001da0:	e7ee      	b.n	8001d80 <xTaskDelayUntil+0xb4>
                traceTASK_DELAY_UNTIL( xTimeToWake );
 8001da2:	f000 febd 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001da6:	f000 fe6f 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001daa:	b2c0      	uxtb	r0, r0
 8001dac:	f002 fa34 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001db0:	e7c7      	b.n	8001d42 <xTaskDelayUntil+0x76>
 8001db2:	0021      	movs	r1, r4
 8001db4:	2088      	movs	r0, #136	; 0x88
 8001db6:	f001 fecd 	bl	8003b54 <prvTraceStoreKernelCallWithNumericParamOnly>
 8001dba:	4643      	mov	r3, r8
 8001dbc:	6818      	ldr	r0, [r3, #0]
 8001dbe:	f000 fe63 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001dc2:	b2c0      	uxtb	r0, r0
 8001dc4:	f002 fa28 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001dc8:	e7b3      	b.n	8001d32 <xTaskDelayUntil+0x66>
 8001dca:	46c0      	nop			; (mov r8, r8)
 8001dcc:	200000ac 	.word	0x200000ac
 8001dd0:	20000130 	.word	0x20000130
 8001dd4:	20000034 	.word	0x20000034
 8001dd8:	20001d7e 	.word	0x20001d7e
 8001ddc:	20000038 	.word	0x20000038
 8001de0:	200000e4 	.word	0x200000e4
 8001de4:	2000003c 	.word	0x2000003c

08001de8 <vTaskDelay>:
    {
 8001de8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001dea:	1e04      	subs	r4, r0, #0
        if( xTicksToDelay > ( TickType_t ) 0U )
 8001dec:	d036      	beq.n	8001e5c <vTaskDelay+0x74>
            configASSERT( uxSchedulerSuspended == 0 );
 8001dee:	4d2a      	ldr	r5, [pc, #168]	; (8001e98 <vTaskDelay+0xb0>)
 8001df0:	682b      	ldr	r3, [r5, #0]
 8001df2:	2b00      	cmp	r3, #0
 8001df4:	d001      	beq.n	8001dfa <vTaskDelay+0x12>
 8001df6:	b672      	cpsid	i
 8001df8:	e7fe      	b.n	8001df8 <vTaskDelay+0x10>
    ++uxSchedulerSuspended;
 8001dfa:	682b      	ldr	r3, [r5, #0]
 8001dfc:	3301      	adds	r3, #1
 8001dfe:	602b      	str	r3, [r5, #0]
                traceTASK_DELAY();
 8001e00:	4e26      	ldr	r6, [pc, #152]	; (8001e9c <vTaskDelay+0xb4>)
 8001e02:	6830      	ldr	r0, [r6, #0]
 8001e04:	f000 fe46 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001e08:	4f25      	ldr	r7, [pc, #148]	; (8001ea0 <vTaskDelay+0xb8>)
 8001e0a:	883b      	ldrh	r3, [r7, #0]
 8001e0c:	4203      	tst	r3, r0
 8001e0e:	d137      	bne.n	8001e80 <vTaskDelay+0x98>
 8001e10:	f000 fe86 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001e14:	f000 fe3e 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001e18:	883b      	ldrh	r3, [r7, #0]
 8001e1a:	4203      	tst	r3, r0
 8001e1c:	d128      	bne.n	8001e70 <vTaskDelay+0x88>
    const TickType_t xConstTickCount = xTickCount;
 8001e1e:	4b21      	ldr	r3, [pc, #132]	; (8001ea4 <vTaskDelay+0xbc>)
 8001e20:	681f      	ldr	r7, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001e22:	6830      	ldr	r0, [r6, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001e24:	19e4      	adds	r4, r4, r7
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001e26:	3004      	adds	r0, #4
 8001e28:	f7fe fa2e 	bl	8000288 <uxListRemove>
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001e2c:	6833      	ldr	r3, [r6, #0]
 8001e2e:	605c      	str	r4, [r3, #4]
                if( xTimeToWake < xConstTickCount )
 8001e30:	42a7      	cmp	r7, r4
 8001e32:	d816      	bhi.n	8001e62 <vTaskDelay+0x7a>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001e34:	4b1c      	ldr	r3, [pc, #112]	; (8001ea8 <vTaskDelay+0xc0>)
 8001e36:	6818      	ldr	r0, [r3, #0]
 8001e38:	6831      	ldr	r1, [r6, #0]
 8001e3a:	3104      	adds	r1, #4
 8001e3c:	f7fe fa0c 	bl	8000258 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001e40:	4b1a      	ldr	r3, [pc, #104]	; (8001eac <vTaskDelay+0xc4>)
 8001e42:	681a      	ldr	r2, [r3, #0]
 8001e44:	4294      	cmp	r4, r2
 8001e46:	d200      	bcs.n	8001e4a <vTaskDelay+0x62>
                        xNextTaskUnblockTime = xTimeToWake;
 8001e48:	601c      	str	r4, [r3, #0]
    configASSERT( uxSchedulerSuspended );
 8001e4a:	682b      	ldr	r3, [r5, #0]
 8001e4c:	2b00      	cmp	r3, #0
 8001e4e:	d101      	bne.n	8001e54 <vTaskDelay+0x6c>
 8001e50:	b672      	cpsid	i
 8001e52:	e7fe      	b.n	8001e52 <vTaskDelay+0x6a>
 8001e54:	f7ff fe92 	bl	8001b7c <xTaskResumeAll.part.0>
        if( xAlreadyYielded == pdFALSE )
 8001e58:	2800      	cmp	r0, #0
 8001e5a:	d101      	bne.n	8001e60 <vTaskDelay+0x78>
            portYIELD_WITHIN_API();
 8001e5c:	f000 fd1c 	bl	8002898 <vPortYield>
    }
 8001e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001e62:	4b13      	ldr	r3, [pc, #76]	; (8001eb0 <vTaskDelay+0xc8>)
 8001e64:	6818      	ldr	r0, [r3, #0]
 8001e66:	6831      	ldr	r1, [r6, #0]
 8001e68:	3104      	adds	r1, #4
 8001e6a:	f7fe f9f5 	bl	8000258 <vListInsert>
 8001e6e:	e7ec      	b.n	8001e4a <vTaskDelay+0x62>
                traceTASK_DELAY();
 8001e70:	f000 fe56 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001e74:	f000 fe08 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001e78:	b2c0      	uxtb	r0, r0
 8001e7a:	f002 f9cd 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001e7e:	e7ce      	b.n	8001e1e <vTaskDelay+0x36>
 8001e80:	0021      	movs	r1, r4
 8001e82:	2089      	movs	r0, #137	; 0x89
 8001e84:	f001 fe66 	bl	8003b54 <prvTraceStoreKernelCallWithNumericParamOnly>
 8001e88:	6830      	ldr	r0, [r6, #0]
 8001e8a:	f000 fdfd 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001e8e:	b2c0      	uxtb	r0, r0
 8001e90:	f002 f9c2 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001e94:	e7bc      	b.n	8001e10 <vTaskDelay+0x28>
 8001e96:	46c0      	nop			; (mov r8, r8)
 8001e98:	200000ac 	.word	0x200000ac
 8001e9c:	20000034 	.word	0x20000034
 8001ea0:	20001d7e 	.word	0x20001d7e
 8001ea4:	20000130 	.word	0x20000130
 8001ea8:	20000038 	.word	0x20000038
 8001eac:	200000e4 	.word	0x200000e4
 8001eb0:	2000003c 	.word	0x2000003c

08001eb4 <vTaskSwitchContext>:
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001eb4:	4b05      	ldr	r3, [pc, #20]	; (8001ecc <vTaskSwitchContext+0x18>)
{
 8001eb6:	b510      	push	{r4, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001eb8:	681b      	ldr	r3, [r3, #0]
 8001eba:	2b00      	cmp	r3, #0
 8001ebc:	d003      	beq.n	8001ec6 <vTaskSwitchContext+0x12>
        xYieldPending = pdTRUE;
 8001ebe:	2201      	movs	r2, #1
 8001ec0:	4b03      	ldr	r3, [pc, #12]	; (8001ed0 <vTaskSwitchContext+0x1c>)
 8001ec2:	601a      	str	r2, [r3, #0]
}
 8001ec4:	bd10      	pop	{r4, pc}
 8001ec6:	f7ff fb45 	bl	8001554 <vTaskSwitchContext.part.0>
 8001eca:	e7fb      	b.n	8001ec4 <vTaskSwitchContext+0x10>
 8001ecc:	200000ac 	.word	0x200000ac
 8001ed0:	20000134 	.word	0x20000134

08001ed4 <vTaskPlaceOnEventList>:
{
 8001ed4:	b570      	push	{r4, r5, r6, lr}
 8001ed6:	000c      	movs	r4, r1
    configASSERT( pxEventList );
 8001ed8:	2800      	cmp	r0, #0
 8001eda:	d01d      	beq.n	8001f18 <vTaskPlaceOnEventList+0x44>
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8001edc:	4d16      	ldr	r5, [pc, #88]	; (8001f38 <vTaskPlaceOnEventList+0x64>)
 8001ede:	6829      	ldr	r1, [r5, #0]
 8001ee0:	3118      	adds	r1, #24
 8001ee2:	f7fe f9b9 	bl	8000258 <vListInsert>
    const TickType_t xConstTickCount = xTickCount;
 8001ee6:	4b15      	ldr	r3, [pc, #84]	; (8001f3c <vTaskPlaceOnEventList+0x68>)
 8001ee8:	681e      	ldr	r6, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001eea:	6828      	ldr	r0, [r5, #0]
 8001eec:	3004      	adds	r0, #4
 8001eee:	f7fe f9cb 	bl	8000288 <uxListRemove>
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001ef2:	1c63      	adds	r3, r4, #1
 8001ef4:	d012      	beq.n	8001f1c <vTaskPlaceOnEventList+0x48>
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001ef6:	682b      	ldr	r3, [r5, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001ef8:	19a4      	adds	r4, r4, r6
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001efa:	605c      	str	r4, [r3, #4]
                if( xTimeToWake < xConstTickCount )
 8001efc:	42a6      	cmp	r6, r4
 8001efe:	d813      	bhi.n	8001f28 <vTaskPlaceOnEventList+0x54>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001f00:	4b0f      	ldr	r3, [pc, #60]	; (8001f40 <vTaskPlaceOnEventList+0x6c>)
 8001f02:	6818      	ldr	r0, [r3, #0]
 8001f04:	6829      	ldr	r1, [r5, #0]
 8001f06:	3104      	adds	r1, #4
 8001f08:	f7fe f9a6 	bl	8000258 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001f0c:	4b0d      	ldr	r3, [pc, #52]	; (8001f44 <vTaskPlaceOnEventList+0x70>)
 8001f0e:	681a      	ldr	r2, [r3, #0]
 8001f10:	4294      	cmp	r4, r2
 8001f12:	d208      	bcs.n	8001f26 <vTaskPlaceOnEventList+0x52>
                        xNextTaskUnblockTime = xTimeToWake;
 8001f14:	601c      	str	r4, [r3, #0]
}
 8001f16:	e006      	b.n	8001f26 <vTaskPlaceOnEventList+0x52>
    configASSERT( pxEventList );
 8001f18:	b672      	cpsid	i
 8001f1a:	e7fe      	b.n	8001f1a <vTaskPlaceOnEventList+0x46>
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001f1c:	6829      	ldr	r1, [r5, #0]
 8001f1e:	480a      	ldr	r0, [pc, #40]	; (8001f48 <vTaskPlaceOnEventList+0x74>)
 8001f20:	3104      	adds	r1, #4
 8001f22:	f7fe f98d 	bl	8000240 <vListInsertEnd>
}
 8001f26:	bd70      	pop	{r4, r5, r6, pc}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001f28:	4b08      	ldr	r3, [pc, #32]	; (8001f4c <vTaskPlaceOnEventList+0x78>)
 8001f2a:	6818      	ldr	r0, [r3, #0]
 8001f2c:	6829      	ldr	r1, [r5, #0]
 8001f2e:	3104      	adds	r1, #4
 8001f30:	f7fe f992 	bl	8000258 <vListInsert>
 8001f34:	e7f7      	b.n	8001f26 <vTaskPlaceOnEventList+0x52>
 8001f36:	46c0      	nop			; (mov r8, r8)
 8001f38:	20000034 	.word	0x20000034
 8001f3c:	20000130 	.word	0x20000130
 8001f40:	20000038 	.word	0x20000038
 8001f44:	200000e4 	.word	0x200000e4
 8001f48:	20000108 	.word	0x20000108
 8001f4c:	2000003c 	.word	0x2000003c

08001f50 <vTaskPlaceOnEventListRestricted>:
    {
 8001f50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f52:	46c6      	mov	lr, r8
 8001f54:	000c      	movs	r4, r1
 8001f56:	0015      	movs	r5, r2
 8001f58:	b500      	push	{lr}
        configASSERT( pxEventList );
 8001f5a:	2800      	cmp	r0, #0
 8001f5c:	d02e      	beq.n	8001fbc <vTaskPlaceOnEventListRestricted+0x6c>
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8001f5e:	4e34      	ldr	r6, [pc, #208]	; (8002030 <vTaskPlaceOnEventListRestricted+0xe0>)
 8001f60:	6831      	ldr	r1, [r6, #0]
 8001f62:	3118      	adds	r1, #24
 8001f64:	f7fe f96c 	bl	8000240 <vListInsertEnd>
        if( xWaitIndefinitely != pdFALSE )
 8001f68:	2d00      	cmp	r5, #0
 8001f6a:	d001      	beq.n	8001f70 <vTaskPlaceOnEventListRestricted+0x20>
            xTicksToWait = portMAX_DELAY;
 8001f6c:	2401      	movs	r4, #1
 8001f6e:	4264      	negs	r4, r4
        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
 8001f70:	6830      	ldr	r0, [r6, #0]
 8001f72:	f000 fd8f 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001f76:	4f2f      	ldr	r7, [pc, #188]	; (8002034 <vTaskPlaceOnEventListRestricted+0xe4>)
 8001f78:	883b      	ldrh	r3, [r7, #0]
 8001f7a:	4203      	tst	r3, r0
 8001f7c:	d12c      	bne.n	8001fd8 <vTaskPlaceOnEventListRestricted+0x88>
 8001f7e:	4b2e      	ldr	r3, [pc, #184]	; (8002038 <vTaskPlaceOnEventListRestricted+0xe8>)
 8001f80:	4698      	mov	r8, r3
 8001f82:	f000 fdcd 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001f86:	f000 fd85 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001f8a:	883b      	ldrh	r3, [r7, #0]
 8001f8c:	4203      	tst	r3, r0
 8001f8e:	d137      	bne.n	8002000 <vTaskPlaceOnEventListRestricted+0xb0>
    const TickType_t xConstTickCount = xTickCount;
 8001f90:	4643      	mov	r3, r8
 8001f92:	681f      	ldr	r7, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001f94:	6830      	ldr	r0, [r6, #0]
 8001f96:	3004      	adds	r0, #4
 8001f98:	f7fe f976 	bl	8000288 <uxListRemove>
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001f9c:	1c63      	adds	r3, r4, #1
 8001f9e:	d03e      	beq.n	800201e <vTaskPlaceOnEventListRestricted+0xce>
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001fa0:	6833      	ldr	r3, [r6, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001fa2:	19e4      	adds	r4, r4, r7
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001fa4:	605c      	str	r4, [r3, #4]
                if( xTimeToWake < xConstTickCount )
 8001fa6:	42a7      	cmp	r7, r4
 8001fa8:	d90a      	bls.n	8001fc0 <vTaskPlaceOnEventListRestricted+0x70>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001faa:	4b24      	ldr	r3, [pc, #144]	; (800203c <vTaskPlaceOnEventListRestricted+0xec>)
 8001fac:	6818      	ldr	r0, [r3, #0]
 8001fae:	6831      	ldr	r1, [r6, #0]
 8001fb0:	3104      	adds	r1, #4
 8001fb2:	f7fe f951 	bl	8000258 <vListInsert>
    }
 8001fb6:	bc80      	pop	{r7}
 8001fb8:	46b8      	mov	r8, r7
 8001fba:	bdf0      	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxEventList );
 8001fbc:	b672      	cpsid	i
 8001fbe:	e7fe      	b.n	8001fbe <vTaskPlaceOnEventListRestricted+0x6e>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001fc0:	4b1f      	ldr	r3, [pc, #124]	; (8002040 <vTaskPlaceOnEventListRestricted+0xf0>)
 8001fc2:	6818      	ldr	r0, [r3, #0]
 8001fc4:	6831      	ldr	r1, [r6, #0]
 8001fc6:	3104      	adds	r1, #4
 8001fc8:	f7fe f946 	bl	8000258 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001fcc:	4b1d      	ldr	r3, [pc, #116]	; (8002044 <vTaskPlaceOnEventListRestricted+0xf4>)
 8001fce:	681a      	ldr	r2, [r3, #0]
 8001fd0:	4294      	cmp	r4, r2
 8001fd2:	d2f0      	bcs.n	8001fb6 <vTaskPlaceOnEventListRestricted+0x66>
                        xNextTaskUnblockTime = xTimeToWake;
 8001fd4:	601c      	str	r4, [r3, #0]
    }
 8001fd6:	e7ee      	b.n	8001fb6 <vTaskPlaceOnEventListRestricted+0x66>
        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
 8001fd8:	4b17      	ldr	r3, [pc, #92]	; (8002038 <vTaskPlaceOnEventListRestricted+0xe8>)
 8001fda:	2088      	movs	r0, #136	; 0x88
 8001fdc:	6819      	ldr	r1, [r3, #0]
 8001fde:	4698      	mov	r8, r3
 8001fe0:	1909      	adds	r1, r1, r4
 8001fe2:	f001 fdb7 	bl	8003b54 <prvTraceStoreKernelCallWithNumericParamOnly>
 8001fe6:	6830      	ldr	r0, [r6, #0]
 8001fe8:	f000 fd4e 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8001fec:	b2c0      	uxtb	r0, r0
 8001fee:	f002 f913 	bl	8004218 <prvTraceSetTaskInstanceFinished>
 8001ff2:	f000 fd95 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8001ff6:	f000 fd4d 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8001ffa:	883b      	ldrh	r3, [r7, #0]
 8001ffc:	4203      	tst	r3, r0
 8001ffe:	d0c7      	beq.n	8001f90 <vTaskPlaceOnEventListRestricted+0x40>
 8002000:	f000 fd8e 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8002004:	f000 fd40 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002008:	b2c0      	uxtb	r0, r0
 800200a:	f002 f905 	bl	8004218 <prvTraceSetTaskInstanceFinished>
    const TickType_t xConstTickCount = xTickCount;
 800200e:	4643      	mov	r3, r8
 8002010:	681f      	ldr	r7, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002012:	6830      	ldr	r0, [r6, #0]
 8002014:	3004      	adds	r0, #4
 8002016:	f7fe f937 	bl	8000288 <uxListRemove>
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800201a:	1c63      	adds	r3, r4, #1
 800201c:	d1c0      	bne.n	8001fa0 <vTaskPlaceOnEventListRestricted+0x50>
 800201e:	2d00      	cmp	r5, #0
 8002020:	d0be      	beq.n	8001fa0 <vTaskPlaceOnEventListRestricted+0x50>
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002022:	6831      	ldr	r1, [r6, #0]
 8002024:	4808      	ldr	r0, [pc, #32]	; (8002048 <vTaskPlaceOnEventListRestricted+0xf8>)
 8002026:	3104      	adds	r1, #4
 8002028:	f7fe f90a 	bl	8000240 <vListInsertEnd>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 800202c:	e7c3      	b.n	8001fb6 <vTaskPlaceOnEventListRestricted+0x66>
 800202e:	46c0      	nop			; (mov r8, r8)
 8002030:	20000034 	.word	0x20000034
 8002034:	20001d7e 	.word	0x20001d7e
 8002038:	20000130 	.word	0x20000130
 800203c:	2000003c 	.word	0x2000003c
 8002040:	20000038 	.word	0x20000038
 8002044:	200000e4 	.word	0x200000e4
 8002048:	20000108 	.word	0x20000108

0800204c <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800204c:	68c3      	ldr	r3, [r0, #12]
{
 800204e:	b570      	push	{r4, r5, r6, lr}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002050:	68dc      	ldr	r4, [r3, #12]
    configASSERT( pxUnblockedTCB );
 8002052:	2c00      	cmp	r4, #0
 8002054:	d032      	beq.n	80020bc <xTaskRemoveFromEventList+0x70>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8002056:	0025      	movs	r5, r4
 8002058:	3518      	adds	r5, #24
 800205a:	0028      	movs	r0, r5
 800205c:	f7fe f914 	bl	8000288 <uxListRemove>
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002060:	4b1b      	ldr	r3, [pc, #108]	; (80020d0 <xTaskRemoveFromEventList+0x84>)
 8002062:	681b      	ldr	r3, [r3, #0]
 8002064:	2b00      	cmp	r3, #0
 8002066:	d00f      	beq.n	8002088 <xTaskRemoveFromEventList+0x3c>
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002068:	0029      	movs	r1, r5
 800206a:	481a      	ldr	r0, [pc, #104]	; (80020d4 <xTaskRemoveFromEventList+0x88>)
 800206c:	f7fe f8e8 	bl	8000240 <vListInsertEnd>
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8002070:	4b19      	ldr	r3, [pc, #100]	; (80020d8 <xTaskRemoveFromEventList+0x8c>)
 8002072:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002074:	681b      	ldr	r3, [r3, #0]
        xReturn = pdFALSE;
 8002076:	2000      	movs	r0, #0
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8002078:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800207a:	429a      	cmp	r2, r3
 800207c:	d903      	bls.n	8002086 <xTaskRemoveFromEventList+0x3a>
        xYieldPending = pdTRUE;
 800207e:	2201      	movs	r2, #1
 8002080:	4b16      	ldr	r3, [pc, #88]	; (80020dc <xTaskRemoveFromEventList+0x90>)
        xReturn = pdTRUE;
 8002082:	3001      	adds	r0, #1
        xYieldPending = pdTRUE;
 8002084:	601a      	str	r2, [r3, #0]
}
 8002086:	bd70      	pop	{r4, r5, r6, pc}
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8002088:	1d25      	adds	r5, r4, #4
 800208a:	0028      	movs	r0, r5
 800208c:	f7fe f8fc 	bl	8000288 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
 8002090:	0020      	movs	r0, r4
 8002092:	f000 fcff 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8002096:	4b12      	ldr	r3, [pc, #72]	; (80020e0 <xTaskRemoveFromEventList+0x94>)
 8002098:	881b      	ldrh	r3, [r3, #0]
 800209a:	4203      	tst	r3, r0
 800209c:	d110      	bne.n	80020c0 <xTaskRemoveFromEventList+0x74>
 800209e:	4b11      	ldr	r3, [pc, #68]	; (80020e4 <xTaskRemoveFromEventList+0x98>)
 80020a0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80020a2:	681a      	ldr	r2, [r3, #0]
 80020a4:	4291      	cmp	r1, r2
 80020a6:	d900      	bls.n	80020aa <xTaskRemoveFromEventList+0x5e>
 80020a8:	6019      	str	r1, [r3, #0]
 80020aa:	008a      	lsls	r2, r1, #2
 80020ac:	1852      	adds	r2, r2, r1
 80020ae:	4b0e      	ldr	r3, [pc, #56]	; (80020e8 <xTaskRemoveFromEventList+0x9c>)
 80020b0:	0090      	lsls	r0, r2, #2
 80020b2:	0029      	movs	r1, r5
 80020b4:	1818      	adds	r0, r3, r0
 80020b6:	f7fe f8c3 	bl	8000240 <vListInsertEnd>
 80020ba:	e7d9      	b.n	8002070 <xTaskRemoveFromEventList+0x24>
    configASSERT( pxUnblockedTCB );
 80020bc:	b672      	cpsid	i
 80020be:	e7fe      	b.n	80020be <xTaskRemoveFromEventList+0x72>
        prvAddTaskToReadyList( pxUnblockedTCB );
 80020c0:	0020      	movs	r0, r4
 80020c2:	f000 fce1 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 80020c6:	b2c0      	uxtb	r0, r0
 80020c8:	f000 ffe8 	bl	800309c <prvTraceStoreTaskReady>
 80020cc:	e7e7      	b.n	800209e <xTaskRemoveFromEventList+0x52>
 80020ce:	46c0      	nop			; (mov r8, r8)
 80020d0:	200000ac 	.word	0x200000ac
 80020d4:	200000f0 	.word	0x200000f0
 80020d8:	20000034 	.word	0x20000034
 80020dc:	20000134 	.word	0x20000134
 80020e0:	20001d7e 	.word	0x20001d7e
 80020e4:	200000b4 	.word	0x200000b4
 80020e8:	20000040 	.word	0x20000040

080020ec <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 80020ec:	4b03      	ldr	r3, [pc, #12]	; (80020fc <vTaskInternalSetTimeOutState+0x10>)
 80020ee:	681b      	ldr	r3, [r3, #0]
 80020f0:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 80020f2:	4b03      	ldr	r3, [pc, #12]	; (8002100 <vTaskInternalSetTimeOutState+0x14>)
 80020f4:	681b      	ldr	r3, [r3, #0]
 80020f6:	6043      	str	r3, [r0, #4]
}
 80020f8:	4770      	bx	lr
 80020fa:	46c0      	nop			; (mov r8, r8)
 80020fc:	200000e8 	.word	0x200000e8
 8002100:	20000130 	.word	0x20000130

08002104 <xTaskCheckForTimeOut>:
{
 8002104:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002106:	46c6      	mov	lr, r8
 8002108:	0004      	movs	r4, r0
 800210a:	000d      	movs	r5, r1
 800210c:	b500      	push	{lr}
    configASSERT( pxTimeOut );
 800210e:	2800      	cmp	r0, #0
 8002110:	d01c      	beq.n	800214c <xTaskCheckForTimeOut+0x48>
    configASSERT( pxTicksToWait );
 8002112:	2900      	cmp	r1, #0
 8002114:	d018      	beq.n	8002148 <xTaskCheckForTimeOut+0x44>
    taskENTER_CRITICAL();
 8002116:	f000 fbcb 	bl	80028b0 <vPortEnterCritical>
        const TickType_t xConstTickCount = xTickCount;
 800211a:	4a14      	ldr	r2, [pc, #80]	; (800216c <xTaskCheckForTimeOut+0x68>)
            if( *pxTicksToWait == portMAX_DELAY )
 800211c:	682b      	ldr	r3, [r5, #0]
        const TickType_t xConstTickCount = xTickCount;
 800211e:	6811      	ldr	r1, [r2, #0]
            if( *pxTicksToWait == portMAX_DELAY )
 8002120:	1c58      	adds	r0, r3, #1
 8002122:	d021      	beq.n	8002168 <xTaskCheckForTimeOut+0x64>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8002124:	4e12      	ldr	r6, [pc, #72]	; (8002170 <xTaskCheckForTimeOut+0x6c>)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8002126:	6860      	ldr	r0, [r4, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8002128:	6837      	ldr	r7, [r6, #0]
 800212a:	46b8      	mov	r8, r7
 800212c:	6827      	ldr	r7, [r4, #0]
 800212e:	4547      	cmp	r7, r8
 8002130:	d00e      	beq.n	8002150 <xTaskCheckForTimeOut+0x4c>
 8002132:	4288      	cmp	r0, r1
 8002134:	d80c      	bhi.n	8002150 <xTaskCheckForTimeOut+0x4c>
            *pxTicksToWait = ( TickType_t ) 0;
 8002136:	2300      	movs	r3, #0
            xReturn = pdTRUE;
 8002138:	2401      	movs	r4, #1
            *pxTicksToWait = ( TickType_t ) 0;
 800213a:	602b      	str	r3, [r5, #0]
    taskEXIT_CRITICAL();
 800213c:	f000 fbc4 	bl	80028c8 <vPortExitCritical>
}
 8002140:	0020      	movs	r0, r4
 8002142:	bc80      	pop	{r7}
 8002144:	46b8      	mov	r8, r7
 8002146:	bdf0      	pop	{r4, r5, r6, r7, pc}
    configASSERT( pxTicksToWait );
 8002148:	b672      	cpsid	i
 800214a:	e7fe      	b.n	800214a <xTaskCheckForTimeOut+0x46>
    configASSERT( pxTimeOut );
 800214c:	b672      	cpsid	i
 800214e:	e7fe      	b.n	800214e <xTaskCheckForTimeOut+0x4a>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8002150:	1a0f      	subs	r7, r1, r0
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8002152:	42bb      	cmp	r3, r7
 8002154:	d9ef      	bls.n	8002136 <xTaskCheckForTimeOut+0x32>
            *pxTicksToWait -= xElapsedTime;
 8002156:	1a5b      	subs	r3, r3, r1
 8002158:	181b      	adds	r3, r3, r0
 800215a:	602b      	str	r3, [r5, #0]
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 800215c:	6833      	ldr	r3, [r6, #0]
 800215e:	6023      	str	r3, [r4, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 8002160:	6813      	ldr	r3, [r2, #0]
 8002162:	6063      	str	r3, [r4, #4]
            xReturn = pdFALSE;
 8002164:	2400      	movs	r4, #0
 8002166:	e7e9      	b.n	800213c <xTaskCheckForTimeOut+0x38>
                xReturn = pdFALSE;
 8002168:	2400      	movs	r4, #0
 800216a:	e7e7      	b.n	800213c <xTaskCheckForTimeOut+0x38>
 800216c:	20000130 	.word	0x20000130
 8002170:	200000e8 	.word	0x200000e8

08002174 <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 8002174:	2201      	movs	r2, #1
 8002176:	4b01      	ldr	r3, [pc, #4]	; (800217c <vTaskMissedYield+0x8>)
 8002178:	601a      	str	r2, [r3, #0]
}
 800217a:	4770      	bx	lr
 800217c:	20000134 	.word	0x20000134

08002180 <uxTaskGetTaskNumber>:
        if( xTask != NULL )
 8002180:	2800      	cmp	r0, #0
 8002182:	d001      	beq.n	8002188 <uxTaskGetTaskNumber+0x8>
            uxReturn = pxTCB->uxTaskNumber;
 8002184:	6c40      	ldr	r0, [r0, #68]	; 0x44
    }
 8002186:	4770      	bx	lr
            uxReturn = 0U;
 8002188:	2000      	movs	r0, #0
        return uxReturn;
 800218a:	e7fc      	b.n	8002186 <uxTaskGetTaskNumber+0x6>

0800218c <vTaskSetTaskNumber>:
        if( xTask != NULL )
 800218c:	2800      	cmp	r0, #0
 800218e:	d000      	beq.n	8002192 <vTaskSetTaskNumber+0x6>
            pxTCB->uxTaskNumber = uxHandle;
 8002190:	6441      	str	r1, [r0, #68]	; 0x44
    }
 8002192:	4770      	bx	lr

08002194 <xTaskGetCurrentTaskHandle>:
        xReturn = pxCurrentTCB;
 8002194:	4b01      	ldr	r3, [pc, #4]	; (800219c <xTaskGetCurrentTaskHandle+0x8>)
 8002196:	6818      	ldr	r0, [r3, #0]
    }
 8002198:	4770      	bx	lr
 800219a:	46c0      	nop			; (mov r8, r8)
 800219c:	20000034 	.word	0x20000034

080021a0 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 80021a0:	4b05      	ldr	r3, [pc, #20]	; (80021b8 <xTaskGetSchedulerState+0x18>)
            xReturn = taskSCHEDULER_NOT_STARTED;
 80021a2:	2001      	movs	r0, #1
        if( xSchedulerRunning == pdFALSE )
 80021a4:	681b      	ldr	r3, [r3, #0]
 80021a6:	2b00      	cmp	r3, #0
 80021a8:	d004      	beq.n	80021b4 <xTaskGetSchedulerState+0x14>
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80021aa:	4b04      	ldr	r3, [pc, #16]	; (80021bc <xTaskGetSchedulerState+0x1c>)
 80021ac:	6818      	ldr	r0, [r3, #0]
 80021ae:	4243      	negs	r3, r0
 80021b0:	4158      	adcs	r0, r3
 80021b2:	0040      	lsls	r0, r0, #1
    }
 80021b4:	4770      	bx	lr
 80021b6:	46c0      	nop			; (mov r8, r8)
 80021b8:	20000104 	.word	0x20000104
 80021bc:	200000ac 	.word	0x200000ac

080021c0 <xTaskPriorityInherit>:
    {
 80021c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80021c2:	46c6      	mov	lr, r8
 80021c4:	0004      	movs	r4, r0
 80021c6:	b500      	push	{lr}
        if( pxMutexHolder != NULL )
 80021c8:	2800      	cmp	r0, #0
 80021ca:	d046      	beq.n	800225a <xTaskPriorityInherit+0x9a>
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80021cc:	4e36      	ldr	r6, [pc, #216]	; (80022a8 <xTaskPriorityInherit+0xe8>)
 80021ce:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80021d0:	6833      	ldr	r3, [r6, #0]
 80021d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80021d4:	429a      	cmp	r2, r3
 80021d6:	d236      	bcs.n	8002246 <xTaskPriorityInherit+0x86>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80021d8:	6983      	ldr	r3, [r0, #24]
 80021da:	2b00      	cmp	r3, #0
 80021dc:	db04      	blt.n	80021e8 <xTaskPriorityInherit+0x28>
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80021de:	6833      	ldr	r3, [r6, #0]
 80021e0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80021e2:	2305      	movs	r3, #5
 80021e4:	1a5b      	subs	r3, r3, r1
 80021e6:	6183      	str	r3, [r0, #24]
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80021e8:	0093      	lsls	r3, r2, #2
 80021ea:	189b      	adds	r3, r3, r2
 80021ec:	4d2f      	ldr	r5, [pc, #188]	; (80022ac <xTaskPriorityInherit+0xec>)
 80021ee:	009b      	lsls	r3, r3, #2
 80021f0:	6962      	ldr	r2, [r4, #20]
 80021f2:	18eb      	adds	r3, r5, r3
 80021f4:	429a      	cmp	r2, r3
 80021f6:	d032      	beq.n	800225e <xTaskPriorityInherit+0x9e>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80021f8:	6833      	ldr	r3, [r6, #0]
 80021fa:	4f2d      	ldr	r7, [pc, #180]	; (80022b0 <xTaskPriorityInherit+0xf0>)
 80021fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80021fe:	62e3      	str	r3, [r4, #44]	; 0x2c
                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
 8002200:	0020      	movs	r0, r4
 8002202:	f000 fc47 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8002206:	883b      	ldrh	r3, [r7, #0]
                xReturn = pdTRUE;
 8002208:	2501      	movs	r5, #1
                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
 800220a:	4203      	tst	r3, r0
 800220c:	d021      	beq.n	8002252 <xTaskPriorityInherit+0x92>
 800220e:	0020      	movs	r0, r4
 8002210:	f000 fc3a 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002214:	0007      	movs	r7, r0
 8002216:	0020      	movs	r0, r4
 8002218:	f000 fc36 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800221c:	b2c1      	uxtb	r1, r0
 800221e:	2003      	movs	r0, #3
 8002220:	f001 fe9a 	bl	8003f58 <prvTraceGetPriorityProperty>
 8002224:	b2fa      	uxtb	r2, r7
 8002226:	0003      	movs	r3, r0
 8002228:	2103      	movs	r1, #3
 800222a:	208e      	movs	r0, #142	; 0x8e
 800222c:	f001 faf8 	bl	8003820 <prvTraceStoreKernelCallWithParam>
 8002230:	0020      	movs	r0, r4
 8002232:	f000 fc29 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002236:	6833      	ldr	r3, [r6, #0]
 8002238:	b2c1      	uxtb	r1, r0
 800223a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800223c:	2003      	movs	r0, #3
 800223e:	b2d2      	uxtb	r2, r2
 8002240:	f001 fdda 	bl	8003df8 <prvTraceSetPriorityProperty>
 8002244:	e005      	b.n	8002252 <xTaskPriorityInherit+0x92>
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8002246:	6833      	ldr	r3, [r6, #0]
 8002248:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800224a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800224c:	429d      	cmp	r5, r3
 800224e:	41ad      	sbcs	r5, r5
 8002250:	426d      	negs	r5, r5
    }
 8002252:	0028      	movs	r0, r5
 8002254:	bc80      	pop	{r7}
 8002256:	46b8      	mov	r8, r7
 8002258:	bdf0      	pop	{r4, r5, r6, r7, pc}
        BaseType_t xReturn = pdFALSE;
 800225a:	2500      	movs	r5, #0
 800225c:	e7f9      	b.n	8002252 <xTaskPriorityInherit+0x92>
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800225e:	1d23      	adds	r3, r4, #4
 8002260:	0018      	movs	r0, r3
 8002262:	4698      	mov	r8, r3
 8002264:	f7fe f810 	bl	8000288 <uxListRemove>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8002268:	6833      	ldr	r3, [r6, #0]
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 800226a:	0020      	movs	r0, r4
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800226c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800226e:	62e3      	str	r3, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8002270:	f000 fc10 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 8002274:	4f0e      	ldr	r7, [pc, #56]	; (80022b0 <xTaskPriorityInherit+0xf0>)
 8002276:	883b      	ldrh	r3, [r7, #0]
 8002278:	4203      	tst	r3, r0
 800227a:	d10d      	bne.n	8002298 <xTaskPriorityInherit+0xd8>
 800227c:	4b0d      	ldr	r3, [pc, #52]	; (80022b4 <xTaskPriorityInherit+0xf4>)
 800227e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002280:	6819      	ldr	r1, [r3, #0]
 8002282:	428a      	cmp	r2, r1
 8002284:	d900      	bls.n	8002288 <xTaskPriorityInherit+0xc8>
 8002286:	601a      	str	r2, [r3, #0]
 8002288:	0093      	lsls	r3, r2, #2
 800228a:	189b      	adds	r3, r3, r2
 800228c:	0098      	lsls	r0, r3, #2
 800228e:	4641      	mov	r1, r8
 8002290:	1828      	adds	r0, r5, r0
 8002292:	f7fd ffd5 	bl	8000240 <vListInsertEnd>
 8002296:	e7b3      	b.n	8002200 <xTaskPriorityInherit+0x40>
 8002298:	0020      	movs	r0, r4
 800229a:	f000 fbf5 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800229e:	b2c0      	uxtb	r0, r0
 80022a0:	f000 fefc 	bl	800309c <prvTraceStoreTaskReady>
 80022a4:	e7ea      	b.n	800227c <xTaskPriorityInherit+0xbc>
 80022a6:	46c0      	nop			; (mov r8, r8)
 80022a8:	20000034 	.word	0x20000034
 80022ac:	20000040 	.word	0x20000040
 80022b0:	20001d7e 	.word	0x20001d7e
 80022b4:	200000b4 	.word	0x200000b4

080022b8 <xTaskPriorityDisinherit>:
    {
 80022b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80022ba:	1e04      	subs	r4, r0, #0
        if( pxMutexHolder != NULL )
 80022bc:	d010      	beq.n	80022e0 <xTaskPriorityDisinherit+0x28>
            configASSERT( pxTCB == pxCurrentTCB );
 80022be:	4b2e      	ldr	r3, [pc, #184]	; (8002378 <xTaskPriorityDisinherit+0xc0>)
 80022c0:	681b      	ldr	r3, [r3, #0]
 80022c2:	4283      	cmp	r3, r0
 80022c4:	d001      	beq.n	80022ca <xTaskPriorityDisinherit+0x12>
 80022c6:	b672      	cpsid	i
 80022c8:	e7fe      	b.n	80022c8 <xTaskPriorityDisinherit+0x10>
            configASSERT( pxTCB->uxMutexesHeld );
 80022ca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80022cc:	2b00      	cmp	r3, #0
 80022ce:	d009      	beq.n	80022e4 <xTaskPriorityDisinherit+0x2c>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80022d0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80022d2:	6c82      	ldr	r2, [r0, #72]	; 0x48
            ( pxTCB->uxMutexesHeld )--;
 80022d4:	3b01      	subs	r3, #1
 80022d6:	64c3      	str	r3, [r0, #76]	; 0x4c
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80022d8:	4291      	cmp	r1, r2
 80022da:	d001      	beq.n	80022e0 <xTaskPriorityDisinherit+0x28>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80022dc:	2b00      	cmp	r3, #0
 80022de:	d003      	beq.n	80022e8 <xTaskPriorityDisinherit+0x30>
        BaseType_t xReturn = pdFALSE;
 80022e0:	2000      	movs	r0, #0
    }
 80022e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            configASSERT( pxTCB->uxMutexesHeld );
 80022e4:	b672      	cpsid	i
 80022e6:	e7fe      	b.n	80022e6 <xTaskPriorityDisinherit+0x2e>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80022e8:	1d05      	adds	r5, r0, #4
 80022ea:	0028      	movs	r0, r5
 80022ec:	f7fd ffcc 	bl	8000288 <uxListRemove>
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 80022f0:	0020      	movs	r0, r4
 80022f2:	f000 fbcf 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80022f6:	4f21      	ldr	r7, [pc, #132]	; (800237c <xTaskPriorityDisinherit+0xc4>)
 80022f8:	883b      	ldrh	r3, [r7, #0]
 80022fa:	4203      	tst	r3, r0
 80022fc:	d121      	bne.n	8002342 <xTaskPriorityDisinherit+0x8a>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80022fe:	2305      	movs	r3, #5
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002300:	6ca2      	ldr	r2, [r4, #72]	; 0x48
                    prvAddTaskToReadyList( pxTCB );
 8002302:	0020      	movs	r0, r4
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002304:	1a9b      	subs	r3, r3, r2
 8002306:	61a3      	str	r3, [r4, #24]
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002308:	62e2      	str	r2, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxTCB );
 800230a:	f000 fbc3 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 800230e:	883b      	ldrh	r3, [r7, #0]
 8002310:	4203      	tst	r3, r0
 8002312:	d10f      	bne.n	8002334 <xTaskPriorityDisinherit+0x7c>
 8002314:	4b1a      	ldr	r3, [pc, #104]	; (8002380 <xTaskPriorityDisinherit+0xc8>)
 8002316:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8002318:	681a      	ldr	r2, [r3, #0]
 800231a:	4291      	cmp	r1, r2
 800231c:	d900      	bls.n	8002320 <xTaskPriorityDisinherit+0x68>
 800231e:	6019      	str	r1, [r3, #0]
 8002320:	008a      	lsls	r2, r1, #2
 8002322:	4b18      	ldr	r3, [pc, #96]	; (8002384 <xTaskPriorityDisinherit+0xcc>)
 8002324:	1852      	adds	r2, r2, r1
 8002326:	0092      	lsls	r2, r2, #2
 8002328:	1898      	adds	r0, r3, r2
 800232a:	0029      	movs	r1, r5
 800232c:	f7fd ff88 	bl	8000240 <vListInsertEnd>
                    xReturn = pdTRUE;
 8002330:	2001      	movs	r0, #1
        return xReturn;
 8002332:	e7d6      	b.n	80022e2 <xTaskPriorityDisinherit+0x2a>
                    prvAddTaskToReadyList( pxTCB );
 8002334:	0020      	movs	r0, r4
 8002336:	f000 fba7 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800233a:	b2c0      	uxtb	r0, r0
 800233c:	f000 feae 	bl	800309c <prvTraceStoreTaskReady>
 8002340:	e7e8      	b.n	8002314 <xTaskPriorityDisinherit+0x5c>
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 8002342:	0020      	movs	r0, r4
 8002344:	f000 fba0 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002348:	0006      	movs	r6, r0
 800234a:	0020      	movs	r0, r4
 800234c:	f000 fb9c 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002350:	b2c1      	uxtb	r1, r0
 8002352:	2003      	movs	r0, #3
 8002354:	f001 fe00 	bl	8003f58 <prvTraceGetPriorityProperty>
 8002358:	b2f2      	uxtb	r2, r6
 800235a:	0003      	movs	r3, r0
 800235c:	2103      	movs	r1, #3
 800235e:	208f      	movs	r0, #143	; 0x8f
 8002360:	f001 fa5e 	bl	8003820 <prvTraceStoreKernelCallWithParam>
 8002364:	0020      	movs	r0, r4
 8002366:	f000 fb8f 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800236a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800236c:	b2c1      	uxtb	r1, r0
 800236e:	b2d2      	uxtb	r2, r2
 8002370:	2003      	movs	r0, #3
 8002372:	f001 fd41 	bl	8003df8 <prvTraceSetPriorityProperty>
 8002376:	e7c2      	b.n	80022fe <xTaskPriorityDisinherit+0x46>
 8002378:	20000034 	.word	0x20000034
 800237c:	20001d7e 	.word	0x20001d7e
 8002380:	200000b4 	.word	0x200000b4
 8002384:	20000040 	.word	0x20000040

08002388 <vTaskPriorityDisinheritAfterTimeout>:
    {
 8002388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800238a:	1e04      	subs	r4, r0, #0
        if( pxMutexHolder != NULL )
 800238c:	d00d      	beq.n	80023aa <vTaskPriorityDisinheritAfterTimeout+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
 800238e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8002390:	2b00      	cmp	r3, #0
 8002392:	d101      	bne.n	8002398 <vTaskPriorityDisinheritAfterTimeout+0x10>
 8002394:	b672      	cpsid	i
 8002396:	e7fe      	b.n	8002396 <vTaskPriorityDisinheritAfterTimeout+0xe>
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8002398:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800239a:	428d      	cmp	r5, r1
 800239c:	d200      	bcs.n	80023a0 <vTaskPriorityDisinheritAfterTimeout+0x18>
 800239e:	000d      	movs	r5, r1
            if( pxTCB->uxPriority != uxPriorityToUse )
 80023a0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80023a2:	42aa      	cmp	r2, r5
 80023a4:	d001      	beq.n	80023aa <vTaskPriorityDisinheritAfterTimeout+0x22>
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80023a6:	2b01      	cmp	r3, #1
 80023a8:	d000      	beq.n	80023ac <vTaskPriorityDisinheritAfterTimeout+0x24>
    }
 80023aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    configASSERT( pxTCB != pxCurrentTCB );
 80023ac:	4b2a      	ldr	r3, [pc, #168]	; (8002458 <vTaskPriorityDisinheritAfterTimeout+0xd0>)
 80023ae:	681b      	ldr	r3, [r3, #0]
 80023b0:	42a3      	cmp	r3, r4
 80023b2:	d02e      	beq.n	8002412 <vTaskPriorityDisinheritAfterTimeout+0x8a>
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
 80023b4:	0020      	movs	r0, r4
 80023b6:	f000 fb6d 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80023ba:	4e28      	ldr	r6, [pc, #160]	; (800245c <vTaskPriorityDisinheritAfterTimeout+0xd4>)
 80023bc:	8833      	ldrh	r3, [r6, #0]
 80023be:	4203      	tst	r3, r0
 80023c0:	d129      	bne.n	8002416 <vTaskPriorityDisinheritAfterTimeout+0x8e>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80023c2:	69a3      	ldr	r3, [r4, #24]
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 80023c4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                    pxTCB->uxPriority = uxPriorityToUse;
 80023c6:	62e5      	str	r5, [r4, #44]	; 0x2c
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80023c8:	2b00      	cmp	r3, #0
 80023ca:	db02      	blt.n	80023d2 <vTaskPriorityDisinheritAfterTimeout+0x4a>
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80023cc:	2305      	movs	r3, #5
 80023ce:	1b5b      	subs	r3, r3, r5
 80023d0:	61a3      	str	r3, [r4, #24]
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80023d2:	0093      	lsls	r3, r2, #2
 80023d4:	189b      	adds	r3, r3, r2
 80023d6:	4d22      	ldr	r5, [pc, #136]	; (8002460 <vTaskPriorityDisinheritAfterTimeout+0xd8>)
 80023d8:	009b      	lsls	r3, r3, #2
 80023da:	6962      	ldr	r2, [r4, #20]
 80023dc:	18eb      	adds	r3, r5, r3
 80023de:	429a      	cmp	r2, r3
 80023e0:	d1e3      	bne.n	80023aa <vTaskPriorityDisinheritAfterTimeout+0x22>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80023e2:	1d27      	adds	r7, r4, #4
 80023e4:	0038      	movs	r0, r7
 80023e6:	f7fd ff4f 	bl	8000288 <uxListRemove>
                        prvAddTaskToReadyList( pxTCB );
 80023ea:	0020      	movs	r0, r4
 80023ec:	f000 fb52 	bl	8002a94 <prvTraceGetTaskNumberHigh16>
 80023f0:	8833      	ldrh	r3, [r6, #0]
 80023f2:	4203      	tst	r3, r0
 80023f4:	d129      	bne.n	800244a <vTaskPriorityDisinheritAfterTimeout+0xc2>
 80023f6:	4b1b      	ldr	r3, [pc, #108]	; (8002464 <vTaskPriorityDisinheritAfterTimeout+0xdc>)
 80023f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80023fa:	6819      	ldr	r1, [r3, #0]
 80023fc:	428a      	cmp	r2, r1
 80023fe:	d900      	bls.n	8002402 <vTaskPriorityDisinheritAfterTimeout+0x7a>
 8002400:	601a      	str	r2, [r3, #0]
 8002402:	0093      	lsls	r3, r2, #2
 8002404:	189b      	adds	r3, r3, r2
 8002406:	009b      	lsls	r3, r3, #2
 8002408:	0039      	movs	r1, r7
 800240a:	18e8      	adds	r0, r5, r3
 800240c:	f7fd ff18 	bl	8000240 <vListInsertEnd>
    }
 8002410:	e7cb      	b.n	80023aa <vTaskPriorityDisinheritAfterTimeout+0x22>
                    configASSERT( pxTCB != pxCurrentTCB );
 8002412:	b672      	cpsid	i
 8002414:	e7fe      	b.n	8002414 <vTaskPriorityDisinheritAfterTimeout+0x8c>
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
 8002416:	0020      	movs	r0, r4
 8002418:	f000 fb36 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800241c:	0007      	movs	r7, r0
 800241e:	0020      	movs	r0, r4
 8002420:	f000 fb32 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002424:	b2c1      	uxtb	r1, r0
 8002426:	2003      	movs	r0, #3
 8002428:	f001 fd96 	bl	8003f58 <prvTraceGetPriorityProperty>
 800242c:	b2fa      	uxtb	r2, r7
 800242e:	0003      	movs	r3, r0
 8002430:	2103      	movs	r1, #3
 8002432:	208f      	movs	r0, #143	; 0x8f
 8002434:	f001 f9f4 	bl	8003820 <prvTraceStoreKernelCallWithParam>
 8002438:	0020      	movs	r0, r4
 800243a:	f000 fb25 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 800243e:	b2ea      	uxtb	r2, r5
 8002440:	b2c1      	uxtb	r1, r0
 8002442:	2003      	movs	r0, #3
 8002444:	f001 fcd8 	bl	8003df8 <prvTraceSetPriorityProperty>
 8002448:	e7bb      	b.n	80023c2 <vTaskPriorityDisinheritAfterTimeout+0x3a>
                        prvAddTaskToReadyList( pxTCB );
 800244a:	0020      	movs	r0, r4
 800244c:	f000 fb1c 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8002450:	b2c0      	uxtb	r0, r0
 8002452:	f000 fe23 	bl	800309c <prvTraceStoreTaskReady>
 8002456:	e7ce      	b.n	80023f6 <vTaskPriorityDisinheritAfterTimeout+0x6e>
 8002458:	20000034 	.word	0x20000034
 800245c:	20001d7e 	.word	0x20001d7e
 8002460:	20000040 	.word	0x20000040
 8002464:	200000b4 	.word	0x200000b4

08002468 <pvTaskIncrementMutexHeldCount>:
        if( pxCurrentTCB != NULL )
 8002468:	4b04      	ldr	r3, [pc, #16]	; (800247c <pvTaskIncrementMutexHeldCount+0x14>)
 800246a:	681a      	ldr	r2, [r3, #0]
 800246c:	2a00      	cmp	r2, #0
 800246e:	d003      	beq.n	8002478 <pvTaskIncrementMutexHeldCount+0x10>
            ( pxCurrentTCB->uxMutexesHeld )++;
 8002470:	6819      	ldr	r1, [r3, #0]
 8002472:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 8002474:	3201      	adds	r2, #1
 8002476:	64ca      	str	r2, [r1, #76]	; 0x4c
        return pxCurrentTCB;
 8002478:	6818      	ldr	r0, [r3, #0]
    }
 800247a:	4770      	bx	lr
 800247c:	20000034 	.word	0x20000034

08002480 <prvSwitchTimerLists>:
            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8002480:	2328      	movs	r3, #40	; 0x28
    {
 8002482:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002484:	464f      	mov	r7, r9
 8002486:	4646      	mov	r6, r8
 8002488:	46d6      	mov	lr, sl
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800248a:	4699      	mov	r9, r3
        if( xTimerQueue != NULL )
 800248c:	4b22      	ldr	r3, [pc, #136]	; (8002518 <prvSwitchTimerLists+0x98>)
    {
 800248e:	b5c0      	push	{r6, r7, lr}
        if( xTimerQueue != NULL )
 8002490:	4698      	mov	r8, r3
 8002492:	4d22      	ldr	r5, [pc, #136]	; (800251c <prvSwitchTimerLists+0x9c>)
    {
 8002494:	b084      	sub	sp, #16
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8002496:	2604      	movs	r6, #4
 8002498:	e00e      	b.n	80024b8 <prvSwitchTimerLists+0x38>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800249a:	68db      	ldr	r3, [r3, #12]
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800249c:	68dc      	ldr	r4, [r3, #12]
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800249e:	681a      	ldr	r2, [r3, #0]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80024a0:	1d27      	adds	r7, r4, #4
 80024a2:	0038      	movs	r0, r7
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80024a4:	4692      	mov	sl, r2
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80024a6:	f7fd feef 	bl	8000288 <uxListRemove>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80024aa:	6a23      	ldr	r3, [r4, #32]
 80024ac:	0020      	movs	r0, r4
 80024ae:	4798      	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80024b0:	464b      	mov	r3, r9
 80024b2:	5ce3      	ldrb	r3, [r4, r3]
 80024b4:	421e      	tst	r6, r3
 80024b6:	d10d      	bne.n	80024d4 <prvSwitchTimerLists+0x54>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80024b8:	682b      	ldr	r3, [r5, #0]
 80024ba:	681a      	ldr	r2, [r3, #0]
 80024bc:	2a00      	cmp	r2, #0
 80024be:	d1ec      	bne.n	800249a <prvSwitchTimerLists+0x1a>
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
 80024c0:	4a17      	ldr	r2, [pc, #92]	; (8002520 <prvSwitchTimerLists+0xa0>)
 80024c2:	6811      	ldr	r1, [r2, #0]
        pxOverflowTimerList = pxTemp;
 80024c4:	6013      	str	r3, [r2, #0]
        pxCurrentTimerList = pxOverflowTimerList;
 80024c6:	6029      	str	r1, [r5, #0]
    }
 80024c8:	b004      	add	sp, #16
 80024ca:	bce0      	pop	{r5, r6, r7}
 80024cc:	46ba      	mov	sl, r7
 80024ce:	46b1      	mov	r9, r6
 80024d0:	46a8      	mov	r8, r5
 80024d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80024d4:	69a3      	ldr	r3, [r4, #24]
 80024d6:	4453      	add	r3, sl
                if( xReloadTime > xNextExpireTime )
 80024d8:	459a      	cmp	sl, r3
 80024da:	d206      	bcs.n	80024ea <prvSwitchTimerLists+0x6a>
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80024dc:	0039      	movs	r1, r7
 80024de:	6828      	ldr	r0, [r5, #0]
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80024e0:	6063      	str	r3, [r4, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80024e2:	6124      	str	r4, [r4, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80024e4:	f7fd feb8 	bl	8000258 <vListInsert>
 80024e8:	e7d5      	b.n	8002496 <prvSwitchTimerLists+0x16>
        if( xTimerQueue != NULL )
 80024ea:	4643      	mov	r3, r8
 80024ec:	681b      	ldr	r3, [r3, #0]
 80024ee:	2b00      	cmp	r3, #0
 80024f0:	d00f      	beq.n	8002512 <prvSwitchTimerLists+0x92>
            xMessage.xMessageID = xCommandID;
 80024f2:	2300      	movs	r3, #0
 80024f4:	9301      	str	r3, [sp, #4]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80024f6:	4653      	mov	r3, sl
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 80024f8:	9403      	str	r4, [sp, #12]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80024fa:	9302      	str	r3, [sp, #8]
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80024fc:	f7ff fe50 	bl	80021a0 <xTaskGetSchedulerState>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8002500:	4643      	mov	r3, r8
 8002502:	2200      	movs	r2, #0
 8002504:	6818      	ldr	r0, [r3, #0]
 8002506:	a901      	add	r1, sp, #4
 8002508:	2300      	movs	r3, #0
 800250a:	f7fd ffb5 	bl	8000478 <xQueueGenericSend>
                    configASSERT( xResult );
 800250e:	2800      	cmp	r0, #0
 8002510:	d1c1      	bne.n	8002496 <prvSwitchTimerLists+0x16>
 8002512:	b672      	cpsid	i
 8002514:	e7fe      	b.n	8002514 <prvSwitchTimerLists+0x94>
 8002516:	46c0      	nop			; (mov r8, r8)
 8002518:	2000016c 	.word	0x2000016c
 800251c:	20000138 	.word	0x20000138
 8002520:	2000013c 	.word	0x2000013c

08002524 <prvTimerTask>:
    {
 8002524:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002526:	4657      	mov	r7, sl
 8002528:	464e      	mov	r6, r9
 800252a:	4645      	mov	r5, r8
 800252c:	46de      	mov	lr, fp
 800252e:	b5e0      	push	{r5, r6, r7, lr}
 8002530:	4b93      	ldr	r3, [pc, #588]	; (8002780 <prvTimerTask+0x25c>)
 8002532:	b089      	sub	sp, #36	; 0x24
 8002534:	4699      	mov	r9, r3
 8002536:	4b93      	ldr	r3, [pc, #588]	; (8002784 <prvTimerTask+0x260>)
 8002538:	4f93      	ldr	r7, [pc, #588]	; (8002788 <prvTimerTask+0x264>)
 800253a:	9301      	str	r3, [sp, #4]
 800253c:	4b93      	ldr	r3, [pc, #588]	; (800278c <prvTimerTask+0x268>)
 800253e:	4c94      	ldr	r4, [pc, #592]	; (8002790 <prvTimerTask+0x26c>)
 8002540:	9300      	str	r3, [sp, #0]
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8002542:	2328      	movs	r3, #40	; 0x28
 8002544:	4698      	mov	r8, r3
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002546:	464b      	mov	r3, r9
 8002548:	681b      	ldr	r3, [r3, #0]
 800254a:	681e      	ldr	r6, [r3, #0]
 800254c:	2e00      	cmp	r6, #0
 800254e:	d100      	bne.n	8002552 <prvTimerTask+0x2e>
 8002550:	e091      	b.n	8002676 <prvTimerTask+0x152>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002552:	68db      	ldr	r3, [r3, #12]
 8002554:	681e      	ldr	r6, [r3, #0]
        vTaskSuspendAll();
 8002556:	f7ff fa19 	bl	800198c <vTaskSuspendAll>
        xTimeNow = xTaskGetTickCount();
 800255a:	f7ff fa1f 	bl	800199c <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 800255e:	683b      	ldr	r3, [r7, #0]
        xTimeNow = xTaskGetTickCount();
 8002560:	0005      	movs	r5, r0
        if( xTimeNow < xLastTime )
 8002562:	4283      	cmp	r3, r0
 8002564:	d900      	bls.n	8002568 <prvTimerTask+0x44>
 8002566:	e0a0      	b.n	80026aa <prvTimerTask+0x186>
        xLastTime = xTimeNow;
 8002568:	6038      	str	r0, [r7, #0]
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800256a:	4286      	cmp	r6, r0
 800256c:	d800      	bhi.n	8002570 <prvTimerTask+0x4c>
 800256e:	e0a5      	b.n	80026bc <prvTimerTask+0x198>
 8002570:	2200      	movs	r2, #0
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002572:	6820      	ldr	r0, [r4, #0]
 8002574:	1b71      	subs	r1, r6, r5
 8002576:	f7fe ff55 	bl	8001424 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 800257a:	f7ff fb9b 	bl	8001cb4 <xTaskResumeAll>
 800257e:	2800      	cmp	r0, #0
 8002580:	d100      	bne.n	8002584 <prvTimerTask+0x60>
 8002582:	e08f      	b.n	80026a4 <prvTimerTask+0x180>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8002584:	2302      	movs	r3, #2
 8002586:	469b      	mov	fp, r3
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8002588:	3b01      	subs	r3, #1
 800258a:	469a      	mov	sl, r3
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800258c:	2200      	movs	r2, #0
 800258e:	6820      	ldr	r0, [r4, #0]
 8002590:	a902      	add	r1, sp, #8
 8002592:	f7fe fab1 	bl	8000af8 <xQueueReceive>
 8002596:	2800      	cmp	r0, #0
 8002598:	d0d5      	beq.n	8002546 <prvTimerTask+0x22>
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800259a:	9b02      	ldr	r3, [sp, #8]
 800259c:	2b00      	cmp	r3, #0
 800259e:	dbf5      	blt.n	800258c <prvTimerTask+0x68>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 80025a0:	9d04      	ldr	r5, [sp, #16]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 80025a2:	696b      	ldr	r3, [r5, #20]
 80025a4:	2b00      	cmp	r3, #0
 80025a6:	d002      	beq.n	80025ae <prvTimerTask+0x8a>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80025a8:	1d28      	adds	r0, r5, #4
 80025aa:	f7fd fe6d 	bl	8000288 <uxListRemove>
        xTimeNow = xTaskGetTickCount();
 80025ae:	f7ff f9f5 	bl	800199c <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 80025b2:	683b      	ldr	r3, [r7, #0]
        xTimeNow = xTaskGetTickCount();
 80025b4:	0006      	movs	r6, r0
        if( xTimeNow < xLastTime )
 80025b6:	4298      	cmp	r0, r3
 80025b8:	d37d      	bcc.n	80026b6 <prvTimerTask+0x192>
                switch( xMessage.xMessageID )
 80025ba:	9b02      	ldr	r3, [sp, #8]
        xLastTime = xTimeNow;
 80025bc:	603e      	str	r6, [r7, #0]
                switch( xMessage.xMessageID )
 80025be:	2b09      	cmp	r3, #9
 80025c0:	d8e4      	bhi.n	800258c <prvTimerTask+0x68>
 80025c2:	9a00      	ldr	r2, [sp, #0]
 80025c4:	009b      	lsls	r3, r3, #2
 80025c6:	58d3      	ldr	r3, [r2, r3]
 80025c8:	469f      	mov	pc, r3
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80025ca:	4643      	mov	r3, r8
 80025cc:	2201      	movs	r2, #1
 80025ce:	5ceb      	ldrb	r3, [r5, r3]
 80025d0:	4313      	orrs	r3, r2
 80025d2:	4642      	mov	r2, r8
 80025d4:	54ab      	strb	r3, [r5, r2]
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80025d6:	69a9      	ldr	r1, [r5, #24]
 80025d8:	9b03      	ldr	r3, [sp, #12]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80025da:	612d      	str	r5, [r5, #16]
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80025dc:	185a      	adds	r2, r3, r1
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 80025de:	606a      	str	r2, [r5, #4]
        if( xNextExpiryTime <= xTimeNow )
 80025e0:	42b2      	cmp	r2, r6
 80025e2:	d900      	bls.n	80025e6 <prvTimerTask+0xc2>
 80025e4:	e086      	b.n	80026f4 <prvTimerTask+0x1d0>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80025e6:	1af3      	subs	r3, r6, r3
 80025e8:	4299      	cmp	r1, r3
 80025ea:	d900      	bls.n	80025ee <prvTimerTask+0xca>
 80025ec:	e0a4      	b.n	8002738 <prvTimerTask+0x214>
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80025ee:	6a2b      	ldr	r3, [r5, #32]
 80025f0:	0028      	movs	r0, r5
 80025f2:	4798      	blx	r3
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80025f4:	4643      	mov	r3, r8
 80025f6:	5ceb      	ldrb	r3, [r5, r3]
 80025f8:	075b      	lsls	r3, r3, #29
 80025fa:	d5c7      	bpl.n	800258c <prvTimerTask+0x68>
        if( xTimerQueue != NULL )
 80025fc:	6822      	ldr	r2, [r4, #0]
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80025fe:	9903      	ldr	r1, [sp, #12]
 8002600:	69ab      	ldr	r3, [r5, #24]
        if( xTimerQueue != NULL )
 8002602:	2a00      	cmp	r2, #0
 8002604:	d00e      	beq.n	8002624 <prvTimerTask+0x100>
            xMessage.xMessageID = xCommandID;
 8002606:	2200      	movs	r2, #0
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8002608:	185b      	adds	r3, r3, r1
            xMessage.xMessageID = xCommandID;
 800260a:	9205      	str	r2, [sp, #20]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800260c:	9306      	str	r3, [sp, #24]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 800260e:	9507      	str	r5, [sp, #28]
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002610:	f7ff fdc6 	bl	80021a0 <xTaskGetSchedulerState>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8002614:	2300      	movs	r3, #0
 8002616:	6820      	ldr	r0, [r4, #0]
 8002618:	001a      	movs	r2, r3
 800261a:	a905      	add	r1, sp, #20
 800261c:	f7fd ff2c 	bl	8000478 <xQueueGenericSend>
                                configASSERT( xResult );
 8002620:	2800      	cmp	r0, #0
 8002622:	d1b3      	bne.n	800258c <prvTimerTask+0x68>
 8002624:	b672      	cpsid	i
 8002626:	e7fe      	b.n	8002626 <prvTimerTask+0x102>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8002628:	4643      	mov	r3, r8
 800262a:	2201      	movs	r2, #1
 800262c:	5ceb      	ldrb	r3, [r5, r3]
 800262e:	4313      	orrs	r3, r2
 8002630:	4642      	mov	r2, r8
 8002632:	54ab      	strb	r3, [r5, r2]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8002634:	9b03      	ldr	r3, [sp, #12]
 8002636:	61ab      	str	r3, [r5, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8002638:	2b00      	cmp	r3, #0
 800263a:	d100      	bne.n	800263e <prvTimerTask+0x11a>
 800263c:	e09e      	b.n	800277c <prvTimerTask+0x258>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800263e:	199b      	adds	r3, r3, r6
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002640:	606b      	str	r3, [r5, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002642:	612d      	str	r5, [r5, #16]
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002644:	1d29      	adds	r1, r5, #4
        if( xNextExpiryTime <= xTimeNow )
 8002646:	42b3      	cmp	r3, r6
 8002648:	d85f      	bhi.n	800270a <prvTimerTask+0x1e6>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800264a:	9b01      	ldr	r3, [sp, #4]
 800264c:	6818      	ldr	r0, [r3, #0]
 800264e:	f7fd fe03 	bl	8000258 <vListInsert>
        return xProcessTimerNow;
 8002652:	e79b      	b.n	800258c <prvTimerTask+0x68>
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8002654:	4643      	mov	r3, r8
 8002656:	4652      	mov	r2, sl
 8002658:	5ceb      	ldrb	r3, [r5, r3]
 800265a:	4393      	bics	r3, r2
 800265c:	4642      	mov	r2, r8
 800265e:	54ab      	strb	r3, [r5, r2]
                        break;
 8002660:	e794      	b.n	800258c <prvTimerTask+0x68>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8002662:	4643      	mov	r3, r8
 8002664:	465a      	mov	r2, fp
 8002666:	5ceb      	ldrb	r3, [r5, r3]
 8002668:	421a      	tst	r2, r3
 800266a:	d053      	beq.n	8002714 <prvTimerTask+0x1f0>
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800266c:	4652      	mov	r2, sl
 800266e:	4393      	bics	r3, r2
 8002670:	4642      	mov	r2, r8
 8002672:	54ab      	strb	r3, [r5, r2]
 8002674:	e78a      	b.n	800258c <prvTimerTask+0x68>
        vTaskSuspendAll();
 8002676:	f7ff f989 	bl	800198c <vTaskSuspendAll>
        xTimeNow = xTaskGetTickCount();
 800267a:	f7ff f98f 	bl	800199c <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 800267e:	683b      	ldr	r3, [r7, #0]
        xTimeNow = xTaskGetTickCount();
 8002680:	0005      	movs	r5, r0
        if( xTimeNow < xLastTime )
 8002682:	4283      	cmp	r3, r0
 8002684:	d811      	bhi.n	80026aa <prvTimerTask+0x186>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8002686:	9b01      	ldr	r3, [sp, #4]
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002688:	6820      	ldr	r0, [r4, #0]
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800268a:	681b      	ldr	r3, [r3, #0]
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800268c:	1b71      	subs	r1, r6, r5
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800268e:	681a      	ldr	r2, [r3, #0]
        xLastTime = xTimeNow;
 8002690:	603d      	str	r5, [r7, #0]
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8002692:	4253      	negs	r3, r2
 8002694:	415a      	adcs	r2, r3
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002696:	f7fe fec5 	bl	8001424 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 800269a:	f7ff fb0b 	bl	8001cb4 <xTaskResumeAll>
 800269e:	2800      	cmp	r0, #0
 80026a0:	d000      	beq.n	80026a4 <prvTimerTask+0x180>
 80026a2:	e76f      	b.n	8002584 <prvTimerTask+0x60>
                        portYIELD_WITHIN_API();
 80026a4:	f000 f8f8 	bl	8002898 <vPortYield>
 80026a8:	e76c      	b.n	8002584 <prvTimerTask+0x60>
            prvSwitchTimerLists();
 80026aa:	f7ff fee9 	bl	8002480 <prvSwitchTimerLists>
        xLastTime = xTimeNow;
 80026ae:	603d      	str	r5, [r7, #0]
                ( void ) xTaskResumeAll();
 80026b0:	f7ff fb00 	bl	8001cb4 <xTaskResumeAll>
 80026b4:	e766      	b.n	8002584 <prvTimerTask+0x60>
            prvSwitchTimerLists();
 80026b6:	f7ff fee3 	bl	8002480 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
 80026ba:	e77e      	b.n	80025ba <prvTimerTask+0x96>
                    ( void ) xTaskResumeAll();
 80026bc:	f7ff fafa 	bl	8001cb4 <xTaskResumeAll>
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80026c0:	464b      	mov	r3, r9
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	68db      	ldr	r3, [r3, #12]
 80026c6:	68db      	ldr	r3, [r3, #12]
 80026c8:	469a      	mov	sl, r3
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80026ca:	2304      	movs	r3, #4
 80026cc:	4453      	add	r3, sl
 80026ce:	0018      	movs	r0, r3
 80026d0:	469b      	mov	fp, r3
 80026d2:	f7fd fdd9 	bl	8000288 <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80026d6:	4653      	mov	r3, sl
 80026d8:	4642      	mov	r2, r8
 80026da:	5c9b      	ldrb	r3, [r3, r2]
 80026dc:	075a      	lsls	r2, r3, #29
 80026de:	d41d      	bmi.n	800271c <prvTimerTask+0x1f8>
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80026e0:	2201      	movs	r2, #1
 80026e2:	4641      	mov	r1, r8
 80026e4:	4393      	bics	r3, r2
 80026e6:	4652      	mov	r2, sl
 80026e8:	5453      	strb	r3, [r2, r1]
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80026ea:	4653      	mov	r3, sl
 80026ec:	4650      	mov	r0, sl
 80026ee:	6a1b      	ldr	r3, [r3, #32]
 80026f0:	4798      	blx	r3
    }
 80026f2:	e747      	b.n	8002584 <prvTimerTask+0x60>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80026f4:	42b3      	cmp	r3, r6
 80026f6:	d902      	bls.n	80026fe <prvTimerTask+0x1da>
 80026f8:	4293      	cmp	r3, r2
 80026fa:	d800      	bhi.n	80026fe <prvTimerTask+0x1da>
 80026fc:	e777      	b.n	80025ee <prvTimerTask+0xca>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80026fe:	464b      	mov	r3, r9
 8002700:	1d29      	adds	r1, r5, #4
 8002702:	6818      	ldr	r0, [r3, #0]
 8002704:	f7fd fda8 	bl	8000258 <vListInsert>
        return xProcessTimerNow;
 8002708:	e740      	b.n	800258c <prvTimerTask+0x68>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800270a:	464b      	mov	r3, r9
 800270c:	6818      	ldr	r0, [r3, #0]
 800270e:	f7fd fda3 	bl	8000258 <vListInsert>
 8002712:	e73b      	b.n	800258c <prvTimerTask+0x68>
                                    vPortFree( pxTimer );
 8002714:	0028      	movs	r0, r5
 8002716:	f000 f9ad 	bl	8002a74 <vPortFree>
 800271a:	e737      	b.n	800258c <prvTimerTask+0x68>
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800271c:	4653      	mov	r3, sl
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800271e:	4651      	mov	r1, sl
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8002720:	699a      	ldr	r2, [r3, #24]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002722:	6109      	str	r1, [r1, #16]
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8002724:	18b3      	adds	r3, r6, r2
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002726:	604b      	str	r3, [r1, #4]
        if( xNextExpiryTime <= xTimeNow )
 8002728:	42ab      	cmp	r3, r5
 800272a:	d90b      	bls.n	8002744 <prvTimerTask+0x220>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800272c:	464b      	mov	r3, r9
 800272e:	4659      	mov	r1, fp
 8002730:	6818      	ldr	r0, [r3, #0]
 8002732:	f7fd fd91 	bl	8000258 <vListInsert>
        return xProcessTimerNow;
 8002736:	e7d8      	b.n	80026ea <prvTimerTask+0x1c6>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002738:	9b01      	ldr	r3, [sp, #4]
 800273a:	1d29      	adds	r1, r5, #4
 800273c:	6818      	ldr	r0, [r3, #0]
 800273e:	f7fd fd8b 	bl	8000258 <vListInsert>
        return xProcessTimerNow;
 8002742:	e723      	b.n	800258c <prvTimerTask+0x68>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002744:	1bad      	subs	r5, r5, r6
 8002746:	42aa      	cmp	r2, r5
 8002748:	d812      	bhi.n	8002770 <prvTimerTask+0x24c>
        if( xTimerQueue != NULL )
 800274a:	6823      	ldr	r3, [r4, #0]
 800274c:	2b00      	cmp	r3, #0
 800274e:	d00d      	beq.n	800276c <prvTimerTask+0x248>
            xMessage.xMessageID = xCommandID;
 8002750:	2300      	movs	r3, #0
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 8002752:	9107      	str	r1, [sp, #28]
            xMessage.xMessageID = xCommandID;
 8002754:	9305      	str	r3, [sp, #20]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8002756:	9606      	str	r6, [sp, #24]
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002758:	f7ff fd22 	bl	80021a0 <xTaskGetSchedulerState>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800275c:	2300      	movs	r3, #0
 800275e:	6820      	ldr	r0, [r4, #0]
 8002760:	001a      	movs	r2, r3
 8002762:	a905      	add	r1, sp, #20
 8002764:	f7fd fe88 	bl	8000478 <xQueueGenericSend>
                configASSERT( xResult );
 8002768:	2800      	cmp	r0, #0
 800276a:	d1be      	bne.n	80026ea <prvTimerTask+0x1c6>
 800276c:	b672      	cpsid	i
 800276e:	e7fe      	b.n	800276e <prvTimerTask+0x24a>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002770:	9b01      	ldr	r3, [sp, #4]
 8002772:	4659      	mov	r1, fp
 8002774:	6818      	ldr	r0, [r3, #0]
 8002776:	f7fd fd6f 	bl	8000258 <vListInsert>
        return xProcessTimerNow;
 800277a:	e7b6      	b.n	80026ea <prvTimerTask+0x1c6>
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800277c:	b672      	cpsid	i
 800277e:	e7fe      	b.n	800277e <prvTimerTask+0x25a>
 8002780:	20000138 	.word	0x20000138
 8002784:	2000013c 	.word	0x2000013c
 8002788:	20000168 	.word	0x20000168
 800278c:	08005dbc 	.word	0x08005dbc
 8002790:	2000016c 	.word	0x2000016c

08002794 <xTimerCreateTimerTask>:
    {
 8002794:	b570      	push	{r4, r5, r6, lr}
 8002796:	b082      	sub	sp, #8
    static void prvCheckForValidListAndQueue( void )
    {
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 8002798:	f000 f88a 	bl	80028b0 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 800279c:	4c15      	ldr	r4, [pc, #84]	; (80027f4 <xTimerCreateTimerTask+0x60>)
 800279e:	6823      	ldr	r3, [r4, #0]
 80027a0:	2b00      	cmp	r3, #0
 80027a2:	d014      	beq.n	80027ce <xTimerCreateTimerTask+0x3a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 80027a4:	f000 f890 	bl	80028c8 <vPortExitCritical>
        if( xTimerQueue != NULL )
 80027a8:	6823      	ldr	r3, [r4, #0]
 80027aa:	2b00      	cmp	r3, #0
 80027ac:	d00b      	beq.n	80027c6 <xTimerCreateTimerTask+0x32>
                    xReturn = xTaskCreate( prvTimerTask,
 80027ae:	4b12      	ldr	r3, [pc, #72]	; (80027f8 <xTimerCreateTimerTask+0x64>)
 80027b0:	2246      	movs	r2, #70	; 0x46
 80027b2:	9301      	str	r3, [sp, #4]
 80027b4:	2303      	movs	r3, #3
 80027b6:	4911      	ldr	r1, [pc, #68]	; (80027fc <xTimerCreateTimerTask+0x68>)
 80027b8:	9300      	str	r3, [sp, #0]
 80027ba:	4811      	ldr	r0, [pc, #68]	; (8002800 <xTimerCreateTimerTask+0x6c>)
 80027bc:	2300      	movs	r3, #0
 80027be:	f7fe ff39 	bl	8001634 <xTaskCreate>
        configASSERT( xReturn );
 80027c2:	2800      	cmp	r0, #0
 80027c4:	d101      	bne.n	80027ca <xTimerCreateTimerTask+0x36>
 80027c6:	b672      	cpsid	i
 80027c8:	e7fe      	b.n	80027c8 <xTimerCreateTimerTask+0x34>
    }
 80027ca:	b002      	add	sp, #8
 80027cc:	bd70      	pop	{r4, r5, r6, pc}
                vListInitialise( &xActiveTimerList1 );
 80027ce:	4e0d      	ldr	r6, [pc, #52]	; (8002804 <xTimerCreateTimerTask+0x70>)
 80027d0:	0030      	movs	r0, r6
 80027d2:	f7fd fd25 	bl	8000220 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 80027d6:	4d0c      	ldr	r5, [pc, #48]	; (8002808 <xTimerCreateTimerTask+0x74>)
 80027d8:	0028      	movs	r0, r5
 80027da:	f7fd fd21 	bl	8000220 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 80027de:	4b0b      	ldr	r3, [pc, #44]	; (800280c <xTimerCreateTimerTask+0x78>)
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80027e0:	2200      	movs	r2, #0
                pxCurrentTimerList = &xActiveTimerList1;
 80027e2:	601e      	str	r6, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 80027e4:	4b0a      	ldr	r3, [pc, #40]	; (8002810 <xTimerCreateTimerTask+0x7c>)
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80027e6:	210c      	movs	r1, #12
 80027e8:	2005      	movs	r0, #5
                pxOverflowTimerList = &xActiveTimerList2;
 80027ea:	601d      	str	r5, [r3, #0]
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80027ec:	f7fd fd98 	bl	8000320 <xQueueGenericCreate>
 80027f0:	6020      	str	r0, [r4, #0]
 80027f2:	e7d7      	b.n	80027a4 <xTimerCreateTimerTask+0x10>
 80027f4:	2000016c 	.word	0x2000016c
 80027f8:	20000170 	.word	0x20000170
 80027fc:	08005de4 	.word	0x08005de4
 8002800:	08002525 	.word	0x08002525
 8002804:	20000140 	.word	0x20000140
 8002808:	20000154 	.word	0x20000154
 800280c:	20000138 	.word	0x20000138
 8002810:	2000013c 	.word	0x2000013c

08002814 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    volatile uint32_t ulDummy = 0UL;
 8002814:	2300      	movs	r3, #0
{
 8002816:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0UL;
 8002818:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 800281a:	4b06      	ldr	r3, [pc, #24]	; (8002834 <prvTaskExitError+0x20>)
 800281c:	681b      	ldr	r3, [r3, #0]
 800281e:	3301      	adds	r3, #1
 8002820:	d001      	beq.n	8002826 <prvTaskExitError+0x12>
 8002822:	b672      	cpsid	i
 8002824:	e7fe      	b.n	8002824 <prvTaskExitError+0x10>
    portDISABLE_INTERRUPTS();
 8002826:	b672      	cpsid	i

    while( ulDummy == 0 )
 8002828:	9b01      	ldr	r3, [sp, #4]
 800282a:	2b00      	cmp	r3, #0
 800282c:	d0fc      	beq.n	8002828 <prvTaskExitError+0x14>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 800282e:	b002      	add	sp, #8
 8002830:	4770      	bx	lr
 8002832:	46c0      	nop			; (mov r8, r8)
 8002834:	20000004 	.word	0x20000004
	...

08002840 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
 8002840:	4a0b      	ldr	r2, [pc, #44]	; (8002870 <pxCurrentTCBConst2>)
 8002842:	6813      	ldr	r3, [r2, #0]
 8002844:	6818      	ldr	r0, [r3, #0]
 8002846:	3020      	adds	r0, #32
 8002848:	f380 8809 	msr	PSP, r0
 800284c:	2002      	movs	r0, #2
 800284e:	f380 8814 	msr	CONTROL, r0
 8002852:	f3bf 8f6f 	isb	sy
 8002856:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 8002858:	46ae      	mov	lr, r5
 800285a:	bc08      	pop	{r3}
 800285c:	bc04      	pop	{r2}
 800285e:	b662      	cpsie	i
 8002860:	4718      	bx	r3
 8002862:	46c0      	nop			; (mov r8, r8)
 8002864:	46c0      	nop			; (mov r8, r8)
 8002866:	46c0      	nop			; (mov r8, r8)
 8002868:	46c0      	nop			; (mov r8, r8)
 800286a:	46c0      	nop			; (mov r8, r8)
 800286c:	46c0      	nop			; (mov r8, r8)
 800286e:	46c0      	nop			; (mov r8, r8)

08002870 <pxCurrentTCBConst2>:
 8002870:	20000034 	.word	0x20000034

08002874 <pxPortInitialiseStack>:
{
 8002874:	b510      	push	{r4, lr}
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
 8002876:	2480      	movs	r4, #128	; 0x80
 8002878:	1f03      	subs	r3, r0, #4
 800287a:	0464      	lsls	r4, r4, #17
 800287c:	601c      	str	r4, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
 800287e:	3b04      	subs	r3, #4
 8002880:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
 8002882:	4903      	ldr	r1, [pc, #12]	; (8002890 <pxPortInitialiseStack+0x1c>)
 8002884:	3b04      	subs	r3, #4
 8002886:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 8002888:	3b14      	subs	r3, #20
    pxTopOfStack -= 8;                                       /* R11..R4. */
 800288a:	3840      	subs	r0, #64	; 0x40
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 800288c:	601a      	str	r2, [r3, #0]
}
 800288e:	bd10      	pop	{r4, pc}
 8002890:	08002815 	.word	0x08002815

08002894 <SVC_Handler>:
}
 8002894:	4770      	bx	lr
 8002896:	46c0      	nop			; (mov r8, r8)

08002898 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002898:	2280      	movs	r2, #128	; 0x80
 800289a:	4b04      	ldr	r3, [pc, #16]	; (80028ac <vPortYield+0x14>)
 800289c:	0552      	lsls	r2, r2, #21
 800289e:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
 80028a0:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 80028a4:	f3bf 8f6f 	isb	sy
}
 80028a8:	4770      	bx	lr
 80028aa:	46c0      	nop			; (mov r8, r8)
 80028ac:	e000ed04 	.word	0xe000ed04

080028b0 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 80028b0:	b672      	cpsid	i
    uxCriticalNesting++;
 80028b2:	4a04      	ldr	r2, [pc, #16]	; (80028c4 <vPortEnterCritical+0x14>)
 80028b4:	6813      	ldr	r3, [r2, #0]
 80028b6:	3301      	adds	r3, #1
 80028b8:	6013      	str	r3, [r2, #0]
    __asm volatile ( "dsb" ::: "memory" );
 80028ba:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 80028be:	f3bf 8f6f 	isb	sy
}
 80028c2:	4770      	bx	lr
 80028c4:	20000004 	.word	0x20000004

080028c8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
 80028c8:	4a05      	ldr	r2, [pc, #20]	; (80028e0 <vPortExitCritical+0x18>)
 80028ca:	6813      	ldr	r3, [r2, #0]
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d101      	bne.n	80028d4 <vPortExitCritical+0xc>
 80028d0:	b672      	cpsid	i
 80028d2:	e7fe      	b.n	80028d2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 80028d4:	3b01      	subs	r3, #1
 80028d6:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
 80028d8:	2b00      	cmp	r3, #0
 80028da:	d100      	bne.n	80028de <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 80028dc:	b662      	cpsie	i
    }
}
 80028de:	4770      	bx	lr
 80028e0:	20000004 	.word	0x20000004

080028e4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
 80028e4:	f3ef 8010 	mrs	r0, PRIMASK
 80028e8:	b672      	cpsid	i
 80028ea:	4770      	bx	lr

080028ec <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
 80028ec:	f380 8810 	msr	PRIMASK, r0
 80028f0:	4770      	bx	lr
 80028f2:	46c0      	nop			; (mov r8, r8)
	...

08002900 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
 8002900:	f3ef 8009 	mrs	r0, PSP
 8002904:	4b0e      	ldr	r3, [pc, #56]	; (8002940 <pxCurrentTCBConst>)
 8002906:	681a      	ldr	r2, [r3, #0]
 8002908:	3820      	subs	r0, #32
 800290a:	6010      	str	r0, [r2, #0]
 800290c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800290e:	4644      	mov	r4, r8
 8002910:	464d      	mov	r5, r9
 8002912:	4656      	mov	r6, sl
 8002914:	465f      	mov	r7, fp
 8002916:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8002918:	b508      	push	{r3, lr}
 800291a:	b672      	cpsid	i
 800291c:	f7ff faca 	bl	8001eb4 <vTaskSwitchContext>
 8002920:	b662      	cpsie	i
 8002922:	bc0c      	pop	{r2, r3}
 8002924:	6811      	ldr	r1, [r2, #0]
 8002926:	6808      	ldr	r0, [r1, #0]
 8002928:	3010      	adds	r0, #16
 800292a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800292c:	46a0      	mov	r8, r4
 800292e:	46a9      	mov	r9, r5
 8002930:	46b2      	mov	sl, r6
 8002932:	46bb      	mov	fp, r7
 8002934:	f380 8809 	msr	PSP, r0
 8002938:	3820      	subs	r0, #32
 800293a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800293c:	4718      	bx	r3
 800293e:	46c0      	nop			; (mov r8, r8)

08002940 <pxCurrentTCBConst>:
 8002940:	20000034 	.word	0x20000034

08002944 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8002944:	b510      	push	{r4, lr}
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 8002946:	f7ff ffcd 	bl	80028e4 <ulSetInterruptMaskFromISR>
 800294a:	0004      	movs	r4, r0
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
 800294c:	f7ff f82c 	bl	80019a8 <xTaskIncrementTick>
 8002950:	2800      	cmp	r0, #0
 8002952:	d003      	beq.n	800295c <SysTick_Handler+0x18>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002954:	2280      	movs	r2, #128	; 0x80
 8002956:	4b03      	ldr	r3, [pc, #12]	; (8002964 <SysTick_Handler+0x20>)
 8002958:	0552      	lsls	r2, r2, #21
 800295a:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800295c:	0020      	movs	r0, r4
 800295e:	f7ff ffc5 	bl	80028ec <vClearInterruptMaskFromISR>
}
 8002962:	bd10      	pop	{r4, pc}
 8002964:	e000ed04 	.word	0xe000ed04

08002968 <vPortSetupTimerInterrupt>:
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8002968:	2200      	movs	r2, #0
 800296a:	4b05      	ldr	r3, [pc, #20]	; (8002980 <vPortSetupTimerInterrupt+0x18>)
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800296c:	4905      	ldr	r1, [pc, #20]	; (8002984 <vPortSetupTimerInterrupt+0x1c>)
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 800296e:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8002970:	600a      	str	r2, [r1, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002972:	4a05      	ldr	r2, [pc, #20]	; (8002988 <vPortSetupTimerInterrupt+0x20>)
 8002974:	4905      	ldr	r1, [pc, #20]	; (800298c <vPortSetupTimerInterrupt+0x24>)
 8002976:	6011      	str	r1, [r2, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8002978:	2207      	movs	r2, #7
 800297a:	601a      	str	r2, [r3, #0]
}
 800297c:	4770      	bx	lr
 800297e:	46c0      	nop			; (mov r8, r8)
 8002980:	e000e010 	.word	0xe000e010
 8002984:	e000e018 	.word	0xe000e018
 8002988:	e000e014 	.word	0xe000e014
 800298c:	0000bb7f 	.word	0x0000bb7f

08002990 <xPortStartScheduler>:
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8002990:	22ff      	movs	r2, #255	; 0xff
 8002992:	4b11      	ldr	r3, [pc, #68]	; (80029d8 <xPortStartScheduler+0x48>)
 8002994:	0412      	lsls	r2, r2, #16
 8002996:	6819      	ldr	r1, [r3, #0]
{
 8002998:	b530      	push	{r4, r5, lr}
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 800299a:	430a      	orrs	r2, r1
 800299c:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 800299e:	22ff      	movs	r2, #255	; 0xff
    uxCriticalNesting = 0;
 80029a0:	2500      	movs	r5, #0
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 80029a2:	6819      	ldr	r1, [r3, #0]
 80029a4:	0612      	lsls	r2, r2, #24
 80029a6:	430a      	orrs	r2, r1
{
 80029a8:	b083      	sub	sp, #12
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 80029aa:	601a      	str	r2, [r3, #0]
    vPortSetupTimerInterrupt();
 80029ac:	f7ff ffdc 	bl	8002968 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 80029b0:	4c0a      	ldr	r4, [pc, #40]	; (80029dc <xPortStartScheduler+0x4c>)
 80029b2:	6025      	str	r5, [r4, #0]
    vPortStartFirstTask();
 80029b4:	f7ff ff44 	bl	8002840 <vPortStartFirstTask>
    vTaskSwitchContext();
 80029b8:	f7ff fa7c 	bl	8001eb4 <vTaskSwitchContext>
    configASSERT( uxCriticalNesting == ~0UL );
 80029bc:	6823      	ldr	r3, [r4, #0]
    volatile uint32_t ulDummy = 0UL;
 80029be:	9501      	str	r5, [sp, #4]
    configASSERT( uxCriticalNesting == ~0UL );
 80029c0:	3301      	adds	r3, #1
 80029c2:	d001      	beq.n	80029c8 <xPortStartScheduler+0x38>
 80029c4:	b672      	cpsid	i
 80029c6:	e7fe      	b.n	80029c6 <xPortStartScheduler+0x36>
    portDISABLE_INTERRUPTS();
 80029c8:	b672      	cpsid	i
    while( ulDummy == 0 )
 80029ca:	9b01      	ldr	r3, [sp, #4]
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	d0fc      	beq.n	80029ca <xPortStartScheduler+0x3a>
}
 80029d0:	2000      	movs	r0, #0
 80029d2:	b003      	add	sp, #12
 80029d4:	bd30      	pop	{r4, r5, pc}
 80029d6:	46c0      	nop			; (mov r8, r8)
 80029d8:	e000ed20 	.word	0xe000ed20
 80029dc:	20000004 	.word	0x20000004

080029e0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 80029e0:	b570      	push	{r4, r5, r6, lr}
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
        {
            if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 80029e2:	2507      	movs	r5, #7
{
 80029e4:	0004      	movs	r4, r0
            if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 80029e6:	4205      	tst	r5, r0
 80029e8:	d005      	beq.n	80029f6 <pvPortMalloc+0x16>
            {
                /* Byte alignment required. Check for overflow. */
                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )
 80029ea:	0003      	movs	r3, r0
 80029ec:	43ab      	bics	r3, r5
 80029ee:	3308      	adds	r3, #8
 80029f0:	4283      	cmp	r3, r0
 80029f2:	d91d      	bls.n	8002a30 <pvPortMalloc+0x50>
 80029f4:	001c      	movs	r4, r3
                }
            }
        }
    #endif

    vTaskSuspendAll();
 80029f6:	f7fe ffc9 	bl	800198c <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 80029fa:	4b1a      	ldr	r3, [pc, #104]	; (8002a64 <pvPortMalloc+0x84>)
 80029fc:	681d      	ldr	r5, [r3, #0]
 80029fe:	2d00      	cmp	r5, #0
 8002a00:	d028      	beq.n	8002a54 <pvPortMalloc+0x74>
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
 8002a02:	2c00      	cmp	r4, #0
 8002a04:	d02b      	beq.n	8002a5e <pvPortMalloc+0x7e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8002a06:	4918      	ldr	r1, [pc, #96]	; (8002a68 <pvPortMalloc+0x88>)
        if( ( xWantedSize > 0 ) && /* valid size */
 8002a08:	4818      	ldr	r0, [pc, #96]	; (8002a6c <pvPortMalloc+0x8c>)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8002a0a:	680a      	ldr	r2, [r1, #0]
 8002a0c:	1913      	adds	r3, r2, r4
        if( ( xWantedSize > 0 ) && /* valid size */
 8002a0e:	4283      	cmp	r3, r0
 8002a10:	d819      	bhi.n	8002a46 <pvPortMalloc+0x66>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8002a12:	429a      	cmp	r2, r3
 8002a14:	d217      	bcs.n	8002a46 <pvPortMalloc+0x66>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 8002a16:	18ad      	adds	r5, r5, r2
            xNextFreeByte += xWantedSize;
 8002a18:	600b      	str	r3, [r1, #0]
        }

        traceMALLOC( pvReturn, xWantedSize );
 8002a1a:	0022      	movs	r2, r4
 8002a1c:	2d00      	cmp	r5, #0
 8002a1e:	d013      	beq.n	8002a48 <pvPortMalloc+0x68>
 8002a20:	0029      	movs	r1, r5
 8002a22:	2094      	movs	r0, #148	; 0x94
 8002a24:	f000 fc16 	bl	8003254 <vTraceStoreMemMangEvent>
    }
    ( void ) xTaskResumeAll();
 8002a28:	f7ff f944 	bl	8001cb4 <xTaskResumeAll>
            }
        }
    #endif

    return pvReturn;
}
 8002a2c:	0028      	movs	r0, r5
 8002a2e:	bd70      	pop	{r4, r5, r6, pc}
    vTaskSuspendAll();
 8002a30:	f7fe ffac 	bl	800198c <vTaskSuspendAll>
        if( pucAlignedHeap == NULL )
 8002a34:	4b0b      	ldr	r3, [pc, #44]	; (8002a64 <pvPortMalloc+0x84>)
 8002a36:	2200      	movs	r2, #0
 8002a38:	6819      	ldr	r1, [r3, #0]
 8002a3a:	2900      	cmp	r1, #0
 8002a3c:	d104      	bne.n	8002a48 <pvPortMalloc+0x68>
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8002a3e:	490c      	ldr	r1, [pc, #48]	; (8002a70 <pvPortMalloc+0x90>)
 8002a40:	43a9      	bics	r1, r5
 8002a42:	6019      	str	r1, [r3, #0]
        if( ( xWantedSize > 0 ) && /* valid size */
 8002a44:	e000      	b.n	8002a48 <pvPortMalloc+0x68>
        traceMALLOC( pvReturn, xWantedSize );
 8002a46:	0022      	movs	r2, r4
 8002a48:	2100      	movs	r1, #0
 8002a4a:	20e8      	movs	r0, #232	; 0xe8
 8002a4c:	f000 fc02 	bl	8003254 <vTraceStoreMemMangEvent>
 8002a50:	2500      	movs	r5, #0
 8002a52:	e7e9      	b.n	8002a28 <pvPortMalloc+0x48>
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8002a54:	2207      	movs	r2, #7
 8002a56:	4d06      	ldr	r5, [pc, #24]	; (8002a70 <pvPortMalloc+0x90>)
 8002a58:	4395      	bics	r5, r2
 8002a5a:	601d      	str	r5, [r3, #0]
 8002a5c:	e7d1      	b.n	8002a02 <pvPortMalloc+0x22>
 8002a5e:	2200      	movs	r2, #0
 8002a60:	e7f2      	b.n	8002a48 <pvPortMalloc+0x68>
 8002a62:	46c0      	nop			; (mov r8, r8)
 8002a64:	20000174 	.word	0x20000174
 8002a68:	20001d78 	.word	0x20001d78
 8002a6c:	00001bf7 	.word	0x00001bf7
 8002a70:	20000180 	.word	0x20000180

08002a74 <vPortFree>:
     * heap_4.c for alternative implementations, and the memory management pages of
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
 8002a74:	2800      	cmp	r0, #0
 8002a76:	d001      	beq.n	8002a7c <vPortFree+0x8>
 8002a78:	b672      	cpsid	i
 8002a7a:	e7fe      	b.n	8002a7a <vPortFree+0x6>
}
 8002a7c:	4770      	bx	lr
 8002a7e:	46c0      	nop			; (mov r8, r8)

08002a80 <prvTraceGetQueueType>:
	return (uint32_t)uxQueueGetQueueNumber(handle);
}
#endif /* (TRC_CFG_FREERTOS_VERSION < TRC_FREERTOS_VERSION_8_X_X) */

uint8_t prvTraceGetQueueType(void* handle)
{
 8002a80:	b510      	push	{r4, lr}
	// This is either declared in header file in FreeRTOS 8 and later, or as extern above
	return ucQueueGetQueueType(handle);
 8002a82:	f7fe fccb 	bl	800141c <ucQueueGetQueueType>
}
 8002a86:	bd10      	pop	{r4, pc}

08002a88 <prvTraceGetTaskNumberLow16>:

/* Tasks */
uint16_t prvTraceGetTaskNumberLow16(void* handle)
{
 8002a88:	b510      	push	{r4, lr}
	return TRACE_GET_LOW16(uxTaskGetTaskNumber(handle));
 8002a8a:	f7ff fb79 	bl	8002180 <uxTaskGetTaskNumber>
 8002a8e:	b280      	uxth	r0, r0
}
 8002a90:	bd10      	pop	{r4, pc}
 8002a92:	46c0      	nop			; (mov r8, r8)

08002a94 <prvTraceGetTaskNumberHigh16>:

uint16_t prvTraceGetTaskNumberHigh16(void* handle)
{
 8002a94:	b510      	push	{r4, lr}
	return TRACE_GET_HIGH16(uxTaskGetTaskNumber(handle));
 8002a96:	f7ff fb73 	bl	8002180 <uxTaskGetTaskNumber>
 8002a9a:	0c00      	lsrs	r0, r0, #16
}
 8002a9c:	bd10      	pop	{r4, pc}
 8002a9e:	46c0      	nop			; (mov r8, r8)

08002aa0 <prvTraceSetTaskNumberLow16>:

void prvTraceSetTaskNumberLow16(void* handle, uint16_t value)
{
 8002aa0:	b570      	push	{r4, r5, r6, lr}
 8002aa2:	000d      	movs	r5, r1
 8002aa4:	0004      	movs	r4, r0
	vTaskSetTaskNumber(handle, TRACE_SET_LOW16(uxTaskGetTaskNumber(handle), value));
 8002aa6:	f7ff fb6b 	bl	8002180 <uxTaskGetTaskNumber>
 8002aaa:	0c01      	lsrs	r1, r0, #16
 8002aac:	0409      	lsls	r1, r1, #16
 8002aae:	4329      	orrs	r1, r5
 8002ab0:	0020      	movs	r0, r4
 8002ab2:	f7ff fb6b 	bl	800218c <vTaskSetTaskNumber>
}
 8002ab6:	bd70      	pop	{r4, r5, r6, pc}

08002ab8 <prvTraceSetTaskNumberHigh16>:

void prvTraceSetTaskNumberHigh16(void* handle, uint16_t value)
{
 8002ab8:	b570      	push	{r4, r5, r6, lr}
 8002aba:	0005      	movs	r5, r0
 8002abc:	000c      	movs	r4, r1
	vTaskSetTaskNumber(handle, TRACE_SET_HIGH16(uxTaskGetTaskNumber(handle), value));
 8002abe:	f7ff fb5f 	bl	8002180 <uxTaskGetTaskNumber>
 8002ac2:	0401      	lsls	r1, r0, #16
 8002ac4:	0424      	lsls	r4, r4, #16
 8002ac6:	0c09      	lsrs	r1, r1, #16
 8002ac8:	0028      	movs	r0, r5
 8002aca:	4321      	orrs	r1, r4
 8002acc:	f7ff fb5e 	bl	800218c <vTaskSetTaskNumber>
}
 8002ad0:	bd70      	pop	{r4, r5, r6, pc}
 8002ad2:	46c0      	nop			; (mov r8, r8)

08002ad4 <prvTraceGetQueueNumberLow16>:

uint16_t prvTraceGetQueueNumberLow16(void* handle)
{
 8002ad4:	b510      	push	{r4, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
 8002ad6:	f7fe fc9d 	bl	8001414 <uxQueueGetQueueNumber>
	return TRACE_GET_LOW16(prvTraceGetQueueNumber(handle));
 8002ada:	b280      	uxth	r0, r0
}
 8002adc:	bd10      	pop	{r4, pc}
 8002ade:	46c0      	nop			; (mov r8, r8)

08002ae0 <prvTraceGetQueueNumberHigh16>:

uint16_t prvTraceGetQueueNumberHigh16(void* handle)
{
 8002ae0:	b510      	push	{r4, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
 8002ae2:	f7fe fc97 	bl	8001414 <uxQueueGetQueueNumber>
	return TRACE_GET_HIGH16(prvTraceGetQueueNumber(handle));
 8002ae6:	0c00      	lsrs	r0, r0, #16
}
 8002ae8:	bd10      	pop	{r4, pc}
 8002aea:	46c0      	nop			; (mov r8, r8)

08002aec <prvTraceSetQueueNumberLow16>:

void prvTraceSetQueueNumberLow16(void* handle, uint16_t value)
{
 8002aec:	b570      	push	{r4, r5, r6, lr}
 8002aee:	000d      	movs	r5, r1
 8002af0:	0004      	movs	r4, r0
	return (uint32_t)uxQueueGetQueueNumber(handle);
 8002af2:	f7fe fc8f 	bl	8001414 <uxQueueGetQueueNumber>
	vQueueSetQueueNumber(handle, TRACE_SET_LOW16(prvTraceGetQueueNumber(handle), value));
 8002af6:	0c01      	lsrs	r1, r0, #16
 8002af8:	0409      	lsls	r1, r1, #16
 8002afa:	4329      	orrs	r1, r5
 8002afc:	0020      	movs	r0, r4
 8002afe:	f7fe fc8b 	bl	8001418 <vQueueSetQueueNumber>
}
 8002b02:	bd70      	pop	{r4, r5, r6, pc}

08002b04 <prvTraceSetQueueNumberHigh16>:

void prvTraceSetQueueNumberHigh16(void* handle, uint16_t value)
{
 8002b04:	b570      	push	{r4, r5, r6, lr}
 8002b06:	0005      	movs	r5, r0
 8002b08:	000c      	movs	r4, r1
	return (uint32_t)uxQueueGetQueueNumber(handle);
 8002b0a:	f7fe fc83 	bl	8001414 <uxQueueGetQueueNumber>
	vQueueSetQueueNumber(handle, TRACE_SET_HIGH16(prvTraceGetQueueNumber(handle), value));
 8002b0e:	0401      	lsls	r1, r0, #16
 8002b10:	0424      	lsls	r4, r4, #16
 8002b12:	0c09      	lsrs	r1, r1, #16
 8002b14:	0028      	movs	r0, r5
 8002b16:	4321      	orrs	r1, r4
 8002b18:	f7fe fc7e 	bl	8001418 <vQueueSetQueueNumber>
}
 8002b1c:	bd70      	pop	{r4, r5, r6, pc}
 8002b1e:	46c0      	nop			; (mov r8, r8)

08002b20 <prvTraceGetCurrentTaskHandle>:
#endif /* (TRC_CFG_INCLUDE_STREAM_BUFFER_EVENTS == 1 && TRC_CFG_FREERTOS_VERSION >= TRC_FREERTOS_VERSION_10_0_0) */

#endif /* (TRC_CFG_SCHEDULING_ONLY == 0) */

void* prvTraceGetCurrentTaskHandle()
{
 8002b20:	b510      	push	{r4, lr}
	return xTaskGetCurrentTaskHandle();
 8002b22:	f7ff fb37 	bl	8002194 <xTaskGetCurrentTaskHandle>
}
 8002b26:	bd10      	pop	{r4, pc}

08002b28 <vTraceEnable>:
*
*
* Note: See other implementation of vTraceEnable in trcStreamingRecorder.c
******************************************************************************/
void vTraceEnable(int startOption)
{
 8002b28:	b510      	push	{r4, lr}
 8002b2a:	0004      	movs	r4, r0
	/* Make sure recorder data is initialized */
	vTraceInitialize();
 8002b2c:	f000 f9ea 	bl	8002f04 <vTraceInitialize>
		xTaskCreate(TzCtrl, STRING_CAST("TzCtrl"), TRC_CFG_CTRL_TASK_STACK_SIZE, NULL, TRC_CFG_CTRL_TASK_PRIORITY, &HandleTzCtrl);
#endif /* defined(configSUPPORT_STATIC_ALLOCATION) && (configSUPPORT_STATIC_ALLOCATION == 1) */
	}
#endif /* defined(TRC_CFG_ENABLE_STACK_MONITOR) && (TRC_CFG_ENABLE_STACK_MONITOR == 1) && (TRC_CFG_SCHEDULING_ONLY == 0) */

	if (startOption == TRC_START)
 8002b30:	2c01      	cmp	r4, #1
 8002b32:	d008      	beq.n	8002b46 <vTraceEnable+0x1e>
	{
		prvTraceInitTimestamps();
		
		vTraceStart();
	}
	else if (startOption == TRC_START_AWAIT_HOST)
 8002b34:	2c02      	cmp	r4, #2
 8002b36:	d00b      	beq.n	8002b50 <vTraceEnable+0x28>
	{
		prvTraceError("vTraceEnable(TRC_START_AWAIT_HOST) not allowed in Snapshot mode");
	}
	else if (startOption != TRC_INIT)
 8002b38:	2c00      	cmp	r4, #0
 8002b3a:	d100      	bne.n	8002b3e <vTraceEnable+0x16>
	{
		prvTraceError("Unexpected argument to vTraceEnable (snapshot mode)");
	}
}
 8002b3c:	bd10      	pop	{r4, pc}
		prvTraceError("Unexpected argument to vTraceEnable (snapshot mode)");
 8002b3e:	4806      	ldr	r0, [pc, #24]	; (8002b58 <vTraceEnable+0x30>)
 8002b40:	f002 f874 	bl	8004c2c <prvTraceError>
}
 8002b44:	e7fa      	b.n	8002b3c <vTraceEnable+0x14>
		prvTraceInitTimestamps();
 8002b46:	f000 f9d3 	bl	8002ef0 <prvTraceInitTimestamps>
		vTraceStart();
 8002b4a:	f001 ffe3 	bl	8004b14 <vTraceStart>
 8002b4e:	e7f5      	b.n	8002b3c <vTraceEnable+0x14>
		prvTraceError("vTraceEnable(TRC_START_AWAIT_HOST) not allowed in Snapshot mode");
 8002b50:	4802      	ldr	r0, [pc, #8]	; (8002b5c <vTraceEnable+0x34>)
 8002b52:	f002 f86b 	bl	8004c2c <prvTraceError>
 8002b56:	e7f1      	b.n	8002b3c <vTraceEnable+0x14>
 8002b58:	08005e2c 	.word	0x08005e2c
 8002b5c:	08005dec 	.word	0x08005dec

08002b60 <vTraceInitObjectPropertyTable>:
#endif

/* Initialization of the object property table */
void vTraceInitObjectPropertyTable()
{
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = TRACE_NCLASSES;
 8002b60:	2209      	movs	r2, #9
 8002b62:	4b14      	ldr	r3, [pc, #80]	; (8002bb4 <vTraceInitObjectPropertyTable+0x54>)
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[3] = TRC_CFG_NTASK;
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4] = TRC_CFG_NISR;
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[5] = TRC_CFG_NTIMER;
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[6] = TRC_CFG_NEVENTGROUP;
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[7] = TRC_CFG_NSTREAMBUFFER;
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[8] = TRC_CFG_NMESSAGEBUFFER;
 8002b64:	2102      	movs	r1, #2
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = TRACE_NCLASSES;
 8002b66:	681b      	ldr	r3, [r3, #0]
 8002b68:	649a      	str	r2, [r3, #72]	; 0x48
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[0] = TRC_CFG_NQUEUE;
 8002b6a:	4a13      	ldr	r2, [pc, #76]	; (8002bb8 <vTraceInitObjectPropertyTable+0x58>)
 8002b6c:	651a      	str	r2, [r3, #80]	; 0x50
 8002b6e:	4a13      	ldr	r2, [pc, #76]	; (8002bbc <vTraceInitObjectPropertyTable+0x5c>)
 8002b70:	655a      	str	r2, [r3, #84]	; 0x54
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[8] = TRC_CFG_NMESSAGEBUFFER;
 8002b72:	2258      	movs	r2, #88	; 0x58
 8002b74:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[0] = TRC_CFG_NAME_LEN_QUEUE;
 8002b76:	4a12      	ldr	r2, [pc, #72]	; (8002bc0 <vTraceInitObjectPropertyTable+0x60>)
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[3] = TRC_CFG_NAME_LEN_TASK;
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[4] = TRC_CFG_NAME_LEN_ISR;
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[5] = TRC_CFG_NAME_LEN_TIMER;
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[6] = TRC_CFG_NAME_LEN_EVENTGROUP;
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[7] = TRC_CFG_NAME_LEN_STREAMBUFFER;
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[8] = TRC_CFG_NAME_LEN_MESSAGEBUFFER;
 8002b78:	310d      	adds	r1, #13
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[0] = TRC_CFG_NAME_LEN_QUEUE;
 8002b7a:	65da      	str	r2, [r3, #92]	; 0x5c
 8002b7c:	661a      	str	r2, [r3, #96]	; 0x60
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[8] = TRC_CFG_NAME_LEN_MESSAGEBUFFER;
 8002b7e:	2264      	movs	r2, #100	; 0x64
 8002b80:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0] = PropertyTableSizeQueue;
 8002b82:	4a10      	ldr	r2, [pc, #64]	; (8002bc4 <vTraceInitObjectPropertyTable+0x64>)
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3] = PropertyTableSizeTask;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[4] = PropertyTableSizeISR;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[5] = PropertyTableSizeTimer;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6] = PropertyTableSizeEventGroup;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[7] = PropertyTableSizeStreamBuffer;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[8] = PropertyTableSizeMessageBuffer;
 8002b84:	3104      	adds	r1, #4
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0] = PropertyTableSizeQueue;
 8002b86:	669a      	str	r2, [r3, #104]	; 0x68
 8002b88:	4a0f      	ldr	r2, [pc, #60]	; (8002bc8 <vTraceInitObjectPropertyTable+0x68>)
 8002b8a:	66da      	str	r2, [r3, #108]	; 0x6c
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[8] = PropertyTableSizeMessageBuffer;
 8002b8c:	2270      	movs	r2, #112	; 0x70
 8002b8e:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[0] = StartIndexQueue;
 8002b90:	2280      	movs	r2, #128	; 0x80
 8002b92:	03d2      	lsls	r2, r2, #15
 8002b94:	675a      	str	r2, [r3, #116]	; 0x74
 8002b96:	4a0d      	ldr	r2, [pc, #52]	; (8002bcc <vTraceInitObjectPropertyTable+0x6c>)
 8002b98:	490d      	ldr	r1, [pc, #52]	; (8002bd0 <vTraceInitObjectPropertyTable+0x70>)
 8002b9a:	679a      	str	r2, [r3, #120]	; 0x78
 8002b9c:	4a0d      	ldr	r2, [pc, #52]	; (8002bd4 <vTraceInitObjectPropertyTable+0x74>)
 8002b9e:	67da      	str	r2, [r3, #124]	; 0x7c
 8002ba0:	2280      	movs	r2, #128	; 0x80
 8002ba2:	5099      	str	r1, [r3, r2]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[3] = StartIndexTask;
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[4] = StartIndexISR;
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[5] = StartIndexTimer;
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[6] = StartIndexEventGroup;
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[7] = StartIndexStreamBuffer;
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[8] = StartIndexMessageBuffer;
 8002ba4:	2182      	movs	r1, #130	; 0x82
 8002ba6:	3204      	adds	r2, #4
 8002ba8:	0089      	lsls	r1, r1, #2
 8002baa:	5299      	strh	r1, [r3, r2]
	RecorderDataPtr->ObjectPropertyTable.ObjectPropertyTableSizeInBytes = TRACE_OBJECT_TABLE_SIZE;
 8002bac:	4a0a      	ldr	r2, [pc, #40]	; (8002bd8 <vTraceInitObjectPropertyTable+0x78>)
 8002bae:	64da      	str	r2, [r3, #76]	; 0x4c
}
 8002bb0:	4770      	bx	lr
 8002bb2:	46c0      	nop			; (mov r8, r8)
 8002bb4:	200033f4 	.word	0x200033f4
 8002bb8:	08020604 	.word	0x08020604
 8002bbc:	02020204 	.word	0x02020204
 8002bc0:	0f0f0f0f 	.word	0x0f0f0f0f
 8002bc4:	13101010 	.word	0x13101010
 8002bc8:	13131011 	.word	0x13131011
 8002bcc:	00c000a0 	.word	0x00c000a0
 8002bd0:	01e201bc 	.word	0x01e201bc
 8002bd4:	019c0158 	.word	0x019c0158
 8002bd8:	0000022e 	.word	0x0000022e

08002bdc <vTraceInitObjectHandleStack>:
/* Initialization of the handle mechanism, see e.g, prvTraceGetObjectHandle */
void vTraceInitObjectHandleStack()
{
	uint32_t i = 0;

	objectHandleStacks.indexOfNextAvailableHandle[0] = objectHandleStacks.lowestIndexOfClass[0] = 0;
 8002bdc:	2300      	movs	r3, #0
{
 8002bde:	b510      	push	{r4, lr}
	objectHandleStacks.indexOfNextAvailableHandle[0] = objectHandleStacks.lowestIndexOfClass[0] = 0;
 8002be0:	4c1c      	ldr	r4, [pc, #112]	; (8002c54 <vTraceInitObjectHandleStack+0x78>)
	objectHandleStacks.highestIndexOfClass[7] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) - 1;
	objectHandleStacks.highestIndexOfClass[8] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) + (TRC_CFG_NMESSAGEBUFFER) - 1;

	for (i = 0; i < TRACE_NCLASSES; i++)
	{
		objectHandleStacks.handleCountWaterMarksOfClass[i] = 0;
 8002be2:	2212      	movs	r2, #18
 8002be4:	0020      	movs	r0, r4
	objectHandleStacks.indexOfNextAvailableHandle[0] = objectHandleStacks.lowestIndexOfClass[0] = 0;
 8002be6:	8263      	strh	r3, [r4, #18]
 8002be8:	8023      	strh	r3, [r4, #0]
	objectHandleStacks.indexOfNextAvailableHandle[1] = objectHandleStacks.lowestIndexOfClass[1] = (TRC_CFG_NQUEUE);
 8002bea:	3304      	adds	r3, #4
 8002bec:	82a3      	strh	r3, [r4, #20]
 8002bee:	8063      	strh	r3, [r4, #2]
	objectHandleStacks.indexOfNextAvailableHandle[2] = objectHandleStacks.lowestIndexOfClass[2] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE);
 8002bf0:	3306      	adds	r3, #6
 8002bf2:	82e3      	strh	r3, [r4, #22]
 8002bf4:	80a3      	strh	r3, [r4, #4]
	objectHandleStacks.indexOfNextAvailableHandle[3] = objectHandleStacks.lowestIndexOfClass[3] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX);
 8002bf6:	3302      	adds	r3, #2
 8002bf8:	8323      	strh	r3, [r4, #24]
 8002bfa:	80e3      	strh	r3, [r4, #6]
	objectHandleStacks.indexOfNextAvailableHandle[4] = objectHandleStacks.lowestIndexOfClass[4] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK);
 8002bfc:	3308      	adds	r3, #8
 8002bfe:	8363      	strh	r3, [r4, #26]
 8002c00:	8123      	strh	r3, [r4, #8]
	objectHandleStacks.indexOfNextAvailableHandle[5] = objectHandleStacks.lowestIndexOfClass[5] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR);
 8002c02:	3304      	adds	r3, #4
 8002c04:	83a3      	strh	r3, [r4, #28]
 8002c06:	8163      	strh	r3, [r4, #10]
	objectHandleStacks.indexOfNextAvailableHandle[6] = objectHandleStacks.lowestIndexOfClass[6] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER);
 8002c08:	3302      	adds	r3, #2
 8002c0a:	83e3      	strh	r3, [r4, #30]
 8002c0c:	81a3      	strh	r3, [r4, #12]
	objectHandleStacks.indexOfNextAvailableHandle[7] = objectHandleStacks.lowestIndexOfClass[7] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP);
 8002c0e:	3302      	adds	r3, #2
 8002c10:	8423      	strh	r3, [r4, #32]
 8002c12:	81e3      	strh	r3, [r4, #14]
	objectHandleStacks.indexOfNextAvailableHandle[8] = objectHandleStacks.lowestIndexOfClass[8] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER);
 8002c14:	3302      	adds	r3, #2
 8002c16:	8463      	strh	r3, [r4, #34]	; 0x22
 8002c18:	8223      	strh	r3, [r4, #16]
	objectHandleStacks.highestIndexOfClass[0] = (TRC_CFG_NQUEUE) - 1;
 8002c1a:	3b1b      	subs	r3, #27
 8002c1c:	84a3      	strh	r3, [r4, #36]	; 0x24
	objectHandleStacks.highestIndexOfClass[1] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) - 1;
 8002c1e:	3306      	adds	r3, #6
 8002c20:	84e3      	strh	r3, [r4, #38]	; 0x26
	objectHandleStacks.highestIndexOfClass[2] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) - 1;
 8002c22:	3302      	adds	r3, #2
 8002c24:	8523      	strh	r3, [r4, #40]	; 0x28
	objectHandleStacks.highestIndexOfClass[3] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) - 1;
 8002c26:	3308      	adds	r3, #8
 8002c28:	8563      	strh	r3, [r4, #42]	; 0x2a
	objectHandleStacks.highestIndexOfClass[4] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) - 1;
 8002c2a:	3304      	adds	r3, #4
 8002c2c:	85a3      	strh	r3, [r4, #44]	; 0x2c
	objectHandleStacks.highestIndexOfClass[5] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) - 1;
 8002c2e:	3302      	adds	r3, #2
 8002c30:	85e3      	strh	r3, [r4, #46]	; 0x2e
	objectHandleStacks.highestIndexOfClass[6] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) - 1;
 8002c32:	3302      	adds	r3, #2
 8002c34:	8623      	strh	r3, [r4, #48]	; 0x30
	objectHandleStacks.highestIndexOfClass[7] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) - 1;
 8002c36:	3302      	adds	r3, #2
 8002c38:	8663      	strh	r3, [r4, #50]	; 0x32
	objectHandleStacks.highestIndexOfClass[8] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) + (TRC_CFG_NMESSAGEBUFFER) - 1;
 8002c3a:	3302      	adds	r3, #2
 8002c3c:	86a3      	strh	r3, [r4, #52]	; 0x34
		objectHandleStacks.handleCountWaterMarksOfClass[i] = 0;
 8002c3e:	2100      	movs	r1, #0
 8002c40:	3036      	adds	r0, #54	; 0x36
 8002c42:	f003 f875 	bl	8005d30 <memset>
	}

	for (i = 0; i < TRACE_KERNEL_OBJECT_COUNT; i++)
	{
		objectHandleStacks.objectHandles[i] = 0;
 8002c46:	0020      	movs	r0, r4
 8002c48:	2220      	movs	r2, #32
 8002c4a:	2100      	movs	r1, #0
 8002c4c:	3048      	adds	r0, #72	; 0x48
 8002c4e:	f003 f86f 	bl	8005d30 <memset>
	}
}
 8002c52:	bd10      	pop	{r4, pc}
 8002c54:	20003414 	.word	0x20003414

08002c58 <pszTraceGetErrorNotEnoughHandles>:

/* Returns the "Not enough handles" error message for this object class */
const char* pszTraceGetErrorNotEnoughHandles(traceObjectClass objectclass)
{
	switch(objectclass)
 8002c58:	2808      	cmp	r0, #8
 8002c5a:	d803      	bhi.n	8002c64 <pszTraceGetErrorNotEnoughHandles+0xc>
 8002c5c:	4b02      	ldr	r3, [pc, #8]	; (8002c68 <pszTraceGetErrorNotEnoughHandles+0x10>)
 8002c5e:	0080      	lsls	r0, r0, #2
 8002c60:	58c0      	ldr	r0, [r0, r3]
	case TRACE_CLASS_MESSAGEBUFFER:
		return "Not enough MESSAGEBUFFER handles - increase TRC_CFG_NMESSAGEBUFFER in trcSnapshotConfig.h";
	default:
		return "pszTraceGetErrorHandles: Invalid objectclass!";
	}
}
 8002c62:	4770      	bx	lr
{
 8002c64:	4801      	ldr	r0, [pc, #4]	; (8002c6c <pszTraceGetErrorNotEnoughHandles+0x14>)
 8002c66:	e7fc      	b.n	8002c62 <pszTraceGetErrorNotEnoughHandles+0xa>
 8002c68:	08006160 	.word	0x08006160
 8002c6c:	08005e60 	.word	0x08005e60

08002c70 <prvTraceGetDTS>:
 *
 * The parameter param_maxDTS should be 0xFF for 8-bit dts or 0xFFFF for
 * events with 16-bit dts fields.
 *****************************************************************************/
uint16_t prvTraceGetDTS(uint16_t param_maxDTS)
{
 8002c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c72:	4657      	mov	r7, sl
 8002c74:	46de      	mov	lr, fp
 8002c76:	464e      	mov	r6, r9
 8002c78:	4645      	mov	r5, r8
 8002c7a:	0004      	movs	r4, r0
 8002c7c:	b5e0      	push	{r5, r6, r7, lr}
	if (RecorderDataPtr != NULL)
 8002c7e:	4f89      	ldr	r7, [pc, #548]	; (8002ea4 <prvTraceGetDTS+0x234>)
	static uint32_t old_timestamp = 0;
	XTSEvent* xts = 0;
	uint32_t dts = 0;
	uint32_t timestamp = 0;

	TRACE_ASSERT(param_maxDTS == 0xFF || param_maxDTS == 0xFFFF, "prvTraceGetDTS: Invalid value for param_maxDTS", 0);
 8002c80:	28ff      	cmp	r0, #255	; 0xff
 8002c82:	d003      	beq.n	8002c8c <prvTraceGetDTS+0x1c>
 8002c84:	4b88      	ldr	r3, [pc, #544]	; (8002ea8 <prvTraceGetDTS+0x238>)
 8002c86:	4298      	cmp	r0, r3
 8002c88:	d000      	beq.n	8002c8c <prvTraceGetDTS+0x1c>
 8002c8a:	e0a3      	b.n	8002dd4 <prvTraceGetDTS+0x164>

	
	if (RecorderDataPtr->frequency == 0)
 8002c8c:	683e      	ldr	r6, [r7, #0]
 8002c8e:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8002c90:	2d00      	cmp	r5, #0
 8002c92:	d078      	beq.n	8002d86 <prvTraceGetDTS+0x116>
	static uint32_t last_hwtc_rest = 0;
	uint32_t diff = 0;
	uint32_t diff_scaled = 0;
#endif /*TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_OS_TIMER_DECR*/

	if (trace_disable_timestamp == 1)
 8002c94:	4b85      	ldr	r3, [pc, #532]	; (8002eac <prvTraceGetDTS+0x23c>)
 8002c96:	681b      	ldr	r3, [r3, #0]
 8002c98:	2b01      	cmp	r3, #1
 8002c9a:	d100      	bne.n	8002c9e <prvTraceGetDTS+0x2e>
 8002c9c:	e085      	b.n	8002daa <prvTraceGetDTS+0x13a>
	}
#endif

#if (TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_OS_TIMER_DECR)
	/* Timestamping is based on a timer that wraps at TRC_HWTC_PERIOD */
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8002c9e:	4a84      	ldr	r2, [pc, #528]	; (8002eb0 <prvTraceGetDTS+0x240>)
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8002ca0:	4b84      	ldr	r3, [pc, #528]	; (8002eb4 <prvTraceGetDTS+0x244>)
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8002ca2:	6812      	ldr	r2, [r2, #0]
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8002ca4:	6819      	ldr	r1, [r3, #0]
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8002ca6:	43d0      	mvns	r0, r2
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8002ca8:	4b83      	ldr	r3, [pc, #524]	; (8002eb8 <prvTraceGetDTS+0x248>)
 8002caa:	3101      	adds	r1, #1
 8002cac:	681b      	ldr	r3, [r3, #0]
 8002cae:	1ac9      	subs	r1, r1, r3
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8002cb0:	4b82      	ldr	r3, [pc, #520]	; (8002ebc <prvTraceGetDTS+0x24c>)
 8002cb2:	469b      	mov	fp, r3
 8002cb4:	681b      	ldr	r3, [r3, #0]
 8002cb6:	42d8      	cmn	r0, r3
 8002cb8:	d500      	bpl.n	8002cbc <prvTraceGetDTS+0x4c>
 8002cba:	e085      	b.n	8002dc8 <prvTraceGetDTS+0x158>
		traceTickCount = uiTraceTickCount;
	}

	/* Check for overflow. May occur if the update of uiTraceTickCount has been
	delayed due to disabled interrupts. */
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
 8002cbc:	4a80      	ldr	r2, [pc, #512]	; (8002ec0 <prvTraceGetDTS+0x250>)
 8002cbe:	4690      	mov	r8, r2
 8002cc0:	6812      	ldr	r2, [r2, #0]
	{
		/* A trace tick has occurred but not been executed by the kernel, so we compensate manually. */
		traceTickCount++;
 8002cc2:	4291      	cmp	r1, r2
 8002cc4:	4192      	sbcs	r2, r2
 8002cc6:	4252      	negs	r2, r2
 8002cc8:	189a      	adds	r2, r3, r2

	/* Check if the return address is OK, then we perform the calculation. */
	if (pTimestamp)
	{
		/* Get timestamp from trace ticks. Scale down the period to avoid unwanted overflows. */
		last_timestamp = traceTickCount * ((TRC_HWTC_PERIOD) / (TRC_HWTC_DIVISOR));
 8002cca:	4b7a      	ldr	r3, [pc, #488]	; (8002eb4 <prvTraceGetDTS+0x244>)
 8002ccc:	469a      	mov	sl, r3
 8002cce:	681b      	ldr	r3, [r3, #0]
 8002cd0:	3301      	adds	r3, #1
 8002cd2:	089b      	lsrs	r3, r3, #2
 8002cd4:	4353      	muls	r3, r2
 8002cd6:	4699      	mov	r9, r3
 8002cd8:	4648      	mov	r0, r9
 8002cda:	4b7a      	ldr	r3, [pc, #488]	; (8002ec4 <prvTraceGetDTS+0x254>)
 8002cdc:	6018      	str	r0, [r3, #0]
 8002cde:	469c      	mov	ip, r3
		/* Increase timestamp by (hwtc_count + "lost hardware ticks from scaling down period") / TRC_HWTC_DIVISOR. */
		last_timestamp += (hwtc_count + traceTickCount * ((TRC_HWTC_PERIOD) % (TRC_HWTC_DIVISOR))) / (TRC_HWTC_DIVISOR);
 8002ce0:	4653      	mov	r3, sl
 8002ce2:	681b      	ldr	r3, [r3, #0]
 8002ce4:	3301      	adds	r3, #1
 8002ce6:	469a      	mov	sl, r3
 8002ce8:	2303      	movs	r3, #3
 8002cea:	4650      	mov	r0, sl
 8002cec:	4003      	ands	r3, r0
 8002cee:	4660      	mov	r0, ip
 8002cf0:	4353      	muls	r3, r2
 8002cf2:	185b      	adds	r3, r3, r1
 8002cf4:	089b      	lsrs	r3, r3, #2
 8002cf6:	444b      	add	r3, r9
 8002cf8:	6003      	str	r3, [r0, #0]
	}
	/* Store the previous value */
	last_traceTickCount = traceTickCount;
 8002cfa:	4658      	mov	r0, fp
 8002cfc:	6002      	str	r2, [r0, #0]
	/* Is anyone interested in the results? */
	if (pTimestamp)
		*pTimestamp = last_timestamp;

	/* Store the previous value */
	last_hwtc_count = hwtc_count;
 8002cfe:	4642      	mov	r2, r8
 8002d00:	6011      	str	r1, [r2, #0]
	dts = timestamp - old_timestamp;
 8002d02:	4a71      	ldr	r2, [pc, #452]	; (8002ec8 <prvTraceGetDTS+0x258>)
 8002d04:	6810      	ldr	r0, [r2, #0]
	old_timestamp = timestamp;
 8002d06:	6013      	str	r3, [r2, #0]
	dts = timestamp - old_timestamp;
 8002d08:	1a19      	subs	r1, r3, r0
 8002d0a:	4688      	mov	r8, r1
	if (RecorderDataPtr->frequency > 0)
 8002d0c:	2d00      	cmp	r5, #0
 8002d0e:	d055      	beq.n	8002dbc <prvTraceGetDTS+0x14c>
		if (dts > RecorderDataPtr->frequency)
 8002d10:	42a9      	cmp	r1, r5
 8002d12:	d900      	bls.n	8002d16 <prvTraceGetDTS+0xa6>
 8002d14:	e073      	b.n	8002dfe <prvTraceGetDTS+0x18e>
			RecorderDataPtr->absTimeLastEvent += dts;
 8002d16:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8002d18:	4441      	add	r1, r8
 8002d1a:	62b1      	str	r1, [r6, #40]	; 0x28
		if (RecorderDataPtr->absTimeLastEvent >= RecorderDataPtr->frequency)
 8002d1c:	428d      	cmp	r5, r1
 8002d1e:	d84e      	bhi.n	8002dbe <prvTraceGetDTS+0x14e>
			RecorderDataPtr->absTimeLastEventSecond++;
 8002d20:	6af3      	ldr	r3, [r6, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent -= RecorderDataPtr->frequency;
 8002d22:	1b49      	subs	r1, r1, r5
			RecorderDataPtr->absTimeLastEventSecond++;
 8002d24:	3301      	adds	r3, #1
 8002d26:	62f3      	str	r3, [r6, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent -= RecorderDataPtr->frequency;
 8002d28:	62b1      	str	r1, [r6, #40]	; 0x28
	if (dts > param_maxDTS)
 8002d2a:	4544      	cmp	r4, r8
 8002d2c:	d249      	bcs.n	8002dc2 <prvTraceGetDTS+0x152>
	if (! RecorderDataPtr->recorderActive)
 8002d2e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002d30:	2b00      	cmp	r3, #0
 8002d32:	d046      	beq.n	8002dc2 <prvTraceGetDTS+0x152>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8002d34:	23fa      	movs	r3, #250	; 0xfa
 8002d36:	69f2      	ldr	r2, [r6, #28]
 8002d38:	009b      	lsls	r3, r3, #2
 8002d3a:	429a      	cmp	r2, r3
 8002d3c:	d300      	bcc.n	8002d40 <prvTraceGetDTS+0xd0>
 8002d3e:	e08b      	b.n	8002e58 <prvTraceGetDTS+0x1e8>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8002d40:	4962      	ldr	r1, [pc, #392]	; (8002ecc <prvTraceGetDTS+0x25c>)
 8002d42:	0093      	lsls	r3, r2, #2
 8002d44:	468c      	mov	ip, r1
			if (param_maxDTS == 0xFFFF)
 8002d46:	4958      	ldr	r1, [pc, #352]	; (8002ea8 <prvTraceGetDTS+0x238>)
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8002d48:	4463      	add	r3, ip
 8002d4a:	18f3      	adds	r3, r6, r3
			if (param_maxDTS == 0xFFFF)
 8002d4c:	428c      	cmp	r4, r1
 8002d4e:	d100      	bne.n	8002d52 <prvTraceGetDTS+0xe2>
 8002d50:	e07d      	b.n	8002e4e <prvTraceGetDTS+0x1de>
				xts->xts_16 = (uint16_t)((dts / 0x100) & 0xFFFF);
 8002d52:	4641      	mov	r1, r8
				xts->xts_8 = (uint8_t)((dts / 0x1000000) & 0xFF);
 8002d54:	4640      	mov	r0, r8
 8002d56:	25a8      	movs	r5, #168	; 0xa8
				xts->xts_16 = (uint16_t)((dts / 0x100) & 0xFFFF);
 8002d58:	0a09      	lsrs	r1, r1, #8
 8002d5a:	b289      	uxth	r1, r1
				xts->xts_8 = (uint8_t)((dts / 0x1000000) & 0xFF);
 8002d5c:	0e00      	lsrs	r0, r0, #24
				xts->type = XTS16;
 8002d5e:	701d      	strb	r5, [r3, #0]
				xts->xts_8 = 0;
 8002d60:	7058      	strb	r0, [r3, #1]
				xts->xts_16 = (uint16_t)((dts / 0x10000) & 0xFFFF);
 8002d62:	8059      	strh	r1, [r3, #2]
	RecorderDataPtr->numEvents++;
 8002d64:	6973      	ldr	r3, [r6, #20]
	RecorderDataPtr->nextFreeIndex++;
 8002d66:	3201      	adds	r2, #1
	RecorderDataPtr->numEvents++;
 8002d68:	3301      	adds	r3, #1
 8002d6a:	6173      	str	r3, [r6, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8002d6c:	23fa      	movs	r3, #250	; 0xfa
	RecorderDataPtr->nextFreeIndex++;
 8002d6e:	61f2      	str	r2, [r6, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8002d70:	009b      	lsls	r3, r3, #2
 8002d72:	429a      	cmp	r2, r3
 8002d74:	d125      	bne.n	8002dc2 <prvTraceGetDTS+0x152>
		RecorderDataPtr->recorderActive = 0;
 8002d76:	2300      	movs	r3, #0
 8002d78:	6333      	str	r3, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8002d7a:	4b55      	ldr	r3, [pc, #340]	; (8002ed0 <prvTraceGetDTS+0x260>)
 8002d7c:	681b      	ldr	r3, [r3, #0]
 8002d7e:	2b00      	cmp	r3, #0
 8002d80:	d01f      	beq.n	8002dc2 <prvTraceGetDTS+0x152>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8002d82:	4798      	blx	r3
 8002d84:	e01d      	b.n	8002dc2 <prvTraceGetDTS+0x152>
		if (timestampFrequency != 0)
 8002d86:	4b53      	ldr	r3, [pc, #332]	; (8002ed4 <prvTraceGetDTS+0x264>)
 8002d88:	681d      	ldr	r5, [r3, #0]
 8002d8a:	2d00      	cmp	r5, #0
 8002d8c:	d141      	bne.n	8002e12 <prvTraceGetDTS+0x1a2>
		else if (init_hwtc_count != (TRC_HWTC_COUNT))
 8002d8e:	4b4a      	ldr	r3, [pc, #296]	; (8002eb8 <prvTraceGetDTS+0x248>)
 8002d90:	681a      	ldr	r2, [r3, #0]
 8002d92:	4b51      	ldr	r3, [pc, #324]	; (8002ed8 <prvTraceGetDTS+0x268>)
 8002d94:	681b      	ldr	r3, [r3, #0]
 8002d96:	429a      	cmp	r2, r3
 8002d98:	d100      	bne.n	8002d9c <prvTraceGetDTS+0x12c>
 8002d9a:	e77b      	b.n	8002c94 <prvTraceGetDTS+0x24>
	if (trace_disable_timestamp == 1)
 8002d9c:	4b43      	ldr	r3, [pc, #268]	; (8002eac <prvTraceGetDTS+0x23c>)
			RecorderDataPtr->frequency = (TRC_HWTC_FREQ_HZ) / (TRC_HWTC_DIVISOR);		
 8002d9e:	4d4f      	ldr	r5, [pc, #316]	; (8002edc <prvTraceGetDTS+0x26c>)
	if (trace_disable_timestamp == 1)
 8002da0:	681b      	ldr	r3, [r3, #0]
			RecorderDataPtr->frequency = (TRC_HWTC_FREQ_HZ) / (TRC_HWTC_DIVISOR);		
 8002da2:	6275      	str	r5, [r6, #36]	; 0x24
	if (trace_disable_timestamp == 1)
 8002da4:	2b01      	cmp	r3, #1
 8002da6:	d000      	beq.n	8002daa <prvTraceGetDTS+0x13a>
 8002da8:	e779      	b.n	8002c9e <prvTraceGetDTS+0x2e>
	dts = timestamp - old_timestamp;
 8002daa:	4a47      	ldr	r2, [pc, #284]	; (8002ec8 <prvTraceGetDTS+0x258>)
			*pTimestamp = last_timestamp;
 8002dac:	4b45      	ldr	r3, [pc, #276]	; (8002ec4 <prvTraceGetDTS+0x254>)
	dts = timestamp - old_timestamp;
 8002dae:	6810      	ldr	r0, [r2, #0]
			*pTimestamp = last_timestamp;
 8002db0:	681b      	ldr	r3, [r3, #0]
	dts = timestamp - old_timestamp;
 8002db2:	1a19      	subs	r1, r3, r0
 8002db4:	4688      	mov	r8, r1
	old_timestamp = timestamp;
 8002db6:	6013      	str	r3, [r2, #0]
	if (RecorderDataPtr->frequency > 0)
 8002db8:	2d00      	cmp	r5, #0
 8002dba:	d1a9      	bne.n	8002d10 <prvTraceGetDTS+0xa0>
		RecorderDataPtr->absTimeLastEvent = timestamp;
 8002dbc:	62b3      	str	r3, [r6, #40]	; 0x28
	if (dts > param_maxDTS)
 8002dbe:	4544      	cmp	r4, r8
 8002dc0:	d3b5      	bcc.n	8002d2e <prvTraceGetDTS+0xbe>
	return (uint16_t)dts & param_maxDTS;
 8002dc2:	4640      	mov	r0, r8
 8002dc4:	4020      	ands	r0, r4
 8002dc6:	e014      	b.n	8002df2 <prvTraceGetDTS+0x182>
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
 8002dc8:	4293      	cmp	r3, r2
 8002dca:	d100      	bne.n	8002dce <prvTraceGetDTS+0x15e>
 8002dcc:	e776      	b.n	8002cbc <prvTraceGetDTS+0x4c>
 8002dce:	4b3c      	ldr	r3, [pc, #240]	; (8002ec0 <prvTraceGetDTS+0x250>)
 8002dd0:	4698      	mov	r8, r3
 8002dd2:	e77a      	b.n	8002cca <prvTraceGetDTS+0x5a>
	if (RecorderDataPtr != NULL)
 8002dd4:	683b      	ldr	r3, [r7, #0]
 8002dd6:	2b00      	cmp	r3, #0
 8002dd8:	d006      	beq.n	8002de8 <prvTraceGetDTS+0x178>
		RecorderDataPtr->recorderActive = 0;
 8002dda:	2200      	movs	r2, #0
 8002ddc:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8002dde:	4b3c      	ldr	r3, [pc, #240]	; (8002ed0 <prvTraceGetDTS+0x260>)
 8002de0:	681b      	ldr	r3, [r3, #0]
 8002de2:	2b00      	cmp	r3, #0
 8002de4:	d000      	beq.n	8002de8 <prvTraceGetDTS+0x178>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8002de6:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8002de8:	4b3d      	ldr	r3, [pc, #244]	; (8002ee0 <prvTraceGetDTS+0x270>)
 8002dea:	681a      	ldr	r2, [r3, #0]
 8002dec:	2a00      	cmp	r2, #0
 8002dee:	d013      	beq.n	8002e18 <prvTraceGetDTS+0x1a8>
	TRACE_ASSERT(param_maxDTS == 0xFF || param_maxDTS == 0xFFFF, "prvTraceGetDTS: Invalid value for param_maxDTS", 0);
 8002df0:	2000      	movs	r0, #0
}
 8002df2:	bcf0      	pop	{r4, r5, r6, r7}
 8002df4:	46bb      	mov	fp, r7
 8002df6:	46b2      	mov	sl, r6
 8002df8:	46a9      	mov	r9, r5
 8002dfa:	46a0      	mov	r8, r4
 8002dfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			RecorderDataPtr->absTimeLastEventSecond += dts / RecorderDataPtr->frequency;
 8002dfe:	0029      	movs	r1, r5
 8002e00:	4640      	mov	r0, r8
 8002e02:	f7fd fa07 	bl	8000214 <__aeabi_uidivmod>
 8002e06:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8002e08:	181b      	adds	r3, r3, r0
 8002e0a:	62f3      	str	r3, [r6, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent += dts % RecorderDataPtr->frequency;
 8002e0c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8002e0e:	18c9      	adds	r1, r1, r3
 8002e10:	e783      	b.n	8002d1a <prvTraceGetDTS+0xaa>
			RecorderDataPtr->frequency = timestampFrequency / (TRC_HWTC_DIVISOR);
 8002e12:	08ad      	lsrs	r5, r5, #2
 8002e14:	6275      	str	r5, [r6, #36]	; 0x24
 8002e16:	e73d      	b.n	8002c94 <prvTraceGetDTS+0x24>
		traceErrorMessage = (char*)(intptr_t) msg;
 8002e18:	4832      	ldr	r0, [pc, #200]	; (8002ee4 <prvTraceGetDTS+0x274>)
		if (RecorderDataPtr != NULL)
 8002e1a:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8002e1c:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8002e1e:	2900      	cmp	r1, #0
 8002e20:	d0e6      	beq.n	8002df0 <prvTraceGetDTS+0x180>
		dst[i] = src[i];
 8002e22:	23ce      	movs	r3, #206	; 0xce
 8002e24:	2254      	movs	r2, #84	; 0x54
 8002e26:	00db      	lsls	r3, r3, #3
 8002e28:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8002e2a:	4a2f      	ldr	r2, [pc, #188]	; (8002ee8 <prvTraceGetDTS+0x278>)
		dst[i] = src[i];
 8002e2c:	2300      	movs	r3, #0
 8002e2e:	4694      	mov	ip, r2
 8002e30:	3001      	adds	r0, #1
 8002e32:	4461      	add	r1, ip
 8002e34:	5cc2      	ldrb	r2, [r0, r3]
 8002e36:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8002e38:	3301      	adds	r3, #1
 8002e3a:	2a00      	cmp	r2, #0
 8002e3c:	d001      	beq.n	8002e42 <prvTraceGetDTS+0x1d2>
	for (i = 0; i < maxLength; i++)
 8002e3e:	2b4f      	cmp	r3, #79	; 0x4f
 8002e40:	d1f8      	bne.n	8002e34 <prvTraceGetDTS+0x1c4>
			RecorderDataPtr->internalErrorOccured = 1;
 8002e42:	23cd      	movs	r3, #205	; 0xcd
 8002e44:	2101      	movs	r1, #1
 8002e46:	683a      	ldr	r2, [r7, #0]
 8002e48:	00db      	lsls	r3, r3, #3
 8002e4a:	50d1      	str	r1, [r2, r3]
 8002e4c:	e7d0      	b.n	8002df0 <prvTraceGetDTS+0x180>
				xts->xts_16 = (uint16_t)((dts / 0x10000) & 0xFFFF);
 8002e4e:	4641      	mov	r1, r8
 8002e50:	25a9      	movs	r5, #169	; 0xa9
 8002e52:	2000      	movs	r0, #0
 8002e54:	0c09      	lsrs	r1, r1, #16
				xts->xts_8 = 0;
 8002e56:	e782      	b.n	8002d5e <prvTraceGetDTS+0xee>
		RecorderDataPtr->recorderActive = 0;
 8002e58:	2300      	movs	r3, #0
 8002e5a:	6333      	str	r3, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8002e5c:	4b1c      	ldr	r3, [pc, #112]	; (8002ed0 <prvTraceGetDTS+0x260>)
 8002e5e:	681b      	ldr	r3, [r3, #0]
 8002e60:	2b00      	cmp	r3, #0
 8002e62:	d000      	beq.n	8002e66 <prvTraceGetDTS+0x1f6>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8002e64:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8002e66:	4b1e      	ldr	r3, [pc, #120]	; (8002ee0 <prvTraceGetDTS+0x270>)
 8002e68:	681a      	ldr	r2, [r3, #0]
 8002e6a:	2a00      	cmp	r2, #0
 8002e6c:	d1a9      	bne.n	8002dc2 <prvTraceGetDTS+0x152>
		traceErrorMessage = (char*)(intptr_t) msg;
 8002e6e:	481f      	ldr	r0, [pc, #124]	; (8002eec <prvTraceGetDTS+0x27c>)
		if (RecorderDataPtr != NULL)
 8002e70:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8002e72:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8002e74:	2900      	cmp	r1, #0
 8002e76:	d0a4      	beq.n	8002dc2 <prvTraceGetDTS+0x152>
		dst[i] = src[i];
 8002e78:	23ce      	movs	r3, #206	; 0xce
 8002e7a:	3241      	adds	r2, #65	; 0x41
 8002e7c:	00db      	lsls	r3, r3, #3
 8002e7e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8002e80:	4a19      	ldr	r2, [pc, #100]	; (8002ee8 <prvTraceGetDTS+0x278>)
		dst[i] = src[i];
 8002e82:	2300      	movs	r3, #0
 8002e84:	4694      	mov	ip, r2
 8002e86:	3001      	adds	r0, #1
 8002e88:	4461      	add	r1, ip
 8002e8a:	5cc2      	ldrb	r2, [r0, r3]
 8002e8c:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8002e8e:	3301      	adds	r3, #1
 8002e90:	2a00      	cmp	r2, #0
 8002e92:	d001      	beq.n	8002e98 <prvTraceGetDTS+0x228>
	for (i = 0; i < maxLength; i++)
 8002e94:	2b4f      	cmp	r3, #79	; 0x4f
 8002e96:	d1f8      	bne.n	8002e8a <prvTraceGetDTS+0x21a>
			RecorderDataPtr->internalErrorOccured = 1;
 8002e98:	23cd      	movs	r3, #205	; 0xcd
 8002e9a:	2101      	movs	r1, #1
 8002e9c:	683a      	ldr	r2, [r7, #0]
 8002e9e:	00db      	lsls	r3, r3, #3
 8002ea0:	50d1      	str	r1, [r2, r3]
		if (xts != NULL)
 8002ea2:	e78e      	b.n	8002dc2 <prvTraceGetDTS+0x152>
 8002ea4:	200033f4 	.word	0x200033f4
 8002ea8:	0000ffff 	.word	0x0000ffff
 8002eac:	2000348c 	.word	0x2000348c
 8002eb0:	20003494 	.word	0x20003494
 8002eb4:	e000e014 	.word	0xe000e014
 8002eb8:	e000e018 	.word	0xe000e018
 8002ebc:	20003410 	.word	0x20003410
 8002ec0:	20003408 	.word	0x20003408
 8002ec4:	2000340c 	.word	0x2000340c
 8002ec8:	2000347c 	.word	0x2000347c
 8002ecc:	000006c4 	.word	0x000006c4
 8002ed0:	20003498 	.word	0x20003498
 8002ed4:	20003484 	.word	0x20003484
 8002ed8:	20003400 	.word	0x20003400
 8002edc:	00b71b00 	.word	0x00b71b00
 8002ee0:	20003488 	.word	0x20003488
 8002ee4:	08006184 	.word	0x08006184
 8002ee8:	00000671 	.word	0x00000671
 8002eec:	080061c4 	.word	0x080061c4

08002ef0 <prvTraceInitTimestamps>:
	init_hwtc_count = TRC_HWTC_COUNT;
 8002ef0:	4b02      	ldr	r3, [pc, #8]	; (8002efc <prvTraceInitTimestamps+0xc>)
 8002ef2:	681a      	ldr	r2, [r3, #0]
 8002ef4:	4b02      	ldr	r3, [pc, #8]	; (8002f00 <prvTraceInitTimestamps+0x10>)
 8002ef6:	601a      	str	r2, [r3, #0]
}
 8002ef8:	4770      	bx	lr
 8002efa:	46c0      	nop			; (mov r8, r8)
 8002efc:	e000e018 	.word	0xe000e018
 8002f00:	20003400 	.word	0x20003400

08002f04 <vTraceInitialize>:
{
 8002f04:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f06:	4646      	mov	r6, r8
 8002f08:	46d6      	mov	lr, sl
 8002f0a:	464f      	mov	r7, r9
 8002f0c:	b5c0      	push	{r6, r7, lr}
	if (RecorderInitialized != 0)
 8002f0e:	4e4b      	ldr	r6, [pc, #300]	; (800303c <vTraceInitialize+0x138>)
 8002f10:	6834      	ldr	r4, [r6, #0]
 8002f12:	2c00      	cmp	r4, #0
 8002f14:	d004      	beq.n	8002f20 <vTraceInitialize+0x1c>
}
 8002f16:	bce0      	pop	{r5, r6, r7}
 8002f18:	46ba      	mov	sl, r7
 8002f1a:	46b1      	mov	r9, r6
 8002f1c:	46a8      	mov	r8, r5
 8002f1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	CurrentFilterMask = 0xFFFF;
 8002f20:	2201      	movs	r2, #1
 8002f22:	4b47      	ldr	r3, [pc, #284]	; (8003040 <vTraceInitialize+0x13c>)
 8002f24:	4252      	negs	r2, r2
 8002f26:	801a      	strh	r2, [r3, #0]
	CurrentFilterGroup = FilterGroup0;
 8002f28:	4b46      	ldr	r3, [pc, #280]	; (8003044 <vTraceInitialize+0x140>)
 8002f2a:	3202      	adds	r2, #2
 8002f2c:	801a      	strh	r2, [r3, #0]
	RecorderDataPtr = &RecorderData;
 8002f2e:	4b46      	ldr	r3, [pc, #280]	; (8003048 <vTraceInitialize+0x144>)
 8002f30:	4d46      	ldr	r5, [pc, #280]	; (800304c <vTraceInitialize+0x148>)
 8002f32:	4698      	mov	r8, r3
 8002f34:	602b      	str	r3, [r5, #0]
	init_hwtc_count = TRC_HWTC_COUNT;
 8002f36:	4b46      	ldr	r3, [pc, #280]	; (8003050 <vTraceInitialize+0x14c>)
	CurrentFilterGroup = FilterGroup0;
 8002f38:	4691      	mov	r9, r2
	init_hwtc_count = TRC_HWTC_COUNT;
 8002f3a:	681a      	ldr	r2, [r3, #0]
 8002f3c:	4b45      	ldr	r3, [pc, #276]	; (8003054 <vTraceInitialize+0x150>)
	traceErrorMessage = 0;
 8002f3e:	4f46      	ldr	r7, [pc, #280]	; (8003058 <vTraceInitialize+0x154>)
	init_hwtc_count = TRC_HWTC_COUNT;
 8002f40:	601a      	str	r2, [r3, #0]
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
 8002f42:	4b46      	ldr	r3, [pc, #280]	; (800305c <vTraceInitialize+0x158>)
 8002f44:	2100      	movs	r1, #0
 8002f46:	001a      	movs	r2, r3
 8002f48:	4640      	mov	r0, r8
 8002f4a:	469a      	mov	sl, r3
	traceErrorMessage = 0;
 8002f4c:	603c      	str	r4, [r7, #0]
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
 8002f4e:	f002 feef 	bl	8005d30 <memset>
	RecorderDataPtr->version = TRACE_KERNEL_VERSION;
 8002f52:	4642      	mov	r2, r8
 8002f54:	4b42      	ldr	r3, [pc, #264]	; (8003060 <vTraceInitialize+0x15c>)
 8002f56:	8193      	strh	r3, [r2, #12]
	RecorderDataPtr->minor_version = TRACE_MINOR_VERSION;
 8002f58:	2307      	movs	r3, #7
 8002f5a:	7393      	strb	r3, [r2, #14]
	RecorderDataPtr->filesize = sizeof(RecorderDataType);
 8002f5c:	4643      	mov	r3, r8
 8002f5e:	4652      	mov	r2, sl
 8002f60:	611a      	str	r2, [r3, #16]
	RecorderDataPtr->maxEvents = (TRC_CFG_EVENT_BUFFER_SIZE);
 8002f62:	23fa      	movs	r3, #250	; 0xfa
 8002f64:	4642      	mov	r2, r8
 8002f66:	009b      	lsls	r3, r3, #2
 8002f68:	6193      	str	r3, [r2, #24]
	RecorderDataPtr->debugMarker0 = (int32_t)0xF0F0F0F0;
 8002f6a:	4b3e      	ldr	r3, [pc, #248]	; (8003064 <vTraceInitialize+0x160>)
 8002f6c:	6413      	str	r3, [r2, #64]	; 0x40
	vTraceInitObjectPropertyTable();
 8002f6e:	f7ff fdf7 	bl	8002b60 <vTraceInitObjectPropertyTable>
	RecorderDataPtr->debugMarker1 = (int32_t)0xF1F1F1F1;
 8002f72:	23ae      	movs	r3, #174	; 0xae
 8002f74:	6829      	ldr	r1, [r5, #0]
 8002f76:	4a3c      	ldr	r2, [pc, #240]	; (8003068 <vTraceInitialize+0x164>)
 8002f78:	009b      	lsls	r3, r3, #2
 8002f7a:	50ca      	str	r2, [r1, r3]
	RecorderDataPtr->SymbolTable.symTableSize = (TRC_CFG_SYMBOL_TABLE_SIZE);
 8002f7c:	22c8      	movs	r2, #200	; 0xc8
 8002f7e:	3304      	adds	r3, #4
 8002f80:	0092      	lsls	r2, r2, #2
 8002f82:	50ca      	str	r2, [r1, r3]
	RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1;
 8002f84:	464a      	mov	r2, r9
 8002f86:	3304      	adds	r3, #4
 8002f88:	50ca      	str	r2, [r1, r3]
	RecorderDataPtr->debugMarker2 = (int32_t)0xF2F2F2F2;
 8002f8a:	4b38      	ldr	r3, [pc, #224]	; (800306c <vTraceInitialize+0x168>)
 8002f8c:	4a38      	ldr	r2, [pc, #224]	; (8003070 <vTraceInitialize+0x16c>)
 8002f8e:	4839      	ldr	r0, [pc, #228]	; (8003074 <vTraceInitialize+0x170>)
 8002f90:	50ca      	str	r2, [r1, r3]
		dst[i] = src[i];
 8002f92:	2254      	movs	r2, #84	; 0x54
 8002f94:	3304      	adds	r3, #4
 8002f96:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8002f98:	4a37      	ldr	r2, [pc, #220]	; (8003078 <vTraceInitialize+0x174>)
		dst[i] = src[i];
 8002f9a:	2300      	movs	r3, #0
 8002f9c:	4694      	mov	ip, r2
 8002f9e:	4461      	add	r1, ip
 8002fa0:	5cc2      	ldrb	r2, [r0, r3]
 8002fa2:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8002fa4:	3301      	adds	r3, #1
 8002fa6:	2a00      	cmp	r2, #0
 8002fa8:	d001      	beq.n	8002fae <vTraceInitialize+0xaa>
	for (i = 0; i < maxLength; i++)
 8002faa:	2b4f      	cmp	r3, #79	; 0x4f
 8002fac:	d1f8      	bne.n	8002fa0 <vTraceInitialize+0x9c>
	RecorderDataPtr->debugMarker3 = (int32_t)0xF3F3F3F3;
 8002fae:	22d8      	movs	r2, #216	; 0xd8
 8002fb0:	682b      	ldr	r3, [r5, #0]
 8002fb2:	4932      	ldr	r1, [pc, #200]	; (800307c <vTraceInitialize+0x178>)
 8002fb4:	00d2      	lsls	r2, r2, #3
 8002fb6:	5099      	str	r1, [r3, r2]
	RecorderDataPtr->endmarker0 = 0x0A;
 8002fb8:	4a31      	ldr	r2, [pc, #196]	; (8003080 <vTraceInitialize+0x17c>)
 8002fba:	4932      	ldr	r1, [pc, #200]	; (8003084 <vTraceInitialize+0x180>)
 8002fbc:	5099      	str	r1, [r3, r2]
 8002fbe:	4a32      	ldr	r2, [pc, #200]	; (8003088 <vTraceInitialize+0x184>)
 8002fc0:	4932      	ldr	r1, [pc, #200]	; (800308c <vTraceInitialize+0x188>)
 8002fc2:	5099      	str	r1, [r3, r2]
 8002fc4:	4a32      	ldr	r2, [pc, #200]	; (8003090 <vTraceInitialize+0x18c>)
 8002fc6:	4933      	ldr	r1, [pc, #204]	; (8003094 <vTraceInitialize+0x190>)
 8002fc8:	5099      	str	r1, [r3, r2]
	vTraceInitObjectHandleStack();
 8002fca:	f7ff fe07 	bl	8002bdc <vTraceInitObjectHandleStack>
	RecorderDataPtr->startmarker11 = 0xF4;
 8002fce:	22f4      	movs	r2, #244	; 0xf4
 8002fd0:	682b      	ldr	r3, [r5, #0]
 8002fd2:	72da      	strb	r2, [r3, #11]
	RecorderDataPtr->startmarker10 = 0xF3;
 8002fd4:	3a01      	subs	r2, #1
 8002fd6:	729a      	strb	r2, [r3, #10]
	RecorderDataPtr->startmarker9 = 0xF2;
 8002fd8:	3a01      	subs	r2, #1
 8002fda:	725a      	strb	r2, [r3, #9]
	RecorderDataPtr->startmarker8 = 0xF1;
 8002fdc:	3a01      	subs	r2, #1
 8002fde:	721a      	strb	r2, [r3, #8]
	RecorderDataPtr->startmarker7 = 0x74;
 8002fe0:	3a7d      	subs	r2, #125	; 0x7d
 8002fe2:	71da      	strb	r2, [r3, #7]
	RecorderDataPtr->startmarker6 = 0x73;
 8002fe4:	3a01      	subs	r2, #1
 8002fe6:	719a      	strb	r2, [r3, #6]
	RecorderDataPtr->startmarker5 = 0x72;
 8002fe8:	3a01      	subs	r2, #1
 8002fea:	715a      	strb	r2, [r3, #5]
	RecorderDataPtr->startmarker4 = 0x71;
 8002fec:	3a01      	subs	r2, #1
 8002fee:	711a      	strb	r2, [r3, #4]
	RecorderDataPtr->startmarker3 = 0x04;
 8002ff0:	3a6d      	subs	r2, #109	; 0x6d
 8002ff2:	70da      	strb	r2, [r3, #3]
	RecorderDataPtr->startmarker2 = 0x03;
 8002ff4:	3a01      	subs	r2, #1
 8002ff6:	709a      	strb	r2, [r3, #2]
	RecorderDataPtr->startmarker1 = 0x02;
 8002ff8:	3a01      	subs	r2, #1
 8002ffa:	705a      	strb	r2, [r3, #1]
	RecorderDataPtr->startmarker0 = 0x01;
 8002ffc:	3a01      	subs	r2, #1
 8002ffe:	701a      	strb	r2, [r3, #0]
	if (traceErrorMessage != NULL)
 8003000:	22ce      	movs	r2, #206	; 0xce
 8003002:	00d2      	lsls	r2, r2, #3
 8003004:	4694      	mov	ip, r2
 8003006:	6839      	ldr	r1, [r7, #0]
 8003008:	4463      	add	r3, ip
 800300a:	2900      	cmp	r1, #0
 800300c:	d012      	beq.n	8003034 <vTraceInitialize+0x130>
		dst[i] = src[i];
 800300e:	5d0a      	ldrb	r2, [r1, r4]
 8003010:	551a      	strb	r2, [r3, r4]
		if (src[i] == 0)
 8003012:	2a00      	cmp	r2, #0
 8003014:	d002      	beq.n	800301c <vTraceInitialize+0x118>
	for (i = 0; i < maxLength; i++)
 8003016:	3401      	adds	r4, #1
 8003018:	2c50      	cmp	r4, #80	; 0x50
 800301a:	d1f8      	bne.n	800300e <vTraceInitialize+0x10a>
		RecorderDataPtr->internalErrorOccured = 1;
 800301c:	22cd      	movs	r2, #205	; 0xcd
 800301e:	2101      	movs	r1, #1
 8003020:	682b      	ldr	r3, [r5, #0]
 8003022:	00d2      	lsls	r2, r2, #3
 8003024:	5099      	str	r1, [r3, r2]
		RecorderDataPtr->recorderActive = 0;
 8003026:	2200      	movs	r2, #0
 8003028:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800302a:	4b1b      	ldr	r3, [pc, #108]	; (8003098 <vTraceInitialize+0x194>)
 800302c:	681b      	ldr	r3, [r3, #0]
 800302e:	2b00      	cmp	r3, #0
 8003030:	d000      	beq.n	8003034 <vTraceInitialize+0x130>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003032:	4798      	blx	r3
	RecorderInitialized = 1;
 8003034:	2301      	movs	r3, #1
 8003036:	6033      	str	r3, [r6, #0]
 8003038:	e76d      	b.n	8002f16 <vTraceInitialize+0x12>
 800303a:	46c0      	nop			; (mov r8, r8)
 800303c:	200033f8 	.word	0x200033f8
 8003040:	20001d7e 	.word	0x20001d7e
 8003044:	20001d7c 	.word	0x20001d7c
 8003048:	20001d80 	.word	0x20001d80
 800304c:	200033f4 	.word	0x200033f4
 8003050:	e000e018 	.word	0xe000e018
 8003054:	20003400 	.word	0x20003400
 8003058:	20003488 	.word	0x20003488
 800305c:	00001674 	.word	0x00001674
 8003060:	00001aa1 	.word	0x00001aa1
 8003064:	f0f0f0f0 	.word	0xf0f0f0f0
 8003068:	f1f1f1f1 	.word	0xf1f1f1f1
 800306c:	0000066c 	.word	0x0000066c
 8003070:	f2f2f2f2 	.word	0xf2f2f2f2
 8003074:	08006355 	.word	0x08006355
 8003078:	00000671 	.word	0x00000671
 800307c:	f3f3f3f3 	.word	0xf3f3f3f3
 8003080:	00001668 	.word	0x00001668
 8003084:	0d0c0b0a 	.word	0x0d0c0b0a
 8003088:	0000166c 	.word	0x0000166c
 800308c:	74737271 	.word	0x74737271
 8003090:	00001670 	.word	0x00001670
 8003094:	f4f3f2f1 	.word	0xf4f3f2f1
 8003098:	20003498 	.word	0x20003498

0800309c <prvTraceStoreTaskReady>:
{
 800309c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800309e:	46ce      	mov	lr, r9
 80030a0:	4647      	mov	r7, r8
 80030a2:	0004      	movs	r4, r0
 80030a4:	b580      	push	{r7, lr}
	if (handle == 0)
 80030a6:	2800      	cmp	r0, #0
 80030a8:	d01c      	beq.n	80030e4 <prvTraceStoreTaskReady+0x48>
	if (! readyEventsEnabled)
 80030aa:	4b5f      	ldr	r3, [pc, #380]	; (8003228 <prvTraceStoreTaskReady+0x18c>)
 80030ac:	681b      	ldr	r3, [r3, #0]
 80030ae:	2b00      	cmp	r3, #0
 80030b0:	d018      	beq.n	80030e4 <prvTraceStoreTaskReady+0x48>
	TRACE_ASSERT(handle <= (TRC_CFG_NTASK), "prvTraceStoreTaskReady: Invalid value for handle", TRC_UNUSED);
 80030b2:	2808      	cmp	r0, #8
 80030b4:	d840      	bhi.n	8003138 <prvTraceStoreTaskReady+0x9c>
	if (recorder_busy)
 80030b6:	4d5d      	ldr	r5, [pc, #372]	; (800322c <prvTraceStoreTaskReady+0x190>)
 80030b8:	682b      	ldr	r3, [r5, #0]
 80030ba:	4698      	mov	r8, r3
 80030bc:	2b00      	cmp	r3, #0
 80030be:	d165      	bne.n	800318c <prvTraceStoreTaskReady+0xf0>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80030c0:	f3ef 8710 	mrs	r7, PRIMASK
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80030c4:	2301      	movs	r3, #1
 80030c6:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
 80030ca:	682b      	ldr	r3, [r5, #0]
	if (RecorderDataPtr->recorderActive) /* Need to repeat this check! */
 80030cc:	4e58      	ldr	r6, [pc, #352]	; (8003230 <prvTraceStoreTaskReady+0x194>)
	trcCRITICAL_SECTION_BEGIN();
 80030ce:	3301      	adds	r3, #1
 80030d0:	602b      	str	r3, [r5, #0]
	if (RecorderDataPtr->recorderActive) /* Need to repeat this check! */
 80030d2:	6833      	ldr	r3, [r6, #0]
 80030d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80030d6:	2b00      	cmp	r3, #0
 80030d8:	d108      	bne.n	80030ec <prvTraceStoreTaskReady+0x50>
	trcCRITICAL_SECTION_END();
 80030da:	682b      	ldr	r3, [r5, #0]
 80030dc:	3b01      	subs	r3, #1
 80030de:	602b      	str	r3, [r5, #0]
 80030e0:	f387 8810 	msr	PRIMASK, r7
}
 80030e4:	bcc0      	pop	{r6, r7}
 80030e6:	46b9      	mov	r9, r7
 80030e8:	46b0      	mov	r8, r6
 80030ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80030ec:	4851      	ldr	r0, [pc, #324]	; (8003234 <prvTraceStoreTaskReady+0x198>)
 80030ee:	f7ff fdbf 	bl	8002c70 <prvTraceGetDTS>
	if (! RecorderDataPtr->recorderActive)
 80030f2:	6833      	ldr	r3, [r6, #0]
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80030f4:	4684      	mov	ip, r0
	if (! RecorderDataPtr->recorderActive)
 80030f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80030f8:	2a00      	cmp	r2, #0
 80030fa:	d0ee      	beq.n	80030da <prvTraceStoreTaskReady+0x3e>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80030fc:	20fa      	movs	r0, #250	; 0xfa
 80030fe:	69d9      	ldr	r1, [r3, #28]
 8003100:	0080      	lsls	r0, r0, #2
 8003102:	4281      	cmp	r1, r0
 8003104:	d267      	bcs.n	80031d6 <prvTraceStoreTaskReady+0x13a>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003106:	4e4c      	ldr	r6, [pc, #304]	; (8003238 <prvTraceStoreTaskReady+0x19c>)
 8003108:	008a      	lsls	r2, r1, #2
 800310a:	46b1      	mov	r9, r6
			tr->type = DIV_TASK_READY;
 800310c:	2602      	movs	r6, #2
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 800310e:	444a      	add	r2, r9
 8003110:	189a      	adds	r2, r3, r2
			tr->type = DIV_TASK_READY;
 8003112:	7016      	strb	r6, [r2, #0]
			tr->dts = dts3;
 8003114:	4666      	mov	r6, ip
			tr->objHandle = hnd8;
 8003116:	7054      	strb	r4, [r2, #1]
			tr->dts = dts3;
 8003118:	8056      	strh	r6, [r2, #2]
	RecorderDataPtr->numEvents++;
 800311a:	695a      	ldr	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 800311c:	3101      	adds	r1, #1
	RecorderDataPtr->numEvents++;
 800311e:	3201      	adds	r2, #1
 8003120:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003122:	61d9      	str	r1, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003124:	4281      	cmp	r1, r0
 8003126:	d1d8      	bne.n	80030da <prvTraceStoreTaskReady+0x3e>
		RecorderDataPtr->recorderActive = 0;
 8003128:	4642      	mov	r2, r8
 800312a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800312c:	4b43      	ldr	r3, [pc, #268]	; (800323c <prvTraceStoreTaskReady+0x1a0>)
 800312e:	681b      	ldr	r3, [r3, #0]
 8003130:	2b00      	cmp	r3, #0
 8003132:	d0d2      	beq.n	80030da <prvTraceStoreTaskReady+0x3e>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003134:	4798      	blx	r3
 8003136:	e7d0      	b.n	80030da <prvTraceStoreTaskReady+0x3e>
	if (RecorderDataPtr != NULL)
 8003138:	4e3d      	ldr	r6, [pc, #244]	; (8003230 <prvTraceStoreTaskReady+0x194>)
 800313a:	6833      	ldr	r3, [r6, #0]
 800313c:	2b00      	cmp	r3, #0
 800313e:	d006      	beq.n	800314e <prvTraceStoreTaskReady+0xb2>
		RecorderDataPtr->recorderActive = 0;
 8003140:	2200      	movs	r2, #0
 8003142:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003144:	4b3d      	ldr	r3, [pc, #244]	; (800323c <prvTraceStoreTaskReady+0x1a0>)
 8003146:	681b      	ldr	r3, [r3, #0]
 8003148:	2b00      	cmp	r3, #0
 800314a:	d000      	beq.n	800314e <prvTraceStoreTaskReady+0xb2>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800314c:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800314e:	4b3c      	ldr	r3, [pc, #240]	; (8003240 <prvTraceStoreTaskReady+0x1a4>)
 8003150:	681a      	ldr	r2, [r3, #0]
 8003152:	2a00      	cmp	r2, #0
 8003154:	d1c6      	bne.n	80030e4 <prvTraceStoreTaskReady+0x48>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003156:	483b      	ldr	r0, [pc, #236]	; (8003244 <prvTraceStoreTaskReady+0x1a8>)
		if (RecorderDataPtr != NULL)
 8003158:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800315a:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 800315c:	2900      	cmp	r1, #0
 800315e:	d0c1      	beq.n	80030e4 <prvTraceStoreTaskReady+0x48>
		dst[i] = src[i];
 8003160:	23ce      	movs	r3, #206	; 0xce
 8003162:	3254      	adds	r2, #84	; 0x54
 8003164:	00db      	lsls	r3, r3, #3
 8003166:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003168:	4a37      	ldr	r2, [pc, #220]	; (8003248 <prvTraceStoreTaskReady+0x1ac>)
		dst[i] = src[i];
 800316a:	2300      	movs	r3, #0
 800316c:	4694      	mov	ip, r2
 800316e:	3001      	adds	r0, #1
 8003170:	4461      	add	r1, ip
 8003172:	5cc2      	ldrb	r2, [r0, r3]
 8003174:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003176:	3301      	adds	r3, #1
 8003178:	2a00      	cmp	r2, #0
 800317a:	d001      	beq.n	8003180 <prvTraceStoreTaskReady+0xe4>
	for (i = 0; i < maxLength; i++)
 800317c:	2b4f      	cmp	r3, #79	; 0x4f
 800317e:	d1f8      	bne.n	8003172 <prvTraceStoreTaskReady+0xd6>
			RecorderDataPtr->internalErrorOccured = 1;
 8003180:	23cd      	movs	r3, #205	; 0xcd
 8003182:	2101      	movs	r1, #1
 8003184:	6832      	ldr	r2, [r6, #0]
 8003186:	00db      	lsls	r3, r3, #3
 8003188:	50d1      	str	r1, [r2, r3]
 800318a:	e7ab      	b.n	80030e4 <prvTraceStoreTaskReady+0x48>
	if (RecorderDataPtr != NULL)
 800318c:	4e28      	ldr	r6, [pc, #160]	; (8003230 <prvTraceStoreTaskReady+0x194>)
 800318e:	6833      	ldr	r3, [r6, #0]
 8003190:	2b00      	cmp	r3, #0
 8003192:	d006      	beq.n	80031a2 <prvTraceStoreTaskReady+0x106>
		RecorderDataPtr->recorderActive = 0;
 8003194:	2200      	movs	r2, #0
 8003196:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003198:	4b28      	ldr	r3, [pc, #160]	; (800323c <prvTraceStoreTaskReady+0x1a0>)
 800319a:	681b      	ldr	r3, [r3, #0]
 800319c:	2b00      	cmp	r3, #0
 800319e:	d000      	beq.n	80031a2 <prvTraceStoreTaskReady+0x106>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80031a0:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80031a2:	4b27      	ldr	r3, [pc, #156]	; (8003240 <prvTraceStoreTaskReady+0x1a4>)
 80031a4:	681a      	ldr	r2, [r3, #0]
 80031a6:	2a00      	cmp	r2, #0
 80031a8:	d19c      	bne.n	80030e4 <prvTraceStoreTaskReady+0x48>
		traceErrorMessage = (char*)(intptr_t) msg;
 80031aa:	4828      	ldr	r0, [pc, #160]	; (800324c <prvTraceStoreTaskReady+0x1b0>)
		if (RecorderDataPtr != NULL)
 80031ac:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80031ae:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80031b0:	2900      	cmp	r1, #0
 80031b2:	d097      	beq.n	80030e4 <prvTraceStoreTaskReady+0x48>
		dst[i] = src[i];
 80031b4:	23ce      	movs	r3, #206	; 0xce
 80031b6:	3252      	adds	r2, #82	; 0x52
 80031b8:	00db      	lsls	r3, r3, #3
 80031ba:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80031bc:	4a22      	ldr	r2, [pc, #136]	; (8003248 <prvTraceStoreTaskReady+0x1ac>)
		dst[i] = src[i];
 80031be:	2300      	movs	r3, #0
 80031c0:	4694      	mov	ip, r2
 80031c2:	3001      	adds	r0, #1
 80031c4:	4461      	add	r1, ip
 80031c6:	5cc2      	ldrb	r2, [r0, r3]
 80031c8:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80031ca:	3301      	adds	r3, #1
 80031cc:	2a00      	cmp	r2, #0
 80031ce:	d0d7      	beq.n	8003180 <prvTraceStoreTaskReady+0xe4>
	for (i = 0; i < maxLength; i++)
 80031d0:	2b4f      	cmp	r3, #79	; 0x4f
 80031d2:	d1f8      	bne.n	80031c6 <prvTraceStoreTaskReady+0x12a>
 80031d4:	e7d4      	b.n	8003180 <prvTraceStoreTaskReady+0xe4>
		RecorderDataPtr->recorderActive = 0;
 80031d6:	4642      	mov	r2, r8
 80031d8:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80031da:	4b18      	ldr	r3, [pc, #96]	; (800323c <prvTraceStoreTaskReady+0x1a0>)
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	2b00      	cmp	r3, #0
 80031e0:	d000      	beq.n	80031e4 <prvTraceStoreTaskReady+0x148>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80031e2:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80031e4:	4b16      	ldr	r3, [pc, #88]	; (8003240 <prvTraceStoreTaskReady+0x1a4>)
 80031e6:	681a      	ldr	r2, [r3, #0]
 80031e8:	2a00      	cmp	r2, #0
 80031ea:	d000      	beq.n	80031ee <prvTraceStoreTaskReady+0x152>
 80031ec:	e775      	b.n	80030da <prvTraceStoreTaskReady+0x3e>
		traceErrorMessage = (char*)(intptr_t) msg;
 80031ee:	4818      	ldr	r0, [pc, #96]	; (8003250 <prvTraceStoreTaskReady+0x1b4>)
		if (RecorderDataPtr != NULL)
 80031f0:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80031f2:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80031f4:	2900      	cmp	r1, #0
 80031f6:	d100      	bne.n	80031fa <prvTraceStoreTaskReady+0x15e>
 80031f8:	e76f      	b.n	80030da <prvTraceStoreTaskReady+0x3e>
		dst[i] = src[i];
 80031fa:	23ce      	movs	r3, #206	; 0xce
 80031fc:	3241      	adds	r2, #65	; 0x41
 80031fe:	00db      	lsls	r3, r3, #3
 8003200:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003202:	4a11      	ldr	r2, [pc, #68]	; (8003248 <prvTraceStoreTaskReady+0x1ac>)
		dst[i] = src[i];
 8003204:	2300      	movs	r3, #0
 8003206:	4694      	mov	ip, r2
 8003208:	3001      	adds	r0, #1
 800320a:	4461      	add	r1, ip
 800320c:	5cc2      	ldrb	r2, [r0, r3]
 800320e:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003210:	3301      	adds	r3, #1
 8003212:	2a00      	cmp	r2, #0
 8003214:	d001      	beq.n	800321a <prvTraceStoreTaskReady+0x17e>
	for (i = 0; i < maxLength; i++)
 8003216:	2b4f      	cmp	r3, #79	; 0x4f
 8003218:	d1f8      	bne.n	800320c <prvTraceStoreTaskReady+0x170>
			RecorderDataPtr->internalErrorOccured = 1;
 800321a:	23cd      	movs	r3, #205	; 0xcd
 800321c:	2101      	movs	r1, #1
 800321e:	6832      	ldr	r2, [r6, #0]
 8003220:	00db      	lsls	r3, r3, #3
 8003222:	50d1      	str	r1, [r2, r3]
		if (tr != NULL)
 8003224:	e759      	b.n	80030da <prvTraceStoreTaskReady+0x3e>
 8003226:	46c0      	nop			; (mov r8, r8)
 8003228:	20000010 	.word	0x20000010
 800322c:	20003480 	.word	0x20003480
 8003230:	200033f4 	.word	0x200033f4
 8003234:	0000ffff 	.word	0x0000ffff
 8003238:	000006c4 	.word	0x000006c4
 800323c:	20003498 	.word	0x20003498
 8003240:	20003488 	.word	0x20003488
 8003244:	08006368 	.word	0x08006368
 8003248:	00000671 	.word	0x00000671
 800324c:	080063a8 	.word	0x080063a8
 8003250:	080061c4 	.word	0x080061c4

08003254 <vTraceStoreMemMangEvent>:
{
 8003254:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003256:	464e      	mov	r6, r9
 8003258:	4645      	mov	r5, r8
 800325a:	46de      	mov	lr, fp
 800325c:	4657      	mov	r7, sl
 800325e:	b5e0      	push	{r5, r6, r7, lr}
	if (RecorderDataPtr == NULL)
 8003260:	4eca      	ldr	r6, [pc, #808]	; (800358c <vTraceStoreMemMangEvent+0x338>)
{
 8003262:	4680      	mov	r8, r0
	if (RecorderDataPtr == NULL)
 8003264:	6833      	ldr	r3, [r6, #0]
{
 8003266:	000c      	movs	r4, r1
 8003268:	b083      	sub	sp, #12
	if (RecorderDataPtr == NULL)
 800326a:	2b00      	cmp	r3, #0
 800326c:	d017      	beq.n	800329e <vTraceStoreMemMangEvent+0x4a>
		size = (uint32_t)(- signed_size);
 800326e:	17d3      	asrs	r3, r2, #31
 8003270:	18d1      	adds	r1, r2, r3
 8003272:	4059      	eors	r1, r3
 8003274:	4689      	mov	r9, r1
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003276:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800327a:	2301      	movs	r3, #1
 800327c:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
 8003280:	4dc3      	ldr	r5, [pc, #780]	; (8003590 <vTraceStoreMemMangEvent+0x33c>)
 8003282:	682b      	ldr	r3, [r5, #0]
 8003284:	3301      	adds	r3, #1
 8003286:	602b      	str	r3, [r5, #0]
		RecorderDataPtr->heapMemUsage += (uint32_t)signed_size;
 8003288:	6833      	ldr	r3, [r6, #0]
	if (address != 0)
 800328a:	2c00      	cmp	r4, #0
 800328c:	d10e      	bne.n	80032ac <vTraceStoreMemMangEvent+0x58>
	if (RecorderDataPtr->recorderActive)
 800328e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003290:	2b00      	cmp	r3, #0
 8003292:	d115      	bne.n	80032c0 <vTraceStoreMemMangEvent+0x6c>
	trcCRITICAL_SECTION_END();
 8003294:	682b      	ldr	r3, [r5, #0]
 8003296:	3b01      	subs	r3, #1
 8003298:	602b      	str	r3, [r5, #0]
 800329a:	f387 8810 	msr	PRIMASK, r7
}
 800329e:	b003      	add	sp, #12
 80032a0:	bcf0      	pop	{r4, r5, r6, r7}
 80032a2:	46bb      	mov	fp, r7
 80032a4:	46b2      	mov	sl, r6
 80032a6:	46a9      	mov	r9, r5
 80032a8:	46a0      	mov	r8, r4
 80032aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		RecorderDataPtr->heapMemUsage += (uint32_t)signed_size;
 80032ac:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80032ae:	1852      	adds	r2, r2, r1
		if (RecorderDataPtr->heapMemUsage > RecorderDataPtr->heapMemMaxUsage)
 80032b0:	6b99      	ldr	r1, [r3, #56]	; 0x38
		RecorderDataPtr->heapMemUsage += (uint32_t)signed_size;
 80032b2:	63da      	str	r2, [r3, #60]	; 0x3c
		if (RecorderDataPtr->heapMemUsage > RecorderDataPtr->heapMemMaxUsage)
 80032b4:	428a      	cmp	r2, r1
 80032b6:	d9ea      	bls.n	800328e <vTraceStoreMemMangEvent+0x3a>
			RecorderDataPtr->heapMemMaxUsage = RecorderDataPtr->heapMemUsage;
 80032b8:	639a      	str	r2, [r3, #56]	; 0x38
	if (RecorderDataPtr->recorderActive)
 80032ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80032bc:	2b00      	cmp	r3, #0
 80032be:	d0e9      	beq.n	8003294 <vTraceStoreMemMangEvent+0x40>
		dts1 = (uint8_t)prvTraceGetDTS(0xFF);
 80032c0:	20ff      	movs	r0, #255	; 0xff
 80032c2:	f7ff fcd5 	bl	8002c70 <prvTraceGetDTS>
	if (param <= param_max)
 80032c6:	2380      	movs	r3, #128	; 0x80
		dts1 = (uint8_t)prvTraceGetDTS(0xFF);
 80032c8:	4683      	mov	fp, r0
	if (! RecorderDataPtr->recorderActive)
 80032ca:	6832      	ldr	r2, [r6, #0]
	if (param <= param_max)
 80032cc:	025b      	lsls	r3, r3, #9
 80032ce:	4599      	cmp	r9, r3
 80032d0:	d25f      	bcs.n	8003392 <vTraceStoreMemMangEvent+0x13e>
	if (! RecorderDataPtr->recorderActive)
 80032d2:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80032d4:	9301      	str	r3, [sp, #4]
 80032d6:	9b01      	ldr	r3, [sp, #4]
 80032d8:	2b00      	cmp	r3, #0
 80032da:	d0db      	beq.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80032dc:	21fa      	movs	r1, #250	; 0xfa
 80032de:	69d3      	ldr	r3, [r2, #28]
 80032e0:	0089      	lsls	r1, r1, #2
 80032e2:	428b      	cmp	r3, r1
 80032e4:	d300      	bcc.n	80032e8 <vTraceStoreMemMangEvent+0x94>
 80032e6:	e0b1      	b.n	800344c <vTraceStoreMemMangEvent+0x1f8>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80032e8:	0099      	lsls	r1, r3, #2
 80032ea:	468a      	mov	sl, r1
 80032ec:	49a9      	ldr	r1, [pc, #676]	; (8003594 <vTraceStoreMemMangEvent+0x340>)
			ms->dts = dts1;
 80032ee:	4658      	mov	r0, fp
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80032f0:	468c      	mov	ip, r1
 80032f2:	44e2      	add	sl, ip
 80032f4:	4492      	add	sl, r2
			ms->dts = dts1;
 80032f6:	4651      	mov	r1, sl
 80032f8:	7048      	strb	r0, [r1, #1]
			ms->type = NULL_EVENT; /* Updated when all events are written */
 80032fa:	2100      	movs	r1, #0
 80032fc:	468c      	mov	ip, r1
 80032fe:	4651      	mov	r1, sl
 8003300:	4660      	mov	r0, ip
 8003302:	7008      	strb	r0, [r1, #0]
			ms->size = size_low;
 8003304:	4648      	mov	r0, r9
 8003306:	8048      	strh	r0, [r1, #2]
	RecorderDataPtr->numEvents++;
 8003308:	6951      	ldr	r1, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 800330a:	3301      	adds	r3, #1
	RecorderDataPtr->numEvents++;
 800330c:	4689      	mov	r9, r1
 800330e:	2101      	movs	r1, #1
 8003310:	468b      	mov	fp, r1
 8003312:	44d9      	add	r9, fp
 8003314:	4649      	mov	r1, r9
 8003316:	6151      	str	r1, [r2, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003318:	21fa      	movs	r1, #250	; 0xfa
	RecorderDataPtr->nextFreeIndex++;
 800331a:	61d3      	str	r3, [r2, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800331c:	0089      	lsls	r1, r1, #2
 800331e:	428b      	cmp	r3, r1
 8003320:	d164      	bne.n	80033ec <vTraceStoreMemMangEvent+0x198>
		RecorderDataPtr->recorderActive = 0;
 8003322:	4663      	mov	r3, ip
 8003324:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003326:	4b9c      	ldr	r3, [pc, #624]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 8003328:	681b      	ldr	r3, [r3, #0]
 800332a:	2b00      	cmp	r3, #0
 800332c:	d0b2      	beq.n	8003294 <vTraceStoreMemMangEvent+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800332e:	4798      	blx	r3
	if (param <= param_max)
 8003330:	2380      	movs	r3, #128	; 0x80
	if (! RecorderDataPtr->recorderActive)
 8003332:	6832      	ldr	r2, [r6, #0]
	if (param <= param_max)
 8003334:	025b      	lsls	r3, r3, #9
 8003336:	429c      	cmp	r4, r3
 8003338:	d25e      	bcs.n	80033f8 <vTraceStoreMemMangEvent+0x1a4>
	if (! RecorderDataPtr->recorderActive)
 800333a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800333c:	9301      	str	r3, [sp, #4]
 800333e:	9b01      	ldr	r3, [sp, #4]
				addr_low = (uint16_t)prvTraceGetParam(0xFFFF, address);
 8003340:	b2a4      	uxth	r4, r4
	if (! RecorderDataPtr->recorderActive)
 8003342:	2b00      	cmp	r3, #0
 8003344:	d0a6      	beq.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003346:	21fa      	movs	r1, #250	; 0xfa
 8003348:	69d3      	ldr	r3, [r2, #28]
 800334a:	0089      	lsls	r1, r1, #2
 800334c:	428b      	cmp	r3, r1
 800334e:	d300      	bcc.n	8003352 <vTraceStoreMemMangEvent+0xfe>
 8003350:	e0a4      	b.n	800349c <vTraceStoreMemMangEvent+0x248>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003352:	4890      	ldr	r0, [pc, #576]	; (8003594 <vTraceStoreMemMangEvent+0x340>)
 8003354:	0099      	lsls	r1, r3, #2
 8003356:	4684      	mov	ip, r0
 8003358:	4461      	add	r1, ip
 800335a:	1851      	adds	r1, r2, r1
				ma->addr_low = addr_low;
 800335c:	804c      	strh	r4, [r1, #2]
				ma->type = (uint8_t) (ecode  + 1);	/* Note this! */
 800335e:	4644      	mov	r4, r8
				ma->addr_high = addr_high;
 8003360:	2000      	movs	r0, #0
				ma->type = (uint8_t) (ecode  + 1);	/* Note this! */
 8003362:	b2e6      	uxtb	r6, r4
 8003364:	1c74      	adds	r4, r6, #1
 8003366:	700c      	strb	r4, [r1, #0]
				ma->addr_high = addr_high;
 8003368:	7048      	strb	r0, [r1, #1]
				ms->type = (uint8_t) ecode;			/* Set type of first event */
 800336a:	4651      	mov	r1, sl
 800336c:	700e      	strb	r6, [r1, #0]
	RecorderDataPtr->numEvents++;
 800336e:	6951      	ldr	r1, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003370:	3301      	adds	r3, #1
	RecorderDataPtr->numEvents++;
 8003372:	3101      	adds	r1, #1
 8003374:	6151      	str	r1, [r2, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003376:	21fa      	movs	r1, #250	; 0xfa
	RecorderDataPtr->nextFreeIndex++;
 8003378:	61d3      	str	r3, [r2, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800337a:	0089      	lsls	r1, r1, #2
 800337c:	428b      	cmp	r3, r1
 800337e:	d000      	beq.n	8003382 <vTraceStoreMemMangEvent+0x12e>
 8003380:	e788      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003382:	4b85      	ldr	r3, [pc, #532]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
		RecorderDataPtr->recorderActive = 0;
 8003384:	6310      	str	r0, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003386:	681b      	ldr	r3, [r3, #0]
 8003388:	2b00      	cmp	r3, #0
 800338a:	d100      	bne.n	800338e <vTraceStoreMemMangEvent+0x13a>
 800338c:	e782      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800338e:	4798      	blx	r3
 8003390:	e780      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (! RecorderDataPtr->recorderActive)
 8003392:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003394:	9301      	str	r3, [sp, #4]
 8003396:	2b00      	cmp	r3, #0
 8003398:	d100      	bne.n	800339c <vTraceStoreMemMangEvent+0x148>
 800339a:	e77b      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800339c:	21fa      	movs	r1, #250	; 0xfa
 800339e:	69d3      	ldr	r3, [r2, #28]
 80033a0:	0089      	lsls	r1, r1, #2
 80033a2:	468c      	mov	ip, r1
 80033a4:	428b      	cmp	r3, r1
 80033a6:	d300      	bcc.n	80033aa <vTraceStoreMemMangEvent+0x156>
 80033a8:	e09b      	b.n	80034e2 <vTraceStoreMemMangEvent+0x28e>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80033aa:	497a      	ldr	r1, [pc, #488]	; (8003594 <vTraceStoreMemMangEvent+0x340>)
 80033ac:	0098      	lsls	r0, r3, #2
 80033ae:	468a      	mov	sl, r1
			xps->type = DIV_XPS;
 80033b0:	2101      	movs	r1, #1
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80033b2:	4450      	add	r0, sl
 80033b4:	1810      	adds	r0, r2, r0
			xps->type = DIV_XPS;
 80033b6:	8001      	strh	r1, [r0, #0]
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
 80033b8:	4649      	mov	r1, r9
 80033ba:	0c09      	lsrs	r1, r1, #16
 80033bc:	8041      	strh	r1, [r0, #2]
	RecorderDataPtr->numEvents++;
 80033be:	6950      	ldr	r0, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 80033c0:	3301      	adds	r3, #1
	RecorderDataPtr->numEvents++;
 80033c2:	3001      	adds	r0, #1
 80033c4:	6150      	str	r0, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 80033c6:	61d3      	str	r3, [r2, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80033c8:	4563      	cmp	r3, ip
 80033ca:	d10a      	bne.n	80033e2 <vTraceStoreMemMangEvent+0x18e>
		RecorderDataPtr->recorderActive = 0;
 80033cc:	2300      	movs	r3, #0
 80033ce:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80033d0:	4b71      	ldr	r3, [pc, #452]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 80033d2:	681b      	ldr	r3, [r3, #0]
 80033d4:	2b00      	cmp	r3, #0
 80033d6:	d100      	bne.n	80033da <vTraceStoreMemMangEvent+0x186>
 80033d8:	e75c      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80033da:	4798      	blx	r3
	if (! RecorderDataPtr->recorderActive)
 80033dc:	6832      	ldr	r2, [r6, #0]
 80033de:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80033e0:	9301      	str	r3, [sp, #4]
		return param & param_max;
 80033e2:	464b      	mov	r3, r9
 80033e4:	041b      	lsls	r3, r3, #16
 80033e6:	0c1b      	lsrs	r3, r3, #16
 80033e8:	4699      	mov	r9, r3
 80033ea:	e774      	b.n	80032d6 <vTraceStoreMemMangEvent+0x82>
	if (param <= param_max)
 80033ec:	2080      	movs	r0, #128	; 0x80
 80033ee:	0240      	lsls	r0, r0, #9
 80033f0:	4284      	cmp	r4, r0
 80033f2:	d206      	bcs.n	8003402 <vTraceStoreMemMangEvent+0x1ae>
				addr_low = (uint16_t)prvTraceGetParam(0xFFFF, address);
 80033f4:	b2a4      	uxth	r4, r4
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80033f6:	e7ac      	b.n	8003352 <vTraceStoreMemMangEvent+0xfe>
	if (! RecorderDataPtr->recorderActive)
 80033f8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80033fa:	9301      	str	r3, [sp, #4]
 80033fc:	2b00      	cmp	r3, #0
 80033fe:	d100      	bne.n	8003402 <vTraceStoreMemMangEvent+0x1ae>
 8003400:	e748      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003402:	21fa      	movs	r1, #250	; 0xfa
 8003404:	69d3      	ldr	r3, [r2, #28]
 8003406:	0089      	lsls	r1, r1, #2
 8003408:	468c      	mov	ip, r1
 800340a:	428b      	cmp	r3, r1
 800340c:	d300      	bcc.n	8003410 <vTraceStoreMemMangEvent+0x1bc>
 800340e:	e092      	b.n	8003536 <vTraceStoreMemMangEvent+0x2e2>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003410:	4960      	ldr	r1, [pc, #384]	; (8003594 <vTraceStoreMemMangEvent+0x340>)
 8003412:	0098      	lsls	r0, r3, #2
 8003414:	4689      	mov	r9, r1
			xps->type = DIV_XPS;
 8003416:	2101      	movs	r1, #1
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003418:	4448      	add	r0, r9
 800341a:	1810      	adds	r0, r2, r0
			xps->type = DIV_XPS;
 800341c:	8001      	strh	r1, [r0, #0]
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
 800341e:	0c21      	lsrs	r1, r4, #16
 8003420:	8041      	strh	r1, [r0, #2]
	RecorderDataPtr->numEvents++;
 8003422:	6950      	ldr	r0, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003424:	3301      	adds	r3, #1
	RecorderDataPtr->numEvents++;
 8003426:	3001      	adds	r0, #1
 8003428:	6150      	str	r0, [r2, #20]
	RecorderDataPtr->nextFreeIndex++;
 800342a:	61d3      	str	r3, [r2, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800342c:	4563      	cmp	r3, ip
 800342e:	d10a      	bne.n	8003446 <vTraceStoreMemMangEvent+0x1f2>
		RecorderDataPtr->recorderActive = 0;
 8003430:	2300      	movs	r3, #0
 8003432:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003434:	4b58      	ldr	r3, [pc, #352]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 8003436:	681b      	ldr	r3, [r3, #0]
 8003438:	2b00      	cmp	r3, #0
 800343a:	d100      	bne.n	800343e <vTraceStoreMemMangEvent+0x1ea>
 800343c:	e72a      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800343e:	4798      	blx	r3
	if (! RecorderDataPtr->recorderActive)
 8003440:	6832      	ldr	r2, [r6, #0]
 8003442:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003444:	9301      	str	r3, [sp, #4]
		return param & param_max;
 8003446:	0424      	lsls	r4, r4, #16
 8003448:	0c24      	lsrs	r4, r4, #16
 800344a:	e778      	b.n	800333e <vTraceStoreMemMangEvent+0xea>
		RecorderDataPtr->recorderActive = 0;
 800344c:	2300      	movs	r3, #0
 800344e:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003450:	4b51      	ldr	r3, [pc, #324]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 8003452:	681b      	ldr	r3, [r3, #0]
 8003454:	2b00      	cmp	r3, #0
 8003456:	d000      	beq.n	800345a <vTraceStoreMemMangEvent+0x206>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003458:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800345a:	4b50      	ldr	r3, [pc, #320]	; (800359c <vTraceStoreMemMangEvent+0x348>)
 800345c:	681a      	ldr	r2, [r3, #0]
 800345e:	2a00      	cmp	r2, #0
 8003460:	d000      	beq.n	8003464 <vTraceStoreMemMangEvent+0x210>
 8003462:	e717      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003464:	494e      	ldr	r1, [pc, #312]	; (80035a0 <vTraceStoreMemMangEvent+0x34c>)
		if (RecorderDataPtr != NULL)
 8003466:	6830      	ldr	r0, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003468:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 800346a:	2800      	cmp	r0, #0
 800346c:	d100      	bne.n	8003470 <vTraceStoreMemMangEvent+0x21c>
 800346e:	e711      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		dst[i] = src[i];
 8003470:	23ce      	movs	r3, #206	; 0xce
 8003472:	3241      	adds	r2, #65	; 0x41
 8003474:	00db      	lsls	r3, r3, #3
 8003476:	54c2      	strb	r2, [r0, r3]
	for (i = 0; i < maxLength; i++)
 8003478:	4a4a      	ldr	r2, [pc, #296]	; (80035a4 <vTraceStoreMemMangEvent+0x350>)
		dst[i] = src[i];
 800347a:	2300      	movs	r3, #0
 800347c:	4694      	mov	ip, r2
 800347e:	3101      	adds	r1, #1
 8003480:	4460      	add	r0, ip
 8003482:	5cca      	ldrb	r2, [r1, r3]
 8003484:	54c2      	strb	r2, [r0, r3]
		if (src[i] == 0)
 8003486:	3301      	adds	r3, #1
 8003488:	2a00      	cmp	r2, #0
 800348a:	d001      	beq.n	8003490 <vTraceStoreMemMangEvent+0x23c>
	for (i = 0; i < maxLength; i++)
 800348c:	2b4f      	cmp	r3, #79	; 0x4f
 800348e:	d1f8      	bne.n	8003482 <vTraceStoreMemMangEvent+0x22e>
			RecorderDataPtr->internalErrorOccured = 1;
 8003490:	23cd      	movs	r3, #205	; 0xcd
 8003492:	2101      	movs	r1, #1
 8003494:	6832      	ldr	r2, [r6, #0]
 8003496:	00db      	lsls	r3, r3, #3
 8003498:	50d1      	str	r1, [r2, r3]
			if (ma != NULL)
 800349a:	e6fb      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		RecorderDataPtr->recorderActive = 0;
 800349c:	2300      	movs	r3, #0
 800349e:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80034a0:	4b3d      	ldr	r3, [pc, #244]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 80034a2:	681b      	ldr	r3, [r3, #0]
 80034a4:	2b00      	cmp	r3, #0
 80034a6:	d000      	beq.n	80034aa <vTraceStoreMemMangEvent+0x256>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80034a8:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80034aa:	4b3c      	ldr	r3, [pc, #240]	; (800359c <vTraceStoreMemMangEvent+0x348>)
 80034ac:	681a      	ldr	r2, [r3, #0]
 80034ae:	2a00      	cmp	r2, #0
 80034b0:	d000      	beq.n	80034b4 <vTraceStoreMemMangEvent+0x260>
 80034b2:	e6ef      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		traceErrorMessage = (char*)(intptr_t) msg;
 80034b4:	493a      	ldr	r1, [pc, #232]	; (80035a0 <vTraceStoreMemMangEvent+0x34c>)
		if (RecorderDataPtr != NULL)
 80034b6:	6830      	ldr	r0, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80034b8:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 80034ba:	2800      	cmp	r0, #0
 80034bc:	d100      	bne.n	80034c0 <vTraceStoreMemMangEvent+0x26c>
 80034be:	e6e9      	b.n	8003294 <vTraceStoreMemMangEvent+0x40>
		dst[i] = src[i];
 80034c0:	23ce      	movs	r3, #206	; 0xce
 80034c2:	3241      	adds	r2, #65	; 0x41
 80034c4:	00db      	lsls	r3, r3, #3
 80034c6:	54c2      	strb	r2, [r0, r3]
	for (i = 0; i < maxLength; i++)
 80034c8:	4a36      	ldr	r2, [pc, #216]	; (80035a4 <vTraceStoreMemMangEvent+0x350>)
		dst[i] = src[i];
 80034ca:	2300      	movs	r3, #0
 80034cc:	4694      	mov	ip, r2
 80034ce:	3101      	adds	r1, #1
 80034d0:	4460      	add	r0, ip
 80034d2:	5cca      	ldrb	r2, [r1, r3]
 80034d4:	54c2      	strb	r2, [r0, r3]
		if (src[i] == 0)
 80034d6:	3301      	adds	r3, #1
 80034d8:	2a00      	cmp	r2, #0
 80034da:	d0d9      	beq.n	8003490 <vTraceStoreMemMangEvent+0x23c>
	for (i = 0; i < maxLength; i++)
 80034dc:	2b4f      	cmp	r3, #79	; 0x4f
 80034de:	d1f8      	bne.n	80034d2 <vTraceStoreMemMangEvent+0x27e>
 80034e0:	e7d6      	b.n	8003490 <vTraceStoreMemMangEvent+0x23c>
		RecorderDataPtr->recorderActive = 0;
 80034e2:	2300      	movs	r3, #0
 80034e4:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80034e6:	4b2c      	ldr	r3, [pc, #176]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 80034e8:	681b      	ldr	r3, [r3, #0]
 80034ea:	2b00      	cmp	r3, #0
 80034ec:	d05e      	beq.n	80035ac <vTraceStoreMemMangEvent+0x358>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80034ee:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80034f0:	4b2a      	ldr	r3, [pc, #168]	; (800359c <vTraceStoreMemMangEvent+0x348>)
		if (RecorderDataPtr != NULL)
 80034f2:	6832      	ldr	r2, [r6, #0]
	if (traceErrorMessage == NULL)
 80034f4:	6819      	ldr	r1, [r3, #0]
 80034f6:	2900      	cmp	r1, #0
 80034f8:	d000      	beq.n	80034fc <vTraceStoreMemMangEvent+0x2a8>
 80034fa:	e770      	b.n	80033de <vTraceStoreMemMangEvent+0x18a>
		traceErrorMessage = (char*)(intptr_t) msg;
 80034fc:	4928      	ldr	r1, [pc, #160]	; (80035a0 <vTraceStoreMemMangEvent+0x34c>)
 80034fe:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003500:	2a00      	cmp	r2, #0
 8003502:	d100      	bne.n	8003506 <vTraceStoreMemMangEvent+0x2b2>
 8003504:	e76b      	b.n	80033de <vTraceStoreMemMangEvent+0x18a>
		dst[i] = src[i];
 8003506:	23ce      	movs	r3, #206	; 0xce
 8003508:	2141      	movs	r1, #65	; 0x41
 800350a:	4826      	ldr	r0, [pc, #152]	; (80035a4 <vTraceStoreMemMangEvent+0x350>)
 800350c:	00db      	lsls	r3, r3, #3
 800350e:	4684      	mov	ip, r0
 8003510:	54d1      	strb	r1, [r2, r3]
 8003512:	2300      	movs	r3, #0
 8003514:	4924      	ldr	r1, [pc, #144]	; (80035a8 <vTraceStoreMemMangEvent+0x354>)
 8003516:	4462      	add	r2, ip
 8003518:	5cc8      	ldrb	r0, [r1, r3]
 800351a:	54d0      	strb	r0, [r2, r3]
		if (src[i] == 0)
 800351c:	3301      	adds	r3, #1
 800351e:	2800      	cmp	r0, #0
 8003520:	d001      	beq.n	8003526 <vTraceStoreMemMangEvent+0x2d2>
	for (i = 0; i < maxLength; i++)
 8003522:	2b4f      	cmp	r3, #79	; 0x4f
 8003524:	d1f8      	bne.n	8003518 <vTraceStoreMemMangEvent+0x2c4>
			RecorderDataPtr->internalErrorOccured = 1;
 8003526:	23cd      	movs	r3, #205	; 0xcd
 8003528:	2101      	movs	r1, #1
 800352a:	6832      	ldr	r2, [r6, #0]
 800352c:	00db      	lsls	r3, r3, #3
 800352e:	50d1      	str	r1, [r2, r3]
	if (! RecorderDataPtr->recorderActive)
 8003530:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003532:	9301      	str	r3, [sp, #4]
 8003534:	e755      	b.n	80033e2 <vTraceStoreMemMangEvent+0x18e>
		RecorderDataPtr->recorderActive = 0;
 8003536:	2300      	movs	r3, #0
 8003538:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800353a:	4b17      	ldr	r3, [pc, #92]	; (8003598 <vTraceStoreMemMangEvent+0x344>)
 800353c:	681b      	ldr	r3, [r3, #0]
 800353e:	2b00      	cmp	r3, #0
 8003540:	d000      	beq.n	8003544 <vTraceStoreMemMangEvent+0x2f0>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003542:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003544:	4b15      	ldr	r3, [pc, #84]	; (800359c <vTraceStoreMemMangEvent+0x348>)
 8003546:	681a      	ldr	r2, [r3, #0]
 8003548:	2a00      	cmp	r2, #0
 800354a:	d000      	beq.n	800354e <vTraceStoreMemMangEvent+0x2fa>
 800354c:	e778      	b.n	8003440 <vTraceStoreMemMangEvent+0x1ec>
		traceErrorMessage = (char*)(intptr_t) msg;
 800354e:	4a14      	ldr	r2, [pc, #80]	; (80035a0 <vTraceStoreMemMangEvent+0x34c>)
 8003550:	601a      	str	r2, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003552:	6832      	ldr	r2, [r6, #0]
 8003554:	2a00      	cmp	r2, #0
 8003556:	d100      	bne.n	800355a <vTraceStoreMemMangEvent+0x306>
 8003558:	e773      	b.n	8003442 <vTraceStoreMemMangEvent+0x1ee>
		dst[i] = src[i];
 800355a:	23ce      	movs	r3, #206	; 0xce
 800355c:	2141      	movs	r1, #65	; 0x41
 800355e:	4811      	ldr	r0, [pc, #68]	; (80035a4 <vTraceStoreMemMangEvent+0x350>)
 8003560:	00db      	lsls	r3, r3, #3
 8003562:	4684      	mov	ip, r0
 8003564:	54d1      	strb	r1, [r2, r3]
 8003566:	2300      	movs	r3, #0
 8003568:	490f      	ldr	r1, [pc, #60]	; (80035a8 <vTraceStoreMemMangEvent+0x354>)
 800356a:	4462      	add	r2, ip
 800356c:	5cc8      	ldrb	r0, [r1, r3]
 800356e:	54d0      	strb	r0, [r2, r3]
		if (src[i] == 0)
 8003570:	3301      	adds	r3, #1
 8003572:	2800      	cmp	r0, #0
 8003574:	d001      	beq.n	800357a <vTraceStoreMemMangEvent+0x326>
	for (i = 0; i < maxLength; i++)
 8003576:	2b4f      	cmp	r3, #79	; 0x4f
 8003578:	d1f8      	bne.n	800356c <vTraceStoreMemMangEvent+0x318>
			RecorderDataPtr->internalErrorOccured = 1;
 800357a:	23cd      	movs	r3, #205	; 0xcd
 800357c:	2101      	movs	r1, #1
 800357e:	6832      	ldr	r2, [r6, #0]
 8003580:	00db      	lsls	r3, r3, #3
 8003582:	50d1      	str	r1, [r2, r3]
	if (! RecorderDataPtr->recorderActive)
 8003584:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003586:	9301      	str	r3, [sp, #4]
 8003588:	e75d      	b.n	8003446 <vTraceStoreMemMangEvent+0x1f2>
 800358a:	46c0      	nop			; (mov r8, r8)
 800358c:	200033f4 	.word	0x200033f4
 8003590:	20003480 	.word	0x20003480
 8003594:	000006c4 	.word	0x000006c4
 8003598:	20003498 	.word	0x20003498
 800359c:	20003488 	.word	0x20003488
 80035a0:	080061c4 	.word	0x080061c4
 80035a4:	00000671 	.word	0x00000671
 80035a8:	080061c5 	.word	0x080061c5
	if (traceErrorMessage == NULL)
 80035ac:	4b03      	ldr	r3, [pc, #12]	; (80035bc <vTraceStoreMemMangEvent+0x368>)
 80035ae:	6819      	ldr	r1, [r3, #0]
 80035b0:	2900      	cmp	r1, #0
 80035b2:	d000      	beq.n	80035b6 <vTraceStoreMemMangEvent+0x362>
 80035b4:	e713      	b.n	80033de <vTraceStoreMemMangEvent+0x18a>
		traceErrorMessage = (char*)(intptr_t) msg;
 80035b6:	4902      	ldr	r1, [pc, #8]	; (80035c0 <vTraceStoreMemMangEvent+0x36c>)
 80035b8:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 80035ba:	e7a4      	b.n	8003506 <vTraceStoreMemMangEvent+0x2b2>
 80035bc:	20003488 	.word	0x20003488
 80035c0:	080061c4 	.word	0x080061c4

080035c4 <prvTraceStoreKernelCall>:
{
 80035c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80035c6:	464f      	mov	r7, r9
 80035c8:	4646      	mov	r6, r8
 80035ca:	46d6      	mov	lr, sl
 80035cc:	b5c0      	push	{r6, r7, lr}
	if (RecorderDataPtr != NULL)
 80035ce:	4f87      	ldr	r7, [pc, #540]	; (80037ec <prvTraceStoreKernelCall+0x228>)
{
 80035d0:	0004      	movs	r4, r0
 80035d2:	0016      	movs	r6, r2
	if (RecorderDataPtr != NULL)
 80035d4:	683b      	ldr	r3, [r7, #0]
	TRACE_ASSERT(ecode < 0xFF, "prvTraceStoreKernelCall: ecode >= 0xFF", TRC_UNUSED);
 80035d6:	28fe      	cmp	r0, #254	; 0xfe
 80035d8:	d827      	bhi.n	800362a <prvTraceStoreKernelCall+0x66>
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCall: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
 80035da:	2908      	cmp	r1, #8
 80035dc:	d900      	bls.n	80035e0 <prvTraceStoreKernelCall+0x1c>
 80035de:	e094      	b.n	800370a <prvTraceStoreKernelCall+0x146>
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCall: Invalid value for objectNumber", TRC_UNUSED);
 80035e0:	1859      	adds	r1, r3, r1
 80035e2:	3150      	adds	r1, #80	; 0x50
 80035e4:	780a      	ldrb	r2, [r1, #0]
 80035e6:	42b2      	cmp	r2, r6
 80035e8:	d200      	bcs.n	80035ec <prvTraceStoreKernelCall+0x28>
 80035ea:	e0b3      	b.n	8003754 <prvTraceStoreKernelCall+0x190>
	if (recorder_busy)
 80035ec:	4d80      	ldr	r5, [pc, #512]	; (80037f0 <prvTraceStoreKernelCall+0x22c>)
 80035ee:	682a      	ldr	r2, [r5, #0]
 80035f0:	4691      	mov	r9, r2
 80035f2:	2a00      	cmp	r2, #0
 80035f4:	d141      	bne.n	800367a <prvTraceStoreKernelCall+0xb6>
	if (handle_of_last_logged_task == 0)
 80035f6:	4b7f      	ldr	r3, [pc, #508]	; (80037f4 <prvTraceStoreKernelCall+0x230>)
 80035f8:	781b      	ldrb	r3, [r3, #0]
 80035fa:	2b00      	cmp	r3, #0
 80035fc:	d010      	beq.n	8003620 <prvTraceStoreKernelCall+0x5c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80035fe:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003602:	2301      	movs	r3, #1
 8003604:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
 8003608:	682b      	ldr	r3, [r5, #0]
 800360a:	3301      	adds	r3, #1
 800360c:	602b      	str	r3, [r5, #0]
	if (RecorderDataPtr->recorderActive)
 800360e:	683b      	ldr	r3, [r7, #0]
 8003610:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003612:	2b00      	cmp	r3, #0
 8003614:	d152      	bne.n	80036bc <prvTraceStoreKernelCall+0xf8>
	trcCRITICAL_SECTION_END();
 8003616:	682b      	ldr	r3, [r5, #0]
 8003618:	3b01      	subs	r3, #1
 800361a:	602b      	str	r3, [r5, #0]
 800361c:	f388 8810 	msr	PRIMASK, r8
}
 8003620:	bce0      	pop	{r5, r6, r7}
 8003622:	46ba      	mov	sl, r7
 8003624:	46b1      	mov	r9, r6
 8003626:	46a8      	mov	r8, r5
 8003628:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (RecorderDataPtr != NULL)
 800362a:	2b00      	cmp	r3, #0
 800362c:	d006      	beq.n	800363c <prvTraceStoreKernelCall+0x78>
		RecorderDataPtr->recorderActive = 0;
 800362e:	2200      	movs	r2, #0
 8003630:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003632:	4b71      	ldr	r3, [pc, #452]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 8003634:	681b      	ldr	r3, [r3, #0]
 8003636:	2b00      	cmp	r3, #0
 8003638:	d000      	beq.n	800363c <prvTraceStoreKernelCall+0x78>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800363a:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800363c:	4b6f      	ldr	r3, [pc, #444]	; (80037fc <prvTraceStoreKernelCall+0x238>)
 800363e:	681a      	ldr	r2, [r3, #0]
 8003640:	2a00      	cmp	r2, #0
 8003642:	d1ed      	bne.n	8003620 <prvTraceStoreKernelCall+0x5c>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003644:	486e      	ldr	r0, [pc, #440]	; (8003800 <prvTraceStoreKernelCall+0x23c>)
		if (RecorderDataPtr != NULL)
 8003646:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003648:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 800364a:	2900      	cmp	r1, #0
 800364c:	d0e8      	beq.n	8003620 <prvTraceStoreKernelCall+0x5c>
		dst[i] = src[i];
 800364e:	23ce      	movs	r3, #206	; 0xce
 8003650:	3254      	adds	r2, #84	; 0x54
 8003652:	00db      	lsls	r3, r3, #3
 8003654:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003656:	4a6b      	ldr	r2, [pc, #428]	; (8003804 <prvTraceStoreKernelCall+0x240>)
		dst[i] = src[i];
 8003658:	2300      	movs	r3, #0
 800365a:	4694      	mov	ip, r2
 800365c:	3001      	adds	r0, #1
 800365e:	4461      	add	r1, ip
 8003660:	5cc2      	ldrb	r2, [r0, r3]
 8003662:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003664:	3301      	adds	r3, #1
 8003666:	2a00      	cmp	r2, #0
 8003668:	d001      	beq.n	800366e <prvTraceStoreKernelCall+0xaa>
	for (i = 0; i < maxLength; i++)
 800366a:	2b4f      	cmp	r3, #79	; 0x4f
 800366c:	d1f8      	bne.n	8003660 <prvTraceStoreKernelCall+0x9c>
			RecorderDataPtr->internalErrorOccured = 1;
 800366e:	23cd      	movs	r3, #205	; 0xcd
 8003670:	2101      	movs	r1, #1
 8003672:	683a      	ldr	r2, [r7, #0]
 8003674:	00db      	lsls	r3, r3, #3
 8003676:	50d1      	str	r1, [r2, r3]
 8003678:	e7d2      	b.n	8003620 <prvTraceStoreKernelCall+0x5c>
		RecorderDataPtr->recorderActive = 0;
 800367a:	2200      	movs	r2, #0
 800367c:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800367e:	4b5e      	ldr	r3, [pc, #376]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 8003680:	681b      	ldr	r3, [r3, #0]
 8003682:	2b00      	cmp	r3, #0
 8003684:	d000      	beq.n	8003688 <prvTraceStoreKernelCall+0xc4>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003686:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003688:	4b5c      	ldr	r3, [pc, #368]	; (80037fc <prvTraceStoreKernelCall+0x238>)
 800368a:	681a      	ldr	r2, [r3, #0]
 800368c:	2a00      	cmp	r2, #0
 800368e:	d1c7      	bne.n	8003620 <prvTraceStoreKernelCall+0x5c>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003690:	485d      	ldr	r0, [pc, #372]	; (8003808 <prvTraceStoreKernelCall+0x244>)
		if (RecorderDataPtr != NULL)
 8003692:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003694:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003696:	2900      	cmp	r1, #0
 8003698:	d0c2      	beq.n	8003620 <prvTraceStoreKernelCall+0x5c>
		dst[i] = src[i];
 800369a:	23ce      	movs	r3, #206	; 0xce
 800369c:	3252      	adds	r2, #82	; 0x52
 800369e:	00db      	lsls	r3, r3, #3
 80036a0:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80036a2:	4a58      	ldr	r2, [pc, #352]	; (8003804 <prvTraceStoreKernelCall+0x240>)
		dst[i] = src[i];
 80036a4:	2300      	movs	r3, #0
 80036a6:	4694      	mov	ip, r2
 80036a8:	3001      	adds	r0, #1
 80036aa:	4461      	add	r1, ip
 80036ac:	5cc2      	ldrb	r2, [r0, r3]
 80036ae:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80036b0:	3301      	adds	r3, #1
 80036b2:	2a00      	cmp	r2, #0
 80036b4:	d0db      	beq.n	800366e <prvTraceStoreKernelCall+0xaa>
	for (i = 0; i < maxLength; i++)
 80036b6:	2b4f      	cmp	r3, #79	; 0x4f
 80036b8:	d1f8      	bne.n	80036ac <prvTraceStoreKernelCall+0xe8>
 80036ba:	e7d8      	b.n	800366e <prvTraceStoreKernelCall+0xaa>
		dts1 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80036bc:	4853      	ldr	r0, [pc, #332]	; (800380c <prvTraceStoreKernelCall+0x248>)
 80036be:	f7ff fad7 	bl	8002c70 <prvTraceGetDTS>
	if (! RecorderDataPtr->recorderActive)
 80036c2:	683b      	ldr	r3, [r7, #0]
		dts1 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80036c4:	4684      	mov	ip, r0
	if (! RecorderDataPtr->recorderActive)
 80036c6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80036c8:	2a00      	cmp	r2, #0
 80036ca:	d0a4      	beq.n	8003616 <prvTraceStoreKernelCall+0x52>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80036cc:	20fa      	movs	r0, #250	; 0xfa
 80036ce:	69d9      	ldr	r1, [r3, #28]
 80036d0:	0080      	lsls	r0, r0, #2
 80036d2:	4281      	cmp	r1, r0
 80036d4:	d262      	bcs.n	800379c <prvTraceStoreKernelCall+0x1d8>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80036d6:	4f4e      	ldr	r7, [pc, #312]	; (8003810 <prvTraceStoreKernelCall+0x24c>)
 80036d8:	008a      	lsls	r2, r1, #2
 80036da:	46ba      	mov	sl, r7
			kse->dts = dts1;
 80036dc:	4667      	mov	r7, ip
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80036de:	4452      	add	r2, sl
 80036e0:	189a      	adds	r2, r3, r2
			kse->type = (uint8_t)ecode;
 80036e2:	7014      	strb	r4, [r2, #0]
			kse->objHandle = hnd8;
 80036e4:	7056      	strb	r6, [r2, #1]
			kse->dts = dts1;
 80036e6:	8057      	strh	r7, [r2, #2]
	RecorderDataPtr->numEvents++;
 80036e8:	695a      	ldr	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 80036ea:	3101      	adds	r1, #1
	RecorderDataPtr->numEvents++;
 80036ec:	3201      	adds	r2, #1
 80036ee:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 80036f0:	61d9      	str	r1, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80036f2:	4281      	cmp	r1, r0
 80036f4:	d000      	beq.n	80036f8 <prvTraceStoreKernelCall+0x134>
 80036f6:	e78e      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
		RecorderDataPtr->recorderActive = 0;
 80036f8:	464a      	mov	r2, r9
 80036fa:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80036fc:	4b3e      	ldr	r3, [pc, #248]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 80036fe:	681b      	ldr	r3, [r3, #0]
 8003700:	2b00      	cmp	r3, #0
 8003702:	d100      	bne.n	8003706 <prvTraceStoreKernelCall+0x142>
 8003704:	e787      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003706:	4798      	blx	r3
 8003708:	e785      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
	if (RecorderDataPtr != NULL)
 800370a:	2b00      	cmp	r3, #0
 800370c:	d006      	beq.n	800371c <prvTraceStoreKernelCall+0x158>
		RecorderDataPtr->recorderActive = 0;
 800370e:	2200      	movs	r2, #0
 8003710:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003712:	4b39      	ldr	r3, [pc, #228]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	2b00      	cmp	r3, #0
 8003718:	d000      	beq.n	800371c <prvTraceStoreKernelCall+0x158>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800371a:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800371c:	4b37      	ldr	r3, [pc, #220]	; (80037fc <prvTraceStoreKernelCall+0x238>)
 800371e:	681a      	ldr	r2, [r3, #0]
 8003720:	2a00      	cmp	r2, #0
 8003722:	d000      	beq.n	8003726 <prvTraceStoreKernelCall+0x162>
 8003724:	e77c      	b.n	8003620 <prvTraceStoreKernelCall+0x5c>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003726:	483b      	ldr	r0, [pc, #236]	; (8003814 <prvTraceStoreKernelCall+0x250>)
		if (RecorderDataPtr != NULL)
 8003728:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800372a:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 800372c:	2900      	cmp	r1, #0
 800372e:	d100      	bne.n	8003732 <prvTraceStoreKernelCall+0x16e>
 8003730:	e776      	b.n	8003620 <prvTraceStoreKernelCall+0x5c>
		dst[i] = src[i];
 8003732:	23ce      	movs	r3, #206	; 0xce
 8003734:	3254      	adds	r2, #84	; 0x54
 8003736:	00db      	lsls	r3, r3, #3
 8003738:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 800373a:	4a32      	ldr	r2, [pc, #200]	; (8003804 <prvTraceStoreKernelCall+0x240>)
		dst[i] = src[i];
 800373c:	2300      	movs	r3, #0
 800373e:	4694      	mov	ip, r2
 8003740:	3001      	adds	r0, #1
 8003742:	4461      	add	r1, ip
 8003744:	5cc2      	ldrb	r2, [r0, r3]
 8003746:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003748:	3301      	adds	r3, #1
 800374a:	2a00      	cmp	r2, #0
 800374c:	d08f      	beq.n	800366e <prvTraceStoreKernelCall+0xaa>
	for (i = 0; i < maxLength; i++)
 800374e:	2b4f      	cmp	r3, #79	; 0x4f
 8003750:	d1f8      	bne.n	8003744 <prvTraceStoreKernelCall+0x180>
 8003752:	e78c      	b.n	800366e <prvTraceStoreKernelCall+0xaa>
		RecorderDataPtr->recorderActive = 0;
 8003754:	2200      	movs	r2, #0
 8003756:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003758:	4b27      	ldr	r3, [pc, #156]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 800375a:	681b      	ldr	r3, [r3, #0]
 800375c:	2b00      	cmp	r3, #0
 800375e:	d000      	beq.n	8003762 <prvTraceStoreKernelCall+0x19e>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003760:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003762:	4b26      	ldr	r3, [pc, #152]	; (80037fc <prvTraceStoreKernelCall+0x238>)
 8003764:	681a      	ldr	r2, [r3, #0]
 8003766:	2a00      	cmp	r2, #0
 8003768:	d000      	beq.n	800376c <prvTraceStoreKernelCall+0x1a8>
 800376a:	e759      	b.n	8003620 <prvTraceStoreKernelCall+0x5c>
		traceErrorMessage = (char*)(intptr_t) msg;
 800376c:	482a      	ldr	r0, [pc, #168]	; (8003818 <prvTraceStoreKernelCall+0x254>)
		if (RecorderDataPtr != NULL)
 800376e:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003770:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003772:	2900      	cmp	r1, #0
 8003774:	d100      	bne.n	8003778 <prvTraceStoreKernelCall+0x1b4>
 8003776:	e753      	b.n	8003620 <prvTraceStoreKernelCall+0x5c>
		dst[i] = src[i];
 8003778:	23ce      	movs	r3, #206	; 0xce
 800377a:	3254      	adds	r2, #84	; 0x54
 800377c:	00db      	lsls	r3, r3, #3
 800377e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003780:	4a20      	ldr	r2, [pc, #128]	; (8003804 <prvTraceStoreKernelCall+0x240>)
		dst[i] = src[i];
 8003782:	2300      	movs	r3, #0
 8003784:	4694      	mov	ip, r2
 8003786:	3001      	adds	r0, #1
 8003788:	4461      	add	r1, ip
 800378a:	5cc2      	ldrb	r2, [r0, r3]
 800378c:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 800378e:	3301      	adds	r3, #1
 8003790:	2a00      	cmp	r2, #0
 8003792:	d100      	bne.n	8003796 <prvTraceStoreKernelCall+0x1d2>
 8003794:	e76b      	b.n	800366e <prvTraceStoreKernelCall+0xaa>
	for (i = 0; i < maxLength; i++)
 8003796:	2b4f      	cmp	r3, #79	; 0x4f
 8003798:	d1f7      	bne.n	800378a <prvTraceStoreKernelCall+0x1c6>
 800379a:	e768      	b.n	800366e <prvTraceStoreKernelCall+0xaa>
		RecorderDataPtr->recorderActive = 0;
 800379c:	464a      	mov	r2, r9
 800379e:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80037a0:	4b15      	ldr	r3, [pc, #84]	; (80037f8 <prvTraceStoreKernelCall+0x234>)
 80037a2:	681b      	ldr	r3, [r3, #0]
 80037a4:	2b00      	cmp	r3, #0
 80037a6:	d000      	beq.n	80037aa <prvTraceStoreKernelCall+0x1e6>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80037a8:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80037aa:	4b14      	ldr	r3, [pc, #80]	; (80037fc <prvTraceStoreKernelCall+0x238>)
 80037ac:	681a      	ldr	r2, [r3, #0]
 80037ae:	2a00      	cmp	r2, #0
 80037b0:	d000      	beq.n	80037b4 <prvTraceStoreKernelCall+0x1f0>
 80037b2:	e730      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
		traceErrorMessage = (char*)(intptr_t) msg;
 80037b4:	4819      	ldr	r0, [pc, #100]	; (800381c <prvTraceStoreKernelCall+0x258>)
		if (RecorderDataPtr != NULL)
 80037b6:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80037b8:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80037ba:	2900      	cmp	r1, #0
 80037bc:	d100      	bne.n	80037c0 <prvTraceStoreKernelCall+0x1fc>
 80037be:	e72a      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
		dst[i] = src[i];
 80037c0:	23ce      	movs	r3, #206	; 0xce
 80037c2:	3241      	adds	r2, #65	; 0x41
 80037c4:	00db      	lsls	r3, r3, #3
 80037c6:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80037c8:	4a0e      	ldr	r2, [pc, #56]	; (8003804 <prvTraceStoreKernelCall+0x240>)
		dst[i] = src[i];
 80037ca:	2300      	movs	r3, #0
 80037cc:	4694      	mov	ip, r2
 80037ce:	3001      	adds	r0, #1
 80037d0:	4461      	add	r1, ip
 80037d2:	5cc2      	ldrb	r2, [r0, r3]
 80037d4:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80037d6:	3301      	adds	r3, #1
 80037d8:	2a00      	cmp	r2, #0
 80037da:	d001      	beq.n	80037e0 <prvTraceStoreKernelCall+0x21c>
	for (i = 0; i < maxLength; i++)
 80037dc:	2b4f      	cmp	r3, #79	; 0x4f
 80037de:	d1f8      	bne.n	80037d2 <prvTraceStoreKernelCall+0x20e>
			RecorderDataPtr->internalErrorOccured = 1;
 80037e0:	23cd      	movs	r3, #205	; 0xcd
 80037e2:	2101      	movs	r1, #1
 80037e4:	683a      	ldr	r2, [r7, #0]
 80037e6:	00db      	lsls	r3, r3, #3
 80037e8:	50d1      	str	r1, [r2, r3]
		if (kse != NULL)
 80037ea:	e714      	b.n	8003616 <prvTraceStoreKernelCall+0x52>
 80037ec:	200033f4 	.word	0x200033f4
 80037f0:	20003480 	.word	0x20003480
 80037f4:	200033fc 	.word	0x200033fc
 80037f8:	20003498 	.word	0x20003498
 80037fc:	20003488 	.word	0x20003488
 8003800:	080063e0 	.word	0x080063e0
 8003804:	00000671 	.word	0x00000671
 8003808:	080064a8 	.word	0x080064a8
 800380c:	0000ffff 	.word	0x0000ffff
 8003810:	000006c4 	.word	0x000006c4
 8003814:	08006418 	.word	0x08006418
 8003818:	08006460 	.word	0x08006460
 800381c:	080061c4 	.word	0x080061c4

08003820 <prvTraceStoreKernelCallWithParam>:
{
 8003820:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003822:	4645      	mov	r5, r8
 8003824:	4657      	mov	r7, sl
 8003826:	46de      	mov	lr, fp
 8003828:	464e      	mov	r6, r9
 800382a:	b5e0      	push	{r5, r6, r7, lr}
	if (RecorderDataPtr != NULL)
 800382c:	4fbc      	ldr	r7, [pc, #752]	; (8003b20 <prvTraceStoreKernelCallWithParam+0x300>)
{
 800382e:	4698      	mov	r8, r3
 8003830:	0004      	movs	r4, r0
 8003832:	0015      	movs	r5, r2
	if (RecorderDataPtr != NULL)
 8003834:	683b      	ldr	r3, [r7, #0]
{
 8003836:	b085      	sub	sp, #20
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithParam: evtcode >= 0xFF", TRC_UNUSED);
 8003838:	28fe      	cmp	r0, #254	; 0xfe
 800383a:	d82a      	bhi.n	8003892 <prvTraceStoreKernelCallWithParam+0x72>
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCallWithParam: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
 800383c:	2908      	cmp	r1, #8
 800383e:	d900      	bls.n	8003842 <prvTraceStoreKernelCallWithParam+0x22>
 8003840:	e09d      	b.n	800397e <prvTraceStoreKernelCallWithParam+0x15e>
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCallWithParam: Invalid value for objectNumber", TRC_UNUSED);
 8003842:	1859      	adds	r1, r3, r1
 8003844:	3150      	adds	r1, #80	; 0x50
 8003846:	780a      	ldrb	r2, [r1, #0]
 8003848:	42aa      	cmp	r2, r5
 800384a:	d200      	bcs.n	800384e <prvTraceStoreKernelCallWithParam+0x2e>
 800384c:	e0bc      	b.n	80039c8 <prvTraceStoreKernelCallWithParam+0x1a8>
	if (recorder_busy)
 800384e:	4eb5      	ldr	r6, [pc, #724]	; (8003b24 <prvTraceStoreKernelCallWithParam+0x304>)
 8003850:	6832      	ldr	r2, [r6, #0]
 8003852:	4691      	mov	r9, r2
 8003854:	2a00      	cmp	r2, #0
 8003856:	d144      	bne.n	80038e2 <prvTraceStoreKernelCallWithParam+0xc2>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003858:	f3ef 8b10 	mrs	fp, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800385c:	2301      	movs	r3, #1
 800385e:	469a      	mov	sl, r3
 8003860:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
 8003864:	6833      	ldr	r3, [r6, #0]
 8003866:	3301      	adds	r3, #1
 8003868:	6033      	str	r3, [r6, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task)
 800386a:	683b      	ldr	r3, [r7, #0]
 800386c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800386e:	2b00      	cmp	r3, #0
 8003870:	d003      	beq.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
 8003872:	4bad      	ldr	r3, [pc, #692]	; (8003b28 <prvTraceStoreKernelCallWithParam+0x308>)
 8003874:	781b      	ldrb	r3, [r3, #0]
 8003876:	2b00      	cmp	r3, #0
 8003878:	d154      	bne.n	8003924 <prvTraceStoreKernelCallWithParam+0x104>
	trcCRITICAL_SECTION_END();
 800387a:	6833      	ldr	r3, [r6, #0]
 800387c:	3b01      	subs	r3, #1
 800387e:	6033      	str	r3, [r6, #0]
 8003880:	f38b 8810 	msr	PRIMASK, fp
}
 8003884:	b005      	add	sp, #20
 8003886:	bcf0      	pop	{r4, r5, r6, r7}
 8003888:	46bb      	mov	fp, r7
 800388a:	46b2      	mov	sl, r6
 800388c:	46a9      	mov	r9, r5
 800388e:	46a0      	mov	r8, r4
 8003890:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (RecorderDataPtr != NULL)
 8003892:	2b00      	cmp	r3, #0
 8003894:	d006      	beq.n	80038a4 <prvTraceStoreKernelCallWithParam+0x84>
		RecorderDataPtr->recorderActive = 0;
 8003896:	2200      	movs	r2, #0
 8003898:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800389a:	4ba4      	ldr	r3, [pc, #656]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 800389c:	681b      	ldr	r3, [r3, #0]
 800389e:	2b00      	cmp	r3, #0
 80038a0:	d000      	beq.n	80038a4 <prvTraceStoreKernelCallWithParam+0x84>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80038a2:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80038a4:	4ba2      	ldr	r3, [pc, #648]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 80038a6:	681a      	ldr	r2, [r3, #0]
 80038a8:	2a00      	cmp	r2, #0
 80038aa:	d1eb      	bne.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		traceErrorMessage = (char*)(intptr_t) msg;
 80038ac:	48a1      	ldr	r0, [pc, #644]	; (8003b34 <prvTraceStoreKernelCallWithParam+0x314>)
		if (RecorderDataPtr != NULL)
 80038ae:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80038b0:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80038b2:	2900      	cmp	r1, #0
 80038b4:	d0e6      	beq.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		dst[i] = src[i];
 80038b6:	23ce      	movs	r3, #206	; 0xce
 80038b8:	3254      	adds	r2, #84	; 0x54
 80038ba:	00db      	lsls	r3, r3, #3
 80038bc:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80038be:	4a9e      	ldr	r2, [pc, #632]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
		dst[i] = src[i];
 80038c0:	2300      	movs	r3, #0
 80038c2:	4694      	mov	ip, r2
 80038c4:	3001      	adds	r0, #1
 80038c6:	4461      	add	r1, ip
 80038c8:	5cc2      	ldrb	r2, [r0, r3]
 80038ca:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80038cc:	3301      	adds	r3, #1
 80038ce:	2a00      	cmp	r2, #0
 80038d0:	d001      	beq.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
	for (i = 0; i < maxLength; i++)
 80038d2:	2b4f      	cmp	r3, #79	; 0x4f
 80038d4:	d1f8      	bne.n	80038c8 <prvTraceStoreKernelCallWithParam+0xa8>
			RecorderDataPtr->internalErrorOccured = 1;
 80038d6:	23cd      	movs	r3, #205	; 0xcd
 80038d8:	2101      	movs	r1, #1
 80038da:	683a      	ldr	r2, [r7, #0]
 80038dc:	00db      	lsls	r3, r3, #3
 80038de:	50d1      	str	r1, [r2, r3]
 80038e0:	e7d0      	b.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		RecorderDataPtr->recorderActive = 0;
 80038e2:	2200      	movs	r2, #0
 80038e4:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80038e6:	4b91      	ldr	r3, [pc, #580]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 80038e8:	681b      	ldr	r3, [r3, #0]
 80038ea:	2b00      	cmp	r3, #0
 80038ec:	d000      	beq.n	80038f0 <prvTraceStoreKernelCallWithParam+0xd0>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80038ee:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80038f0:	4b8f      	ldr	r3, [pc, #572]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 80038f2:	681a      	ldr	r2, [r3, #0]
 80038f4:	2a00      	cmp	r2, #0
 80038f6:	d1c5      	bne.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		traceErrorMessage = (char*)(intptr_t) msg;
 80038f8:	4890      	ldr	r0, [pc, #576]	; (8003b3c <prvTraceStoreKernelCallWithParam+0x31c>)
		if (RecorderDataPtr != NULL)
 80038fa:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80038fc:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80038fe:	2900      	cmp	r1, #0
 8003900:	d0c0      	beq.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		dst[i] = src[i];
 8003902:	23ce      	movs	r3, #206	; 0xce
 8003904:	3252      	adds	r2, #82	; 0x52
 8003906:	00db      	lsls	r3, r3, #3
 8003908:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 800390a:	4a8b      	ldr	r2, [pc, #556]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
		dst[i] = src[i];
 800390c:	2300      	movs	r3, #0
 800390e:	4694      	mov	ip, r2
 8003910:	3001      	adds	r0, #1
 8003912:	4461      	add	r1, ip
 8003914:	5cc2      	ldrb	r2, [r0, r3]
 8003916:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003918:	3301      	adds	r3, #1
 800391a:	2a00      	cmp	r2, #0
 800391c:	d0db      	beq.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
	for (i = 0; i < maxLength; i++)
 800391e:	2b4f      	cmp	r3, #79	; 0x4f
 8003920:	d1f8      	bne.n	8003914 <prvTraceStoreKernelCallWithParam+0xf4>
 8003922:	e7d8      	b.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
		dts2 = (uint8_t)prvTraceGetDTS(0xFF);
 8003924:	20ff      	movs	r0, #255	; 0xff
 8003926:	f7ff f9a3 	bl	8002c70 <prvTraceGetDTS>
	if (param <= param_max)
 800392a:	4643      	mov	r3, r8
		dts2 = (uint8_t)prvTraceGetDTS(0xFF);
 800392c:	9001      	str	r0, [sp, #4]
	if (param <= param_max)
 800392e:	2bff      	cmp	r3, #255	; 0xff
 8003930:	d86e      	bhi.n	8003a10 <prvTraceStoreKernelCallWithParam+0x1f0>
	if (! RecorderDataPtr->recorderActive)
 8003932:	683b      	ldr	r3, [r7, #0]
 8003934:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003936:	2a00      	cmp	r2, #0
 8003938:	d09f      	beq.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800393a:	20fa      	movs	r0, #250	; 0xfa
 800393c:	69d9      	ldr	r1, [r3, #28]
 800393e:	0080      	lsls	r0, r0, #2
 8003940:	4281      	cmp	r1, r0
 8003942:	d300      	bcc.n	8003946 <prvTraceStoreKernelCallWithParam+0x126>
 8003944:	e09c      	b.n	8003a80 <prvTraceStoreKernelCallWithParam+0x260>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003946:	4f7e      	ldr	r7, [pc, #504]	; (8003b40 <prvTraceStoreKernelCallWithParam+0x320>)
 8003948:	008a      	lsls	r2, r1, #2
 800394a:	46bc      	mov	ip, r7
 800394c:	4462      	add	r2, ip
 800394e:	189a      	adds	r2, r3, r2
			kse->type = (uint8_t)evtcode;
 8003950:	7014      	strb	r4, [r2, #0]
			kse->param = p8;
 8003952:	4644      	mov	r4, r8
			kse->dts = dts2;
 8003954:	9f01      	ldr	r7, [sp, #4]
			kse->objHandle = hnd8;
 8003956:	7055      	strb	r5, [r2, #1]
			kse->dts = dts2;
 8003958:	70d7      	strb	r7, [r2, #3]
			kse->param = p8;
 800395a:	7094      	strb	r4, [r2, #2]
	RecorderDataPtr->numEvents++;
 800395c:	695a      	ldr	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 800395e:	3101      	adds	r1, #1
	RecorderDataPtr->numEvents++;
 8003960:	3201      	adds	r2, #1
 8003962:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003964:	61d9      	str	r1, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003966:	4281      	cmp	r1, r0
 8003968:	d000      	beq.n	800396c <prvTraceStoreKernelCallWithParam+0x14c>
 800396a:	e786      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		RecorderDataPtr->recorderActive = 0;
 800396c:	2200      	movs	r2, #0
 800396e:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003970:	4b6e      	ldr	r3, [pc, #440]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 8003972:	681b      	ldr	r3, [r3, #0]
 8003974:	2b00      	cmp	r3, #0
 8003976:	d100      	bne.n	800397a <prvTraceStoreKernelCallWithParam+0x15a>
 8003978:	e77f      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800397a:	4798      	blx	r3
 800397c:	e77d      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
	if (RecorderDataPtr != NULL)
 800397e:	2b00      	cmp	r3, #0
 8003980:	d006      	beq.n	8003990 <prvTraceStoreKernelCallWithParam+0x170>
		RecorderDataPtr->recorderActive = 0;
 8003982:	2200      	movs	r2, #0
 8003984:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003986:	4b69      	ldr	r3, [pc, #420]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 8003988:	681b      	ldr	r3, [r3, #0]
 800398a:	2b00      	cmp	r3, #0
 800398c:	d000      	beq.n	8003990 <prvTraceStoreKernelCallWithParam+0x170>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800398e:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003990:	4b67      	ldr	r3, [pc, #412]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 8003992:	681a      	ldr	r2, [r3, #0]
 8003994:	2a00      	cmp	r2, #0
 8003996:	d000      	beq.n	800399a <prvTraceStoreKernelCallWithParam+0x17a>
 8003998:	e774      	b.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		traceErrorMessage = (char*)(intptr_t) msg;
 800399a:	486a      	ldr	r0, [pc, #424]	; (8003b44 <prvTraceStoreKernelCallWithParam+0x324>)
		if (RecorderDataPtr != NULL)
 800399c:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800399e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80039a0:	2900      	cmp	r1, #0
 80039a2:	d100      	bne.n	80039a6 <prvTraceStoreKernelCallWithParam+0x186>
 80039a4:	e76e      	b.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		dst[i] = src[i];
 80039a6:	23ce      	movs	r3, #206	; 0xce
 80039a8:	3254      	adds	r2, #84	; 0x54
 80039aa:	00db      	lsls	r3, r3, #3
 80039ac:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80039ae:	4a62      	ldr	r2, [pc, #392]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
		dst[i] = src[i];
 80039b0:	2300      	movs	r3, #0
 80039b2:	4694      	mov	ip, r2
 80039b4:	3001      	adds	r0, #1
 80039b6:	4461      	add	r1, ip
 80039b8:	5cc2      	ldrb	r2, [r0, r3]
 80039ba:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80039bc:	3301      	adds	r3, #1
 80039be:	2a00      	cmp	r2, #0
 80039c0:	d089      	beq.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
	for (i = 0; i < maxLength; i++)
 80039c2:	2b4f      	cmp	r3, #79	; 0x4f
 80039c4:	d1f8      	bne.n	80039b8 <prvTraceStoreKernelCallWithParam+0x198>
 80039c6:	e786      	b.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
		RecorderDataPtr->recorderActive = 0;
 80039c8:	2200      	movs	r2, #0
 80039ca:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80039cc:	4b57      	ldr	r3, [pc, #348]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 80039ce:	681b      	ldr	r3, [r3, #0]
 80039d0:	2b00      	cmp	r3, #0
 80039d2:	d000      	beq.n	80039d6 <prvTraceStoreKernelCallWithParam+0x1b6>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80039d4:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80039d6:	4b56      	ldr	r3, [pc, #344]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 80039d8:	681a      	ldr	r2, [r3, #0]
 80039da:	2a00      	cmp	r2, #0
 80039dc:	d000      	beq.n	80039e0 <prvTraceStoreKernelCallWithParam+0x1c0>
 80039de:	e751      	b.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		traceErrorMessage = (char*)(intptr_t) msg;
 80039e0:	4859      	ldr	r0, [pc, #356]	; (8003b48 <prvTraceStoreKernelCallWithParam+0x328>)
		if (RecorderDataPtr != NULL)
 80039e2:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80039e4:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80039e6:	2900      	cmp	r1, #0
 80039e8:	d100      	bne.n	80039ec <prvTraceStoreKernelCallWithParam+0x1cc>
 80039ea:	e74b      	b.n	8003884 <prvTraceStoreKernelCallWithParam+0x64>
		dst[i] = src[i];
 80039ec:	23ce      	movs	r3, #206	; 0xce
 80039ee:	3254      	adds	r2, #84	; 0x54
 80039f0:	00db      	lsls	r3, r3, #3
 80039f2:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80039f4:	4a50      	ldr	r2, [pc, #320]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
		dst[i] = src[i];
 80039f6:	2300      	movs	r3, #0
 80039f8:	4694      	mov	ip, r2
 80039fa:	3001      	adds	r0, #1
 80039fc:	4461      	add	r1, ip
 80039fe:	5cc2      	ldrb	r2, [r0, r3]
 8003a00:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003a02:	3301      	adds	r3, #1
 8003a04:	2a00      	cmp	r2, #0
 8003a06:	d100      	bne.n	8003a0a <prvTraceStoreKernelCallWithParam+0x1ea>
 8003a08:	e765      	b.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
	for (i = 0; i < maxLength; i++)
 8003a0a:	2b4f      	cmp	r3, #79	; 0x4f
 8003a0c:	d1f7      	bne.n	80039fe <prvTraceStoreKernelCallWithParam+0x1de>
 8003a0e:	e762      	b.n	80038d6 <prvTraceStoreKernelCallWithParam+0xb6>
	if (! RecorderDataPtr->recorderActive)
 8003a10:	683b      	ldr	r3, [r7, #0]
 8003a12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003a14:	2a00      	cmp	r2, #0
 8003a16:	d100      	bne.n	8003a1a <prvTraceStoreKernelCallWithParam+0x1fa>
 8003a18:	e72f      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003a1a:	21fa      	movs	r1, #250	; 0xfa
 8003a1c:	69d8      	ldr	r0, [r3, #28]
 8003a1e:	0089      	lsls	r1, r1, #2
 8003a20:	9002      	str	r0, [sp, #8]
 8003a22:	4288      	cmp	r0, r1
 8003a24:	d254      	bcs.n	8003ad0 <prvTraceStoreKernelCallWithParam+0x2b0>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003a26:	0081      	lsls	r1, r0, #2
 8003a28:	4845      	ldr	r0, [pc, #276]	; (8003b40 <prvTraceStoreKernelCallWithParam+0x320>)
 8003a2a:	4684      	mov	ip, r0
			xps->type = DIV_XPS;
 8003a2c:	4650      	mov	r0, sl
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003a2e:	4461      	add	r1, ip
 8003a30:	1859      	adds	r1, r3, r1
			xps->type = DIV_XPS;
 8003a32:	7008      	strb	r0, [r1, #0]
			xps->xps_8 = (uint8_t)((param & (0xFF00 & ~param_max)) >> 8);
 8003a34:	20ff      	movs	r0, #255	; 0xff
 8003a36:	4684      	mov	ip, r0
			xps->type = DIV_XPS;
 8003a38:	9103      	str	r1, [sp, #12]
			xps->xps_8 = (uint8_t)((param & (0xFF00 & ~param_max)) >> 8);
 8003a3a:	4640      	mov	r0, r8
 8003a3c:	4661      	mov	r1, ip
 8003a3e:	4388      	bics	r0, r1
 8003a40:	4684      	mov	ip, r0
 8003a42:	0a01      	lsrs	r1, r0, #8
 8003a44:	9803      	ldr	r0, [sp, #12]
 8003a46:	7041      	strb	r1, [r0, #1]
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
 8003a48:	4661      	mov	r1, ip
 8003a4a:	0c09      	lsrs	r1, r1, #16
 8003a4c:	8041      	strh	r1, [r0, #2]
	RecorderDataPtr->numEvents++;
 8003a4e:	6959      	ldr	r1, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003a50:	9802      	ldr	r0, [sp, #8]
	RecorderDataPtr->numEvents++;
 8003a52:	3101      	adds	r1, #1
 8003a54:	6159      	str	r1, [r3, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003a56:	21fa      	movs	r1, #250	; 0xfa
	RecorderDataPtr->nextFreeIndex++;
 8003a58:	3001      	adds	r0, #1
 8003a5a:	61d8      	str	r0, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003a5c:	0089      	lsls	r1, r1, #2
 8003a5e:	4288      	cmp	r0, r1
 8003a60:	d109      	bne.n	8003a76 <prvTraceStoreKernelCallWithParam+0x256>
		RecorderDataPtr->recorderActive = 0;
 8003a62:	2200      	movs	r2, #0
 8003a64:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003a66:	4b31      	ldr	r3, [pc, #196]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 8003a68:	681b      	ldr	r3, [r3, #0]
 8003a6a:	2b00      	cmp	r3, #0
 8003a6c:	d100      	bne.n	8003a70 <prvTraceStoreKernelCallWithParam+0x250>
 8003a6e:	e704      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003a70:	4798      	blx	r3
	if (! RecorderDataPtr->recorderActive)
 8003a72:	683b      	ldr	r3, [r7, #0]
 8003a74:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		return param & param_max;
 8003a76:	4640      	mov	r0, r8
 8003a78:	21ff      	movs	r1, #255	; 0xff
 8003a7a:	4008      	ands	r0, r1
 8003a7c:	4680      	mov	r8, r0
 8003a7e:	e75a      	b.n	8003936 <prvTraceStoreKernelCallWithParam+0x116>
		RecorderDataPtr->recorderActive = 0;
 8003a80:	2200      	movs	r2, #0
 8003a82:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003a84:	4b29      	ldr	r3, [pc, #164]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 8003a86:	681b      	ldr	r3, [r3, #0]
 8003a88:	2b00      	cmp	r3, #0
 8003a8a:	d000      	beq.n	8003a8e <prvTraceStoreKernelCallWithParam+0x26e>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003a8c:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003a8e:	4b28      	ldr	r3, [pc, #160]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 8003a90:	681a      	ldr	r2, [r3, #0]
 8003a92:	2a00      	cmp	r2, #0
 8003a94:	d000      	beq.n	8003a98 <prvTraceStoreKernelCallWithParam+0x278>
 8003a96:	e6f0      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003a98:	492c      	ldr	r1, [pc, #176]	; (8003b4c <prvTraceStoreKernelCallWithParam+0x32c>)
		if (RecorderDataPtr != NULL)
 8003a9a:	6838      	ldr	r0, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003a9c:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003a9e:	2800      	cmp	r0, #0
 8003aa0:	d100      	bne.n	8003aa4 <prvTraceStoreKernelCallWithParam+0x284>
 8003aa2:	e6ea      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		dst[i] = src[i];
 8003aa4:	23ce      	movs	r3, #206	; 0xce
 8003aa6:	3241      	adds	r2, #65	; 0x41
 8003aa8:	00db      	lsls	r3, r3, #3
 8003aaa:	54c2      	strb	r2, [r0, r3]
	for (i = 0; i < maxLength; i++)
 8003aac:	4a22      	ldr	r2, [pc, #136]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
		dst[i] = src[i];
 8003aae:	2300      	movs	r3, #0
 8003ab0:	4694      	mov	ip, r2
 8003ab2:	3101      	adds	r1, #1
 8003ab4:	4460      	add	r0, ip
 8003ab6:	5cca      	ldrb	r2, [r1, r3]
 8003ab8:	54c2      	strb	r2, [r0, r3]
		if (src[i] == 0)
 8003aba:	3301      	adds	r3, #1
 8003abc:	2a00      	cmp	r2, #0
 8003abe:	d001      	beq.n	8003ac4 <prvTraceStoreKernelCallWithParam+0x2a4>
	for (i = 0; i < maxLength; i++)
 8003ac0:	2b4f      	cmp	r3, #79	; 0x4f
 8003ac2:	d1f8      	bne.n	8003ab6 <prvTraceStoreKernelCallWithParam+0x296>
			RecorderDataPtr->internalErrorOccured = 1;
 8003ac4:	23cd      	movs	r3, #205	; 0xcd
 8003ac6:	2101      	movs	r1, #1
 8003ac8:	683a      	ldr	r2, [r7, #0]
 8003aca:	00db      	lsls	r3, r3, #3
 8003acc:	50d1      	str	r1, [r2, r3]
		if (kse != NULL)
 8003ace:	e6d4      	b.n	800387a <prvTraceStoreKernelCallWithParam+0x5a>
		RecorderDataPtr->recorderActive = 0;
 8003ad0:	464a      	mov	r2, r9
 8003ad2:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003ad4:	4b15      	ldr	r3, [pc, #84]	; (8003b2c <prvTraceStoreKernelCallWithParam+0x30c>)
 8003ad6:	681b      	ldr	r3, [r3, #0]
 8003ad8:	2b00      	cmp	r3, #0
 8003ada:	d000      	beq.n	8003ade <prvTraceStoreKernelCallWithParam+0x2be>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003adc:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003ade:	4b14      	ldr	r3, [pc, #80]	; (8003b30 <prvTraceStoreKernelCallWithParam+0x310>)
 8003ae0:	681a      	ldr	r2, [r3, #0]
 8003ae2:	2a00      	cmp	r2, #0
 8003ae4:	d1c5      	bne.n	8003a72 <prvTraceStoreKernelCallWithParam+0x252>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003ae6:	4a19      	ldr	r2, [pc, #100]	; (8003b4c <prvTraceStoreKernelCallWithParam+0x32c>)
 8003ae8:	601a      	str	r2, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003aea:	683b      	ldr	r3, [r7, #0]
 8003aec:	2b00      	cmp	r3, #0
 8003aee:	d0c1      	beq.n	8003a74 <prvTraceStoreKernelCallWithParam+0x254>
		dst[i] = src[i];
 8003af0:	22ce      	movs	r2, #206	; 0xce
 8003af2:	2141      	movs	r1, #65	; 0x41
 8003af4:	4810      	ldr	r0, [pc, #64]	; (8003b38 <prvTraceStoreKernelCallWithParam+0x318>)
 8003af6:	00d2      	lsls	r2, r2, #3
 8003af8:	4684      	mov	ip, r0
 8003afa:	5499      	strb	r1, [r3, r2]
 8003afc:	2200      	movs	r2, #0
 8003afe:	4914      	ldr	r1, [pc, #80]	; (8003b50 <prvTraceStoreKernelCallWithParam+0x330>)
 8003b00:	4463      	add	r3, ip
 8003b02:	5c88      	ldrb	r0, [r1, r2]
 8003b04:	5498      	strb	r0, [r3, r2]
		if (src[i] == 0)
 8003b06:	3201      	adds	r2, #1
 8003b08:	2800      	cmp	r0, #0
 8003b0a:	d001      	beq.n	8003b10 <prvTraceStoreKernelCallWithParam+0x2f0>
	for (i = 0; i < maxLength; i++)
 8003b0c:	2a4f      	cmp	r2, #79	; 0x4f
 8003b0e:	d1f8      	bne.n	8003b02 <prvTraceStoreKernelCallWithParam+0x2e2>
			RecorderDataPtr->internalErrorOccured = 1;
 8003b10:	22cd      	movs	r2, #205	; 0xcd
 8003b12:	2101      	movs	r1, #1
 8003b14:	683b      	ldr	r3, [r7, #0]
 8003b16:	00d2      	lsls	r2, r2, #3
 8003b18:	5099      	str	r1, [r3, r2]
	if (! RecorderDataPtr->recorderActive)
 8003b1a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003b1c:	e7ab      	b.n	8003a76 <prvTraceStoreKernelCallWithParam+0x256>
 8003b1e:	46c0      	nop			; (mov r8, r8)
 8003b20:	200033f4 	.word	0x200033f4
 8003b24:	20003480 	.word	0x20003480
 8003b28:	200033fc 	.word	0x200033fc
 8003b2c:	20003498 	.word	0x20003498
 8003b30:	20003488 	.word	0x20003488
 8003b34:	080064e0 	.word	0x080064e0
 8003b38:	00000671 	.word	0x00000671
 8003b3c:	080065c0 	.word	0x080065c0
 8003b40:	000006c4 	.word	0x000006c4
 8003b44:	08006520 	.word	0x08006520
 8003b48:	08006570 	.word	0x08006570
 8003b4c:	080061c4 	.word	0x080061c4
 8003b50:	080061c5 	.word	0x080061c5

08003b54 <prvTraceStoreKernelCallWithNumericParamOnly>:
{
 8003b54:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b56:	464e      	mov	r6, r9
 8003b58:	4645      	mov	r5, r8
 8003b5a:	46de      	mov	lr, fp
 8003b5c:	4657      	mov	r7, sl
 8003b5e:	b5e0      	push	{r5, r6, r7, lr}
 8003b60:	0005      	movs	r5, r0
 8003b62:	000e      	movs	r6, r1
 8003b64:	b083      	sub	sp, #12
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithNumericParamOnly: Invalid value for evtcode", TRC_UNUSED);
 8003b66:	28fe      	cmp	r0, #254	; 0xfe
 8003b68:	d850      	bhi.n	8003c0c <prvTraceStoreKernelCallWithNumericParamOnly+0xb8>
	if (recorder_busy)
 8003b6a:	4c98      	ldr	r4, [pc, #608]	; (8003dcc <prvTraceStoreKernelCallWithNumericParamOnly+0x278>)
 8003b6c:	6823      	ldr	r3, [r4, #0]
 8003b6e:	4698      	mov	r8, r3
 8003b70:	2b00      	cmp	r3, #0
 8003b72:	d000      	beq.n	8003b76 <prvTraceStoreKernelCallWithNumericParamOnly+0x22>
 8003b74:	e077      	b.n	8003c66 <prvTraceStoreKernelCallWithNumericParamOnly+0x112>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003b76:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003b7a:	2301      	movs	r3, #1
 8003b7c:	4699      	mov	r9, r3
 8003b7e:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
 8003b82:	6823      	ldr	r3, [r4, #0]
 8003b84:	3301      	adds	r3, #1
 8003b86:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task)
 8003b88:	4b91      	ldr	r3, [pc, #580]	; (8003dd0 <prvTraceStoreKernelCallWithNumericParamOnly+0x27c>)
 8003b8a:	469a      	mov	sl, r3
 8003b8c:	681b      	ldr	r3, [r3, #0]
 8003b8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003b90:	2b00      	cmp	r3, #0
 8003b92:	d10b      	bne.n	8003bac <prvTraceStoreKernelCallWithNumericParamOnly+0x58>
	trcCRITICAL_SECTION_END();
 8003b94:	6823      	ldr	r3, [r4, #0]
 8003b96:	3b01      	subs	r3, #1
 8003b98:	6023      	str	r3, [r4, #0]
 8003b9a:	f387 8810 	msr	PRIMASK, r7
}
 8003b9e:	b003      	add	sp, #12
 8003ba0:	bcf0      	pop	{r4, r5, r6, r7}
 8003ba2:	46bb      	mov	fp, r7
 8003ba4:	46b2      	mov	sl, r6
 8003ba6:	46a9      	mov	r9, r5
 8003ba8:	46a0      	mov	r8, r4
 8003baa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task)
 8003bac:	4b89      	ldr	r3, [pc, #548]	; (8003dd4 <prvTraceStoreKernelCallWithNumericParamOnly+0x280>)
 8003bae:	781b      	ldrb	r3, [r3, #0]
 8003bb0:	2b00      	cmp	r3, #0
 8003bb2:	d0ef      	beq.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		dts6 = (uint8_t)prvTraceGetDTS(0xFF);
 8003bb4:	20ff      	movs	r0, #255	; 0xff
 8003bb6:	f7ff f85b 	bl	8002c70 <prvTraceGetDTS>
	if (param <= param_max)
 8003bba:	2380      	movs	r3, #128	; 0x80
		dts6 = (uint8_t)prvTraceGetDTS(0xFF);
 8003bbc:	9000      	str	r0, [sp, #0]
	if (param <= param_max)
 8003bbe:	025b      	lsls	r3, r3, #9
 8003bc0:	429e      	cmp	r6, r3
 8003bc2:	d279      	bcs.n	8003cb8 <prvTraceStoreKernelCallWithNumericParamOnly+0x164>
	if (! RecorderDataPtr->recorderActive)
 8003bc4:	4653      	mov	r3, sl
 8003bc6:	681b      	ldr	r3, [r3, #0]
 8003bc8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003bca:	2a00      	cmp	r2, #0
 8003bcc:	d0e2      	beq.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003bce:	22fa      	movs	r2, #250	; 0xfa
 8003bd0:	69d9      	ldr	r1, [r3, #28]
 8003bd2:	0092      	lsls	r2, r2, #2
 8003bd4:	4690      	mov	r8, r2
 8003bd6:	4291      	cmp	r1, r2
 8003bd8:	d300      	bcc.n	8003bdc <prvTraceStoreKernelCallWithNumericParamOnly+0x88>
 8003bda:	e0a3      	b.n	8003d24 <prvTraceStoreKernelCallWithNumericParamOnly+0x1d0>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003bdc:	487e      	ldr	r0, [pc, #504]	; (8003dd8 <prvTraceStoreKernelCallWithNumericParamOnly+0x284>)
 8003bde:	008a      	lsls	r2, r1, #2
 8003be0:	4684      	mov	ip, r0
			kse->dts = dts6;
 8003be2:	9800      	ldr	r0, [sp, #0]
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003be4:	4462      	add	r2, ip
 8003be6:	189a      	adds	r2, r3, r2
			kse->dts = dts6;
 8003be8:	7050      	strb	r0, [r2, #1]
			kse->type = (uint8_t)evtcode;
 8003bea:	7015      	strb	r5, [r2, #0]
			kse->param = restParam;
 8003bec:	8056      	strh	r6, [r2, #2]
	RecorderDataPtr->numEvents++;
 8003bee:	695a      	ldr	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003bf0:	3101      	adds	r1, #1
	RecorderDataPtr->numEvents++;
 8003bf2:	3201      	adds	r2, #1
 8003bf4:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003bf6:	61d9      	str	r1, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003bf8:	4541      	cmp	r1, r8
 8003bfa:	d1cb      	bne.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		RecorderDataPtr->recorderActive = 0;
 8003bfc:	2200      	movs	r2, #0
 8003bfe:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003c00:	4b76      	ldr	r3, [pc, #472]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003c02:	681b      	ldr	r3, [r3, #0]
 8003c04:	2b00      	cmp	r3, #0
 8003c06:	d0c5      	beq.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003c08:	4798      	blx	r3
 8003c0a:	e7c3      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
	if (RecorderDataPtr != NULL)
 8003c0c:	4b70      	ldr	r3, [pc, #448]	; (8003dd0 <prvTraceStoreKernelCallWithNumericParamOnly+0x27c>)
 8003c0e:	469a      	mov	sl, r3
 8003c10:	681b      	ldr	r3, [r3, #0]
 8003c12:	2b00      	cmp	r3, #0
 8003c14:	d006      	beq.n	8003c24 <prvTraceStoreKernelCallWithNumericParamOnly+0xd0>
		RecorderDataPtr->recorderActive = 0;
 8003c16:	2200      	movs	r2, #0
 8003c18:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003c1a:	4b70      	ldr	r3, [pc, #448]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003c1c:	681b      	ldr	r3, [r3, #0]
 8003c1e:	2b00      	cmp	r3, #0
 8003c20:	d000      	beq.n	8003c24 <prvTraceStoreKernelCallWithNumericParamOnly+0xd0>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003c22:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003c24:	4b6e      	ldr	r3, [pc, #440]	; (8003de0 <prvTraceStoreKernelCallWithNumericParamOnly+0x28c>)
 8003c26:	681a      	ldr	r2, [r3, #0]
 8003c28:	2a00      	cmp	r2, #0
 8003c2a:	d1b8      	bne.n	8003b9e <prvTraceStoreKernelCallWithNumericParamOnly+0x4a>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003c2c:	486d      	ldr	r0, [pc, #436]	; (8003de4 <prvTraceStoreKernelCallWithNumericParamOnly+0x290>)
 8003c2e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003c30:	4653      	mov	r3, sl
 8003c32:	6819      	ldr	r1, [r3, #0]
 8003c34:	2900      	cmp	r1, #0
 8003c36:	d0b2      	beq.n	8003b9e <prvTraceStoreKernelCallWithNumericParamOnly+0x4a>
		dst[i] = src[i];
 8003c38:	23ce      	movs	r3, #206	; 0xce
 8003c3a:	3254      	adds	r2, #84	; 0x54
 8003c3c:	00db      	lsls	r3, r3, #3
 8003c3e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003c40:	4a69      	ldr	r2, [pc, #420]	; (8003de8 <prvTraceStoreKernelCallWithNumericParamOnly+0x294>)
		dst[i] = src[i];
 8003c42:	2300      	movs	r3, #0
 8003c44:	4694      	mov	ip, r2
 8003c46:	3001      	adds	r0, #1
 8003c48:	4461      	add	r1, ip
 8003c4a:	5cc2      	ldrb	r2, [r0, r3]
 8003c4c:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003c4e:	3301      	adds	r3, #1
 8003c50:	2a00      	cmp	r2, #0
 8003c52:	d001      	beq.n	8003c58 <prvTraceStoreKernelCallWithNumericParamOnly+0x104>
	for (i = 0; i < maxLength; i++)
 8003c54:	2b4f      	cmp	r3, #79	; 0x4f
 8003c56:	d1f8      	bne.n	8003c4a <prvTraceStoreKernelCallWithNumericParamOnly+0xf6>
			RecorderDataPtr->internalErrorOccured = 1;
 8003c58:	4653      	mov	r3, sl
 8003c5a:	681a      	ldr	r2, [r3, #0]
 8003c5c:	23cd      	movs	r3, #205	; 0xcd
 8003c5e:	2101      	movs	r1, #1
 8003c60:	00db      	lsls	r3, r3, #3
 8003c62:	50d1      	str	r1, [r2, r3]
 8003c64:	e79b      	b.n	8003b9e <prvTraceStoreKernelCallWithNumericParamOnly+0x4a>
	if (RecorderDataPtr != NULL)
 8003c66:	4b5a      	ldr	r3, [pc, #360]	; (8003dd0 <prvTraceStoreKernelCallWithNumericParamOnly+0x27c>)
 8003c68:	469a      	mov	sl, r3
 8003c6a:	681b      	ldr	r3, [r3, #0]
 8003c6c:	2b00      	cmp	r3, #0
 8003c6e:	d006      	beq.n	8003c7e <prvTraceStoreKernelCallWithNumericParamOnly+0x12a>
		RecorderDataPtr->recorderActive = 0;
 8003c70:	2200      	movs	r2, #0
 8003c72:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003c74:	4b59      	ldr	r3, [pc, #356]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	2b00      	cmp	r3, #0
 8003c7a:	d000      	beq.n	8003c7e <prvTraceStoreKernelCallWithNumericParamOnly+0x12a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003c7c:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003c7e:	4b58      	ldr	r3, [pc, #352]	; (8003de0 <prvTraceStoreKernelCallWithNumericParamOnly+0x28c>)
 8003c80:	681a      	ldr	r2, [r3, #0]
 8003c82:	2a00      	cmp	r2, #0
 8003c84:	d000      	beq.n	8003c88 <prvTraceStoreKernelCallWithNumericParamOnly+0x134>
 8003c86:	e78a      	b.n	8003b9e <prvTraceStoreKernelCallWithNumericParamOnly+0x4a>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003c88:	4858      	ldr	r0, [pc, #352]	; (8003dec <prvTraceStoreKernelCallWithNumericParamOnly+0x298>)
 8003c8a:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003c8c:	4653      	mov	r3, sl
 8003c8e:	6819      	ldr	r1, [r3, #0]
 8003c90:	2900      	cmp	r1, #0
 8003c92:	d100      	bne.n	8003c96 <prvTraceStoreKernelCallWithNumericParamOnly+0x142>
 8003c94:	e783      	b.n	8003b9e <prvTraceStoreKernelCallWithNumericParamOnly+0x4a>
		dst[i] = src[i];
 8003c96:	23ce      	movs	r3, #206	; 0xce
 8003c98:	3252      	adds	r2, #82	; 0x52
 8003c9a:	00db      	lsls	r3, r3, #3
 8003c9c:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003c9e:	4a52      	ldr	r2, [pc, #328]	; (8003de8 <prvTraceStoreKernelCallWithNumericParamOnly+0x294>)
		dst[i] = src[i];
 8003ca0:	2300      	movs	r3, #0
 8003ca2:	4694      	mov	ip, r2
 8003ca4:	3001      	adds	r0, #1
 8003ca6:	4461      	add	r1, ip
 8003ca8:	5cc2      	ldrb	r2, [r0, r3]
 8003caa:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003cac:	3301      	adds	r3, #1
 8003cae:	2a00      	cmp	r2, #0
 8003cb0:	d0d2      	beq.n	8003c58 <prvTraceStoreKernelCallWithNumericParamOnly+0x104>
	for (i = 0; i < maxLength; i++)
 8003cb2:	2b4f      	cmp	r3, #79	; 0x4f
 8003cb4:	d1f8      	bne.n	8003ca8 <prvTraceStoreKernelCallWithNumericParamOnly+0x154>
 8003cb6:	e7cf      	b.n	8003c58 <prvTraceStoreKernelCallWithNumericParamOnly+0x104>
	if (! RecorderDataPtr->recorderActive)
 8003cb8:	4653      	mov	r3, sl
 8003cba:	681b      	ldr	r3, [r3, #0]
 8003cbc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003cbe:	2a00      	cmp	r2, #0
 8003cc0:	d100      	bne.n	8003cc4 <prvTraceStoreKernelCallWithNumericParamOnly+0x170>
 8003cc2:	e767      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003cc4:	20fa      	movs	r0, #250	; 0xfa
 8003cc6:	69d9      	ldr	r1, [r3, #28]
 8003cc8:	0080      	lsls	r0, r0, #2
 8003cca:	9101      	str	r1, [sp, #4]
 8003ccc:	4281      	cmp	r1, r0
 8003cce:	d253      	bcs.n	8003d78 <prvTraceStoreKernelCallWithNumericParamOnly+0x224>
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003cd0:	0088      	lsls	r0, r1, #2
 8003cd2:	4684      	mov	ip, r0
 8003cd4:	4840      	ldr	r0, [pc, #256]	; (8003dd8 <prvTraceStoreKernelCallWithNumericParamOnly+0x284>)
			xps->type = DIV_XPS;
 8003cd6:	4649      	mov	r1, r9
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 8003cd8:	4683      	mov	fp, r0
 8003cda:	44dc      	add	ip, fp
 8003cdc:	449c      	add	ip, r3
			xps->type = DIV_XPS;
 8003cde:	4660      	mov	r0, ip
 8003ce0:	8001      	strh	r1, [r0, #0]
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
 8003ce2:	0c31      	lsrs	r1, r6, #16
 8003ce4:	4689      	mov	r9, r1
 8003ce6:	4661      	mov	r1, ip
 8003ce8:	4648      	mov	r0, r9
 8003cea:	8048      	strh	r0, [r1, #2]
	RecorderDataPtr->numEvents++;
 8003cec:	6959      	ldr	r1, [r3, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003cee:	20fa      	movs	r0, #250	; 0xfa
	RecorderDataPtr->numEvents++;
 8003cf0:	468c      	mov	ip, r1
 8003cf2:	2101      	movs	r1, #1
 8003cf4:	4689      	mov	r9, r1
 8003cf6:	44cc      	add	ip, r9
 8003cf8:	4661      	mov	r1, ip
 8003cfa:	6159      	str	r1, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8003cfc:	9901      	ldr	r1, [sp, #4]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003cfe:	0080      	lsls	r0, r0, #2
	RecorderDataPtr->nextFreeIndex++;
 8003d00:	3101      	adds	r1, #1
 8003d02:	61d9      	str	r1, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 8003d04:	4281      	cmp	r1, r0
 8003d06:	d10a      	bne.n	8003d1e <prvTraceStoreKernelCallWithNumericParamOnly+0x1ca>
		RecorderDataPtr->recorderActive = 0;
 8003d08:	4642      	mov	r2, r8
 8003d0a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003d0c:	4b33      	ldr	r3, [pc, #204]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003d0e:	681b      	ldr	r3, [r3, #0]
 8003d10:	2b00      	cmp	r3, #0
 8003d12:	d100      	bne.n	8003d16 <prvTraceStoreKernelCallWithNumericParamOnly+0x1c2>
 8003d14:	e73e      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003d16:	4798      	blx	r3
	if (! RecorderDataPtr->recorderActive)
 8003d18:	4653      	mov	r3, sl
 8003d1a:	681b      	ldr	r3, [r3, #0]
 8003d1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		return param & param_max;
 8003d1e:	0436      	lsls	r6, r6, #16
 8003d20:	0c36      	lsrs	r6, r6, #16
 8003d22:	e752      	b.n	8003bca <prvTraceStoreKernelCallWithNumericParamOnly+0x76>
		RecorderDataPtr->recorderActive = 0;
 8003d24:	2200      	movs	r2, #0
 8003d26:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003d28:	4b2c      	ldr	r3, [pc, #176]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003d2a:	681b      	ldr	r3, [r3, #0]
 8003d2c:	2b00      	cmp	r3, #0
 8003d2e:	d000      	beq.n	8003d32 <prvTraceStoreKernelCallWithNumericParamOnly+0x1de>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003d30:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003d32:	4b2b      	ldr	r3, [pc, #172]	; (8003de0 <prvTraceStoreKernelCallWithNumericParamOnly+0x28c>)
 8003d34:	681a      	ldr	r2, [r3, #0]
 8003d36:	2a00      	cmp	r2, #0
 8003d38:	d000      	beq.n	8003d3c <prvTraceStoreKernelCallWithNumericParamOnly+0x1e8>
 8003d3a:	e72b      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003d3c:	492c      	ldr	r1, [pc, #176]	; (8003df0 <prvTraceStoreKernelCallWithNumericParamOnly+0x29c>)
 8003d3e:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003d40:	4653      	mov	r3, sl
 8003d42:	6818      	ldr	r0, [r3, #0]
 8003d44:	2800      	cmp	r0, #0
 8003d46:	d100      	bne.n	8003d4a <prvTraceStoreKernelCallWithNumericParamOnly+0x1f6>
 8003d48:	e724      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		dst[i] = src[i];
 8003d4a:	23ce      	movs	r3, #206	; 0xce
 8003d4c:	3241      	adds	r2, #65	; 0x41
 8003d4e:	00db      	lsls	r3, r3, #3
 8003d50:	54c2      	strb	r2, [r0, r3]
	for (i = 0; i < maxLength; i++)
 8003d52:	4a25      	ldr	r2, [pc, #148]	; (8003de8 <prvTraceStoreKernelCallWithNumericParamOnly+0x294>)
		dst[i] = src[i];
 8003d54:	2300      	movs	r3, #0
 8003d56:	4694      	mov	ip, r2
 8003d58:	3101      	adds	r1, #1
 8003d5a:	4460      	add	r0, ip
 8003d5c:	5cca      	ldrb	r2, [r1, r3]
 8003d5e:	54c2      	strb	r2, [r0, r3]
		if (src[i] == 0)
 8003d60:	3301      	adds	r3, #1
 8003d62:	2a00      	cmp	r2, #0
 8003d64:	d001      	beq.n	8003d6a <prvTraceStoreKernelCallWithNumericParamOnly+0x216>
	for (i = 0; i < maxLength; i++)
 8003d66:	2b4f      	cmp	r3, #79	; 0x4f
 8003d68:	d1f8      	bne.n	8003d5c <prvTraceStoreKernelCallWithNumericParamOnly+0x208>
			RecorderDataPtr->internalErrorOccured = 1;
 8003d6a:	4653      	mov	r3, sl
 8003d6c:	681a      	ldr	r2, [r3, #0]
 8003d6e:	23cd      	movs	r3, #205	; 0xcd
 8003d70:	2101      	movs	r1, #1
 8003d72:	00db      	lsls	r3, r3, #3
 8003d74:	50d1      	str	r1, [r2, r3]
		if (kse != NULL)
 8003d76:	e70d      	b.n	8003b94 <prvTraceStoreKernelCallWithNumericParamOnly+0x40>
		RecorderDataPtr->recorderActive = 0;
 8003d78:	4642      	mov	r2, r8
 8003d7a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003d7c:	4b17      	ldr	r3, [pc, #92]	; (8003ddc <prvTraceStoreKernelCallWithNumericParamOnly+0x288>)
 8003d7e:	681b      	ldr	r3, [r3, #0]
 8003d80:	2b00      	cmp	r3, #0
 8003d82:	d000      	beq.n	8003d86 <prvTraceStoreKernelCallWithNumericParamOnly+0x232>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003d84:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003d86:	4b16      	ldr	r3, [pc, #88]	; (8003de0 <prvTraceStoreKernelCallWithNumericParamOnly+0x28c>)
 8003d88:	681a      	ldr	r2, [r3, #0]
 8003d8a:	2a00      	cmp	r2, #0
 8003d8c:	d1c4      	bne.n	8003d18 <prvTraceStoreKernelCallWithNumericParamOnly+0x1c4>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003d8e:	4a18      	ldr	r2, [pc, #96]	; (8003df0 <prvTraceStoreKernelCallWithNumericParamOnly+0x29c>)
 8003d90:	601a      	str	r2, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003d92:	4653      	mov	r3, sl
 8003d94:	681b      	ldr	r3, [r3, #0]
 8003d96:	2b00      	cmp	r3, #0
 8003d98:	d0c0      	beq.n	8003d1c <prvTraceStoreKernelCallWithNumericParamOnly+0x1c8>
		dst[i] = src[i];
 8003d9a:	22ce      	movs	r2, #206	; 0xce
 8003d9c:	2141      	movs	r1, #65	; 0x41
 8003d9e:	4812      	ldr	r0, [pc, #72]	; (8003de8 <prvTraceStoreKernelCallWithNumericParamOnly+0x294>)
 8003da0:	00d2      	lsls	r2, r2, #3
 8003da2:	4684      	mov	ip, r0
 8003da4:	5499      	strb	r1, [r3, r2]
 8003da6:	2200      	movs	r2, #0
 8003da8:	4912      	ldr	r1, [pc, #72]	; (8003df4 <prvTraceStoreKernelCallWithNumericParamOnly+0x2a0>)
 8003daa:	4463      	add	r3, ip
 8003dac:	5c88      	ldrb	r0, [r1, r2]
 8003dae:	5498      	strb	r0, [r3, r2]
		if (src[i] == 0)
 8003db0:	3201      	adds	r2, #1
 8003db2:	2800      	cmp	r0, #0
 8003db4:	d001      	beq.n	8003dba <prvTraceStoreKernelCallWithNumericParamOnly+0x266>
	for (i = 0; i < maxLength; i++)
 8003db6:	2a4f      	cmp	r2, #79	; 0x4f
 8003db8:	d1f8      	bne.n	8003dac <prvTraceStoreKernelCallWithNumericParamOnly+0x258>
			RecorderDataPtr->internalErrorOccured = 1;
 8003dba:	4653      	mov	r3, sl
 8003dbc:	22cd      	movs	r2, #205	; 0xcd
 8003dbe:	2101      	movs	r1, #1
 8003dc0:	681b      	ldr	r3, [r3, #0]
 8003dc2:	00d2      	lsls	r2, r2, #3
 8003dc4:	5099      	str	r1, [r3, r2]
	if (! RecorderDataPtr->recorderActive)
 8003dc6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003dc8:	e7a9      	b.n	8003d1e <prvTraceStoreKernelCallWithNumericParamOnly+0x1ca>
 8003dca:	46c0      	nop			; (mov r8, r8)
 8003dcc:	20003480 	.word	0x20003480
 8003dd0:	200033f4 	.word	0x200033f4
 8003dd4:	200033fc 	.word	0x200033fc
 8003dd8:	000006c4 	.word	0x000006c4
 8003ddc:	20003498 	.word	0x20003498
 8003de0:	20003488 	.word	0x20003488
 8003de4:	080065f8 	.word	0x080065f8
 8003de8:	00000671 	.word	0x00000671
 8003dec:	08006650 	.word	0x08006650
 8003df0:	080061c4 	.word	0x080061c4
 8003df4:	080061c5 	.word	0x080061c5

08003df8 <prvTraceSetPriorityProperty>:
{
 8003df8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003dfa:	0004      	movs	r4, r0
 8003dfc:	0015      	movs	r5, r2
	if (RecorderDataPtr != NULL)
 8003dfe:	4f4e      	ldr	r7, [pc, #312]	; (8003f38 <prvTraceSetPriorityProperty+0x140>)
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
 8003e00:	2808      	cmp	r0, #8
 8003e02:	d81c      	bhi.n	8003e3e <prvTraceSetPriorityProperty+0x46>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8003e04:	683e      	ldr	r6, [r7, #0]
 8003e06:	1833      	adds	r3, r6, r0
 8003e08:	001a      	movs	r2, r3
 8003e0a:	3250      	adds	r2, #80	; 0x50
 8003e0c:	7812      	ldrb	r2, [r2, #0]
 8003e0e:	428a      	cmp	r2, r1
 8003e10:	d365      	bcc.n	8003ede <prvTraceSetPriorityProperty+0xe6>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 8003e12:	2900      	cmp	r1, #0
 8003e14:	d03c      	beq.n	8003e90 <prvTraceSetPriorityProperty+0x98>
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003e16:	0002      	movs	r2, r0
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8003e18:	3368      	adds	r3, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003e1a:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8003e1c:	3901      	subs	r1, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003e1e:	3238      	adds	r2, #56	; 0x38
 8003e20:	434b      	muls	r3, r1
 8003e22:	0052      	lsls	r2, r2, #1
 8003e24:	18b2      	adds	r2, r6, r2
 8003e26:	8892      	ldrh	r2, [r2, #4]
 8003e28:	189b      	adds	r3, r3, r2
 8003e2a:	0032      	movs	r2, r6
	TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id) = value;
 8003e2c:	b29b      	uxth	r3, r3
 8003e2e:	1912      	adds	r2, r2, r4
 8003e30:	325c      	adds	r2, #92	; 0x5c
 8003e32:	7812      	ldrb	r2, [r2, #0]
 8003e34:	18f3      	adds	r3, r6, r3
 8003e36:	189b      	adds	r3, r3, r2
 8003e38:	3389      	adds	r3, #137	; 0x89
 8003e3a:	701d      	strb	r5, [r3, #0]
}
 8003e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (RecorderDataPtr != NULL)
 8003e3e:	683b      	ldr	r3, [r7, #0]
 8003e40:	2b00      	cmp	r3, #0
 8003e42:	d006      	beq.n	8003e52 <prvTraceSetPriorityProperty+0x5a>
		RecorderDataPtr->recorderActive = 0;
 8003e44:	2200      	movs	r2, #0
 8003e46:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003e48:	4b3c      	ldr	r3, [pc, #240]	; (8003f3c <prvTraceSetPriorityProperty+0x144>)
 8003e4a:	681b      	ldr	r3, [r3, #0]
 8003e4c:	2b00      	cmp	r3, #0
 8003e4e:	d000      	beq.n	8003e52 <prvTraceSetPriorityProperty+0x5a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003e50:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003e52:	4b3b      	ldr	r3, [pc, #236]	; (8003f40 <prvTraceSetPriorityProperty+0x148>)
 8003e54:	681a      	ldr	r2, [r3, #0]
 8003e56:	2a00      	cmp	r2, #0
 8003e58:	d1f0      	bne.n	8003e3c <prvTraceSetPriorityProperty+0x44>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003e5a:	483a      	ldr	r0, [pc, #232]	; (8003f44 <prvTraceSetPriorityProperty+0x14c>)
		if (RecorderDataPtr != NULL)
 8003e5c:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003e5e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003e60:	2900      	cmp	r1, #0
 8003e62:	d0eb      	beq.n	8003e3c <prvTraceSetPriorityProperty+0x44>
		dst[i] = src[i];
 8003e64:	23ce      	movs	r3, #206	; 0xce
 8003e66:	3254      	adds	r2, #84	; 0x54
 8003e68:	00db      	lsls	r3, r3, #3
 8003e6a:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003e6c:	4a36      	ldr	r2, [pc, #216]	; (8003f48 <prvTraceSetPriorityProperty+0x150>)
		dst[i] = src[i];
 8003e6e:	2300      	movs	r3, #0
 8003e70:	4694      	mov	ip, r2
 8003e72:	3001      	adds	r0, #1
 8003e74:	4461      	add	r1, ip
 8003e76:	5cc2      	ldrb	r2, [r0, r3]
 8003e78:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003e7a:	3301      	adds	r3, #1
 8003e7c:	2a00      	cmp	r2, #0
 8003e7e:	d001      	beq.n	8003e84 <prvTraceSetPriorityProperty+0x8c>
	for (i = 0; i < maxLength; i++)
 8003e80:	2b4f      	cmp	r3, #79	; 0x4f
 8003e82:	d1f8      	bne.n	8003e76 <prvTraceSetPriorityProperty+0x7e>
			RecorderDataPtr->internalErrorOccured = 1;
 8003e84:	23cd      	movs	r3, #205	; 0xcd
 8003e86:	2101      	movs	r1, #1
 8003e88:	683a      	ldr	r2, [r7, #0]
 8003e8a:	00db      	lsls	r3, r3, #3
 8003e8c:	50d1      	str	r1, [r2, r3]
 8003e8e:	e7d5      	b.n	8003e3c <prvTraceSetPriorityProperty+0x44>
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003e90:	4b2a      	ldr	r3, [pc, #168]	; (8003f3c <prvTraceSetPriorityProperty+0x144>)
		RecorderDataPtr->recorderActive = 0;
 8003e92:	6331      	str	r1, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003e94:	681b      	ldr	r3, [r3, #0]
 8003e96:	2b00      	cmp	r3, #0
 8003e98:	d042      	beq.n	8003f20 <prvTraceSetPriorityProperty+0x128>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003e9a:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003e9c:	4928      	ldr	r1, [pc, #160]	; (8003f40 <prvTraceSetPriorityProperty+0x148>)
 8003e9e:	2300      	movs	r3, #0
 8003ea0:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8003ea2:	683a      	ldr	r2, [r7, #0]
	if (traceErrorMessage == NULL)
 8003ea4:	2800      	cmp	r0, #0
 8003ea6:	d1c2      	bne.n	8003e2e <prvTraceSetPriorityProperty+0x36>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003ea8:	4828      	ldr	r0, [pc, #160]	; (8003f4c <prvTraceSetPriorityProperty+0x154>)
 8003eaa:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8003eac:	2a00      	cmp	r2, #0
 8003eae:	d0be      	beq.n	8003e2e <prvTraceSetPriorityProperty+0x36>
		dst[i] = src[i];
 8003eb0:	23ce      	movs	r3, #206	; 0xce
 8003eb2:	2154      	movs	r1, #84	; 0x54
 8003eb4:	00db      	lsls	r3, r3, #3
 8003eb6:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < maxLength; i++)
 8003eb8:	4923      	ldr	r1, [pc, #140]	; (8003f48 <prvTraceSetPriorityProperty+0x150>)
		dst[i] = src[i];
 8003eba:	2300      	movs	r3, #0
 8003ebc:	468c      	mov	ip, r1
 8003ebe:	4824      	ldr	r0, [pc, #144]	; (8003f50 <prvTraceSetPriorityProperty+0x158>)
 8003ec0:	4462      	add	r2, ip
 8003ec2:	5cc1      	ldrb	r1, [r0, r3]
 8003ec4:	54d1      	strb	r1, [r2, r3]
		if (src[i] == 0)
 8003ec6:	3301      	adds	r3, #1
 8003ec8:	2900      	cmp	r1, #0
 8003eca:	d001      	beq.n	8003ed0 <prvTraceSetPriorityProperty+0xd8>
	for (i = 0; i < maxLength; i++)
 8003ecc:	2b4f      	cmp	r3, #79	; 0x4f
 8003ece:	d1f8      	bne.n	8003ec2 <prvTraceSetPriorityProperty+0xca>
			RecorderDataPtr->internalErrorOccured = 1;
 8003ed0:	23cd      	movs	r3, #205	; 0xcd
 8003ed2:	2101      	movs	r1, #1
 8003ed4:	683a      	ldr	r2, [r7, #0]
 8003ed6:	00db      	lsls	r3, r3, #3
 8003ed8:	50d1      	str	r1, [r2, r3]
 8003eda:	2300      	movs	r3, #0
 8003edc:	e7a7      	b.n	8003e2e <prvTraceSetPriorityProperty+0x36>
		RecorderDataPtr->recorderActive = 0;
 8003ede:	2300      	movs	r3, #0
 8003ee0:	6333      	str	r3, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003ee2:	4b16      	ldr	r3, [pc, #88]	; (8003f3c <prvTraceSetPriorityProperty+0x144>)
 8003ee4:	681b      	ldr	r3, [r3, #0]
 8003ee6:	2b00      	cmp	r3, #0
 8003ee8:	d000      	beq.n	8003eec <prvTraceSetPriorityProperty+0xf4>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003eea:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003eec:	4b14      	ldr	r3, [pc, #80]	; (8003f40 <prvTraceSetPriorityProperty+0x148>)
 8003eee:	681a      	ldr	r2, [r3, #0]
 8003ef0:	2a00      	cmp	r2, #0
 8003ef2:	d1a3      	bne.n	8003e3c <prvTraceSetPriorityProperty+0x44>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003ef4:	4817      	ldr	r0, [pc, #92]	; (8003f54 <prvTraceSetPriorityProperty+0x15c>)
		if (RecorderDataPtr != NULL)
 8003ef6:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8003ef8:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8003efa:	2900      	cmp	r1, #0
 8003efc:	d09e      	beq.n	8003e3c <prvTraceSetPriorityProperty+0x44>
		dst[i] = src[i];
 8003efe:	23ce      	movs	r3, #206	; 0xce
 8003f00:	3254      	adds	r2, #84	; 0x54
 8003f02:	00db      	lsls	r3, r3, #3
 8003f04:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8003f06:	4a10      	ldr	r2, [pc, #64]	; (8003f48 <prvTraceSetPriorityProperty+0x150>)
		dst[i] = src[i];
 8003f08:	2300      	movs	r3, #0
 8003f0a:	4694      	mov	ip, r2
 8003f0c:	3001      	adds	r0, #1
 8003f0e:	4461      	add	r1, ip
 8003f10:	5cc2      	ldrb	r2, [r0, r3]
 8003f12:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8003f14:	3301      	adds	r3, #1
 8003f16:	2a00      	cmp	r2, #0
 8003f18:	d0b4      	beq.n	8003e84 <prvTraceSetPriorityProperty+0x8c>
	for (i = 0; i < maxLength; i++)
 8003f1a:	2b4f      	cmp	r3, #79	; 0x4f
 8003f1c:	d1f8      	bne.n	8003f10 <prvTraceSetPriorityProperty+0x118>
 8003f1e:	e7b1      	b.n	8003e84 <prvTraceSetPriorityProperty+0x8c>
	if (traceErrorMessage == NULL)
 8003f20:	4b07      	ldr	r3, [pc, #28]	; (8003f40 <prvTraceSetPriorityProperty+0x148>)
 8003f22:	681a      	ldr	r2, [r3, #0]
 8003f24:	2a00      	cmp	r2, #0
 8003f26:	d002      	beq.n	8003f2e <prvTraceSetPriorityProperty+0x136>
 8003f28:	0032      	movs	r2, r6
 8003f2a:	2300      	movs	r3, #0
 8003f2c:	e77f      	b.n	8003e2e <prvTraceSetPriorityProperty+0x36>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003f2e:	4a07      	ldr	r2, [pc, #28]	; (8003f4c <prvTraceSetPriorityProperty+0x154>)
 8003f30:	601a      	str	r2, [r3, #0]
 8003f32:	0032      	movs	r2, r6
 8003f34:	e7bc      	b.n	8003eb0 <prvTraceSetPriorityProperty+0xb8>
 8003f36:	46c0      	nop			; (mov r8, r8)
 8003f38:	200033f4 	.word	0x200033f4
 8003f3c:	20003498 	.word	0x20003498
 8003f40:	20003488 	.word	0x20003488
 8003f44:	08006688 	.word	0x08006688
 8003f48:	00000671 	.word	0x00000671
 8003f4c:	08006314 	.word	0x08006314
 8003f50:	08006315 	.word	0x08006315
 8003f54:	080062d4 	.word	0x080062d4

08003f58 <prvTraceGetPriorityProperty>:
{
 8003f58:	b570      	push	{r4, r5, r6, lr}
 8003f5a:	0004      	movs	r4, r0
	if (RecorderDataPtr != NULL)
 8003f5c:	4e4e      	ldr	r6, [pc, #312]	; (8004098 <prvTraceGetPriorityProperty+0x140>)
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
 8003f5e:	2808      	cmp	r0, #8
 8003f60:	d81c      	bhi.n	8003f9c <prvTraceGetPriorityProperty+0x44>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8003f62:	6835      	ldr	r5, [r6, #0]
 8003f64:	182b      	adds	r3, r5, r0
 8003f66:	001a      	movs	r2, r3
 8003f68:	3250      	adds	r2, #80	; 0x50
 8003f6a:	7812      	ldrb	r2, [r2, #0]
 8003f6c:	428a      	cmp	r2, r1
 8003f6e:	d367      	bcc.n	8004040 <prvTraceGetPriorityProperty+0xe8>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 8003f70:	2900      	cmp	r1, #0
 8003f72:	d023      	beq.n	8003fbc <prvTraceGetPriorityProperty+0x64>
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003f74:	0002      	movs	r2, r0
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8003f76:	3368      	adds	r3, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003f78:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8003f7a:	3901      	subs	r1, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8003f7c:	3238      	adds	r2, #56	; 0x38
 8003f7e:	434b      	muls	r3, r1
 8003f80:	0052      	lsls	r2, r2, #1
 8003f82:	18aa      	adds	r2, r5, r2
 8003f84:	8892      	ldrh	r2, [r2, #4]
 8003f86:	189b      	adds	r3, r3, r2
 8003f88:	002a      	movs	r2, r5
	return TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id);
 8003f8a:	b29b      	uxth	r3, r3
 8003f8c:	1912      	adds	r2, r2, r4
 8003f8e:	325c      	adds	r2, #92	; 0x5c
 8003f90:	7812      	ldrb	r2, [r2, #0]
 8003f92:	18eb      	adds	r3, r5, r3
 8003f94:	189b      	adds	r3, r3, r2
 8003f96:	3389      	adds	r3, #137	; 0x89
 8003f98:	7818      	ldrb	r0, [r3, #0]
 8003f9a:	e00e      	b.n	8003fba <prvTraceGetPriorityProperty+0x62>
	if (RecorderDataPtr != NULL)
 8003f9c:	6833      	ldr	r3, [r6, #0]
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	d006      	beq.n	8003fb0 <prvTraceGetPriorityProperty+0x58>
		RecorderDataPtr->recorderActive = 0;
 8003fa2:	2200      	movs	r2, #0
 8003fa4:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003fa6:	4b3d      	ldr	r3, [pc, #244]	; (800409c <prvTraceGetPriorityProperty+0x144>)
 8003fa8:	681b      	ldr	r3, [r3, #0]
 8003faa:	2b00      	cmp	r3, #0
 8003fac:	d000      	beq.n	8003fb0 <prvTraceGetPriorityProperty+0x58>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003fae:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003fb0:	4b3b      	ldr	r3, [pc, #236]	; (80040a0 <prvTraceGetPriorityProperty+0x148>)
 8003fb2:	681a      	ldr	r2, [r3, #0]
 8003fb4:	2a00      	cmp	r2, #0
 8003fb6:	d028      	beq.n	800400a <prvTraceGetPriorityProperty+0xb2>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8003fb8:	2000      	movs	r0, #0
}
 8003fba:	bd70      	pop	{r4, r5, r6, pc}
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003fbc:	4b37      	ldr	r3, [pc, #220]	; (800409c <prvTraceGetPriorityProperty+0x144>)
		RecorderDataPtr->recorderActive = 0;
 8003fbe:	6329      	str	r1, [r5, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8003fc0:	681b      	ldr	r3, [r3, #0]
 8003fc2:	2b00      	cmp	r3, #0
 8003fc4:	d05d      	beq.n	8004082 <prvTraceGetPriorityProperty+0x12a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8003fc6:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8003fc8:	4935      	ldr	r1, [pc, #212]	; (80040a0 <prvTraceGetPriorityProperty+0x148>)
 8003fca:	2300      	movs	r3, #0
 8003fcc:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8003fce:	6832      	ldr	r2, [r6, #0]
	if (traceErrorMessage == NULL)
 8003fd0:	2800      	cmp	r0, #0
 8003fd2:	d1db      	bne.n	8003f8c <prvTraceGetPriorityProperty+0x34>
		traceErrorMessage = (char*)(intptr_t) msg;
 8003fd4:	4833      	ldr	r0, [pc, #204]	; (80040a4 <prvTraceGetPriorityProperty+0x14c>)
 8003fd6:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8003fd8:	2a00      	cmp	r2, #0
 8003fda:	d0d7      	beq.n	8003f8c <prvTraceGetPriorityProperty+0x34>
		dst[i] = src[i];
 8003fdc:	23ce      	movs	r3, #206	; 0xce
 8003fde:	2154      	movs	r1, #84	; 0x54
 8003fe0:	00db      	lsls	r3, r3, #3
 8003fe2:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < maxLength; i++)
 8003fe4:	4930      	ldr	r1, [pc, #192]	; (80040a8 <prvTraceGetPriorityProperty+0x150>)
		dst[i] = src[i];
 8003fe6:	2300      	movs	r3, #0
 8003fe8:	468c      	mov	ip, r1
 8003fea:	4830      	ldr	r0, [pc, #192]	; (80040ac <prvTraceGetPriorityProperty+0x154>)
 8003fec:	4462      	add	r2, ip
 8003fee:	5cc1      	ldrb	r1, [r0, r3]
 8003ff0:	54d1      	strb	r1, [r2, r3]
		if (src[i] == 0)
 8003ff2:	3301      	adds	r3, #1
 8003ff4:	2900      	cmp	r1, #0
 8003ff6:	d001      	beq.n	8003ffc <prvTraceGetPriorityProperty+0xa4>
	for (i = 0; i < maxLength; i++)
 8003ff8:	2b4f      	cmp	r3, #79	; 0x4f
 8003ffa:	d1f8      	bne.n	8003fee <prvTraceGetPriorityProperty+0x96>
			RecorderDataPtr->internalErrorOccured = 1;
 8003ffc:	23cd      	movs	r3, #205	; 0xcd
 8003ffe:	2101      	movs	r1, #1
 8004000:	6832      	ldr	r2, [r6, #0]
 8004002:	00db      	lsls	r3, r3, #3
 8004004:	50d1      	str	r1, [r2, r3]
 8004006:	2300      	movs	r3, #0
 8004008:	e7c0      	b.n	8003f8c <prvTraceGetPriorityProperty+0x34>
		traceErrorMessage = (char*)(intptr_t) msg;
 800400a:	4829      	ldr	r0, [pc, #164]	; (80040b0 <prvTraceGetPriorityProperty+0x158>)
		if (RecorderDataPtr != NULL)
 800400c:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800400e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004010:	2900      	cmp	r1, #0
 8004012:	d0d1      	beq.n	8003fb8 <prvTraceGetPriorityProperty+0x60>
		dst[i] = src[i];
 8004014:	23ce      	movs	r3, #206	; 0xce
 8004016:	2254      	movs	r2, #84	; 0x54
 8004018:	00db      	lsls	r3, r3, #3
 800401a:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 800401c:	4a22      	ldr	r2, [pc, #136]	; (80040a8 <prvTraceGetPriorityProperty+0x150>)
		dst[i] = src[i];
 800401e:	2300      	movs	r3, #0
 8004020:	4694      	mov	ip, r2
 8004022:	3001      	adds	r0, #1
 8004024:	4461      	add	r1, ip
 8004026:	5cc2      	ldrb	r2, [r0, r3]
 8004028:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 800402a:	3301      	adds	r3, #1
 800402c:	2a00      	cmp	r2, #0
 800402e:	d001      	beq.n	8004034 <prvTraceGetPriorityProperty+0xdc>
	for (i = 0; i < maxLength; i++)
 8004030:	2b4f      	cmp	r3, #79	; 0x4f
 8004032:	d1f8      	bne.n	8004026 <prvTraceGetPriorityProperty+0xce>
			RecorderDataPtr->internalErrorOccured = 1;
 8004034:	23cd      	movs	r3, #205	; 0xcd
 8004036:	2101      	movs	r1, #1
 8004038:	6832      	ldr	r2, [r6, #0]
 800403a:	00db      	lsls	r3, r3, #3
 800403c:	50d1      	str	r1, [r2, r3]
 800403e:	e7bb      	b.n	8003fb8 <prvTraceGetPriorityProperty+0x60>
		RecorderDataPtr->recorderActive = 0;
 8004040:	2300      	movs	r3, #0
 8004042:	632b      	str	r3, [r5, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004044:	4b15      	ldr	r3, [pc, #84]	; (800409c <prvTraceGetPriorityProperty+0x144>)
 8004046:	681b      	ldr	r3, [r3, #0]
 8004048:	2b00      	cmp	r3, #0
 800404a:	d000      	beq.n	800404e <prvTraceGetPriorityProperty+0xf6>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800404c:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800404e:	4b14      	ldr	r3, [pc, #80]	; (80040a0 <prvTraceGetPriorityProperty+0x148>)
 8004050:	681a      	ldr	r2, [r3, #0]
 8004052:	2a00      	cmp	r2, #0
 8004054:	d1b0      	bne.n	8003fb8 <prvTraceGetPriorityProperty+0x60>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004056:	4817      	ldr	r0, [pc, #92]	; (80040b4 <prvTraceGetPriorityProperty+0x15c>)
		if (RecorderDataPtr != NULL)
 8004058:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800405a:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 800405c:	2900      	cmp	r1, #0
 800405e:	d0ab      	beq.n	8003fb8 <prvTraceGetPriorityProperty+0x60>
		dst[i] = src[i];
 8004060:	23ce      	movs	r3, #206	; 0xce
 8004062:	3254      	adds	r2, #84	; 0x54
 8004064:	00db      	lsls	r3, r3, #3
 8004066:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004068:	4a0f      	ldr	r2, [pc, #60]	; (80040a8 <prvTraceGetPriorityProperty+0x150>)
		dst[i] = src[i];
 800406a:	2300      	movs	r3, #0
 800406c:	4694      	mov	ip, r2
 800406e:	3001      	adds	r0, #1
 8004070:	4461      	add	r1, ip
 8004072:	5cc2      	ldrb	r2, [r0, r3]
 8004074:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004076:	3301      	adds	r3, #1
 8004078:	2a00      	cmp	r2, #0
 800407a:	d0db      	beq.n	8004034 <prvTraceGetPriorityProperty+0xdc>
	for (i = 0; i < maxLength; i++)
 800407c:	2b4f      	cmp	r3, #79	; 0x4f
 800407e:	d1f8      	bne.n	8004072 <prvTraceGetPriorityProperty+0x11a>
 8004080:	e7d8      	b.n	8004034 <prvTraceGetPriorityProperty+0xdc>
	if (traceErrorMessage == NULL)
 8004082:	4b07      	ldr	r3, [pc, #28]	; (80040a0 <prvTraceGetPriorityProperty+0x148>)
 8004084:	681a      	ldr	r2, [r3, #0]
 8004086:	2a00      	cmp	r2, #0
 8004088:	d002      	beq.n	8004090 <prvTraceGetPriorityProperty+0x138>
 800408a:	002a      	movs	r2, r5
 800408c:	2300      	movs	r3, #0
 800408e:	e77d      	b.n	8003f8c <prvTraceGetPriorityProperty+0x34>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004090:	4a04      	ldr	r2, [pc, #16]	; (80040a4 <prvTraceGetPriorityProperty+0x14c>)
 8004092:	601a      	str	r2, [r3, #0]
 8004094:	002a      	movs	r2, r5
 8004096:	e7a1      	b.n	8003fdc <prvTraceGetPriorityProperty+0x84>
 8004098:	200033f4 	.word	0x200033f4
 800409c:	20003498 	.word	0x20003498
 80040a0:	20003488 	.word	0x20003488
 80040a4:	08006314 	.word	0x08006314
 80040a8:	00000671 	.word	0x00000671
 80040ac:	08006315 	.word	0x08006315
 80040b0:	080066d4 	.word	0x080066d4
 80040b4:	08006720 	.word	0x08006720

080040b8 <prvTraceSetObjectState>:
{
 80040b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80040ba:	0004      	movs	r4, r0
 80040bc:	0015      	movs	r5, r2
	if (RecorderDataPtr != NULL)
 80040be:	4f4e      	ldr	r7, [pc, #312]	; (80041f8 <prvTraceSetObjectState+0x140>)
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
 80040c0:	2808      	cmp	r0, #8
 80040c2:	d81c      	bhi.n	80040fe <prvTraceSetObjectState+0x46>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 80040c4:	683e      	ldr	r6, [r7, #0]
 80040c6:	1833      	adds	r3, r6, r0
 80040c8:	001a      	movs	r2, r3
 80040ca:	3250      	adds	r2, #80	; 0x50
 80040cc:	7812      	ldrb	r2, [r2, #0]
 80040ce:	428a      	cmp	r2, r1
 80040d0:	d365      	bcc.n	800419e <prvTraceSetObjectState+0xe6>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 80040d2:	2900      	cmp	r1, #0
 80040d4:	d03c      	beq.n	8004150 <prvTraceSetObjectState+0x98>
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 80040d6:	0002      	movs	r2, r0
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 80040d8:	3368      	adds	r3, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 80040da:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 80040dc:	3901      	subs	r1, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 80040de:	3238      	adds	r2, #56	; 0x38
 80040e0:	434b      	muls	r3, r1
 80040e2:	0052      	lsls	r2, r2, #1
 80040e4:	18b2      	adds	r2, r6, r2
 80040e6:	8892      	ldrh	r2, [r2, #4]
 80040e8:	189b      	adds	r3, r3, r2
 80040ea:	0032      	movs	r2, r6
	TRACE_PROPERTY_OBJECT_STATE(objectclass, id) = value;
 80040ec:	b29b      	uxth	r3, r3
 80040ee:	1912      	adds	r2, r2, r4
 80040f0:	325c      	adds	r2, #92	; 0x5c
 80040f2:	7812      	ldrb	r2, [r2, #0]
 80040f4:	18f3      	adds	r3, r6, r3
 80040f6:	189b      	adds	r3, r3, r2
 80040f8:	3388      	adds	r3, #136	; 0x88
 80040fa:	701d      	strb	r5, [r3, #0]
}
 80040fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (RecorderDataPtr != NULL)
 80040fe:	683b      	ldr	r3, [r7, #0]
 8004100:	2b00      	cmp	r3, #0
 8004102:	d006      	beq.n	8004112 <prvTraceSetObjectState+0x5a>
		RecorderDataPtr->recorderActive = 0;
 8004104:	2200      	movs	r2, #0
 8004106:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004108:	4b3c      	ldr	r3, [pc, #240]	; (80041fc <prvTraceSetObjectState+0x144>)
 800410a:	681b      	ldr	r3, [r3, #0]
 800410c:	2b00      	cmp	r3, #0
 800410e:	d000      	beq.n	8004112 <prvTraceSetObjectState+0x5a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004110:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004112:	4b3b      	ldr	r3, [pc, #236]	; (8004200 <prvTraceSetObjectState+0x148>)
 8004114:	681a      	ldr	r2, [r3, #0]
 8004116:	2a00      	cmp	r2, #0
 8004118:	d1f0      	bne.n	80040fc <prvTraceSetObjectState+0x44>
		traceErrorMessage = (char*)(intptr_t) msg;
 800411a:	483a      	ldr	r0, [pc, #232]	; (8004204 <prvTraceSetObjectState+0x14c>)
		if (RecorderDataPtr != NULL)
 800411c:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800411e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004120:	2900      	cmp	r1, #0
 8004122:	d0eb      	beq.n	80040fc <prvTraceSetObjectState+0x44>
		dst[i] = src[i];
 8004124:	23ce      	movs	r3, #206	; 0xce
 8004126:	3254      	adds	r2, #84	; 0x54
 8004128:	00db      	lsls	r3, r3, #3
 800412a:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 800412c:	4a36      	ldr	r2, [pc, #216]	; (8004208 <prvTraceSetObjectState+0x150>)
		dst[i] = src[i];
 800412e:	2300      	movs	r3, #0
 8004130:	4694      	mov	ip, r2
 8004132:	3001      	adds	r0, #1
 8004134:	4461      	add	r1, ip
 8004136:	5cc2      	ldrb	r2, [r0, r3]
 8004138:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 800413a:	3301      	adds	r3, #1
 800413c:	2a00      	cmp	r2, #0
 800413e:	d001      	beq.n	8004144 <prvTraceSetObjectState+0x8c>
	for (i = 0; i < maxLength; i++)
 8004140:	2b4f      	cmp	r3, #79	; 0x4f
 8004142:	d1f8      	bne.n	8004136 <prvTraceSetObjectState+0x7e>
			RecorderDataPtr->internalErrorOccured = 1;
 8004144:	23cd      	movs	r3, #205	; 0xcd
 8004146:	2101      	movs	r1, #1
 8004148:	683a      	ldr	r2, [r7, #0]
 800414a:	00db      	lsls	r3, r3, #3
 800414c:	50d1      	str	r1, [r2, r3]
 800414e:	e7d5      	b.n	80040fc <prvTraceSetObjectState+0x44>
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004150:	4b2a      	ldr	r3, [pc, #168]	; (80041fc <prvTraceSetObjectState+0x144>)
		RecorderDataPtr->recorderActive = 0;
 8004152:	6331      	str	r1, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004154:	681b      	ldr	r3, [r3, #0]
 8004156:	2b00      	cmp	r3, #0
 8004158:	d042      	beq.n	80041e0 <prvTraceSetObjectState+0x128>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800415a:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800415c:	4928      	ldr	r1, [pc, #160]	; (8004200 <prvTraceSetObjectState+0x148>)
 800415e:	2300      	movs	r3, #0
 8004160:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8004162:	683a      	ldr	r2, [r7, #0]
	if (traceErrorMessage == NULL)
 8004164:	2800      	cmp	r0, #0
 8004166:	d1c2      	bne.n	80040ee <prvTraceSetObjectState+0x36>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004168:	4828      	ldr	r0, [pc, #160]	; (800420c <prvTraceSetObjectState+0x154>)
 800416a:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 800416c:	2a00      	cmp	r2, #0
 800416e:	d0be      	beq.n	80040ee <prvTraceSetObjectState+0x36>
		dst[i] = src[i];
 8004170:	23ce      	movs	r3, #206	; 0xce
 8004172:	2154      	movs	r1, #84	; 0x54
 8004174:	00db      	lsls	r3, r3, #3
 8004176:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < maxLength; i++)
 8004178:	4923      	ldr	r1, [pc, #140]	; (8004208 <prvTraceSetObjectState+0x150>)
		dst[i] = src[i];
 800417a:	2300      	movs	r3, #0
 800417c:	468c      	mov	ip, r1
 800417e:	4824      	ldr	r0, [pc, #144]	; (8004210 <prvTraceSetObjectState+0x158>)
 8004180:	4462      	add	r2, ip
 8004182:	5cc1      	ldrb	r1, [r0, r3]
 8004184:	54d1      	strb	r1, [r2, r3]
		if (src[i] == 0)
 8004186:	3301      	adds	r3, #1
 8004188:	2900      	cmp	r1, #0
 800418a:	d001      	beq.n	8004190 <prvTraceSetObjectState+0xd8>
	for (i = 0; i < maxLength; i++)
 800418c:	2b4f      	cmp	r3, #79	; 0x4f
 800418e:	d1f8      	bne.n	8004182 <prvTraceSetObjectState+0xca>
			RecorderDataPtr->internalErrorOccured = 1;
 8004190:	23cd      	movs	r3, #205	; 0xcd
 8004192:	2101      	movs	r1, #1
 8004194:	683a      	ldr	r2, [r7, #0]
 8004196:	00db      	lsls	r3, r3, #3
 8004198:	50d1      	str	r1, [r2, r3]
 800419a:	2300      	movs	r3, #0
 800419c:	e7a7      	b.n	80040ee <prvTraceSetObjectState+0x36>
		RecorderDataPtr->recorderActive = 0;
 800419e:	2300      	movs	r3, #0
 80041a0:	6333      	str	r3, [r6, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80041a2:	4b16      	ldr	r3, [pc, #88]	; (80041fc <prvTraceSetObjectState+0x144>)
 80041a4:	681b      	ldr	r3, [r3, #0]
 80041a6:	2b00      	cmp	r3, #0
 80041a8:	d000      	beq.n	80041ac <prvTraceSetObjectState+0xf4>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80041aa:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80041ac:	4b14      	ldr	r3, [pc, #80]	; (8004200 <prvTraceSetObjectState+0x148>)
 80041ae:	681a      	ldr	r2, [r3, #0]
 80041b0:	2a00      	cmp	r2, #0
 80041b2:	d1a3      	bne.n	80040fc <prvTraceSetObjectState+0x44>
		traceErrorMessage = (char*)(intptr_t) msg;
 80041b4:	4817      	ldr	r0, [pc, #92]	; (8004214 <prvTraceSetObjectState+0x15c>)
		if (RecorderDataPtr != NULL)
 80041b6:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80041b8:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80041ba:	2900      	cmp	r1, #0
 80041bc:	d09e      	beq.n	80040fc <prvTraceSetObjectState+0x44>
		dst[i] = src[i];
 80041be:	23ce      	movs	r3, #206	; 0xce
 80041c0:	3254      	adds	r2, #84	; 0x54
 80041c2:	00db      	lsls	r3, r3, #3
 80041c4:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80041c6:	4a10      	ldr	r2, [pc, #64]	; (8004208 <prvTraceSetObjectState+0x150>)
		dst[i] = src[i];
 80041c8:	2300      	movs	r3, #0
 80041ca:	4694      	mov	ip, r2
 80041cc:	3001      	adds	r0, #1
 80041ce:	4461      	add	r1, ip
 80041d0:	5cc2      	ldrb	r2, [r0, r3]
 80041d2:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80041d4:	3301      	adds	r3, #1
 80041d6:	2a00      	cmp	r2, #0
 80041d8:	d0b4      	beq.n	8004144 <prvTraceSetObjectState+0x8c>
	for (i = 0; i < maxLength; i++)
 80041da:	2b4f      	cmp	r3, #79	; 0x4f
 80041dc:	d1f8      	bne.n	80041d0 <prvTraceSetObjectState+0x118>
 80041de:	e7b1      	b.n	8004144 <prvTraceSetObjectState+0x8c>
	if (traceErrorMessage == NULL)
 80041e0:	4b07      	ldr	r3, [pc, #28]	; (8004200 <prvTraceSetObjectState+0x148>)
 80041e2:	681a      	ldr	r2, [r3, #0]
 80041e4:	2a00      	cmp	r2, #0
 80041e6:	d002      	beq.n	80041ee <prvTraceSetObjectState+0x136>
 80041e8:	0032      	movs	r2, r6
 80041ea:	2300      	movs	r3, #0
 80041ec:	e77f      	b.n	80040ee <prvTraceSetObjectState+0x36>
		traceErrorMessage = (char*)(intptr_t) msg;
 80041ee:	4a07      	ldr	r2, [pc, #28]	; (800420c <prvTraceSetObjectState+0x154>)
 80041f0:	601a      	str	r2, [r3, #0]
 80041f2:	0032      	movs	r2, r6
 80041f4:	e7bc      	b.n	8004170 <prvTraceSetObjectState+0xb8>
 80041f6:	46c0      	nop			; (mov r8, r8)
 80041f8:	200033f4 	.word	0x200033f4
 80041fc:	20003498 	.word	0x20003498
 8004200:	20003488 	.word	0x20003488
 8004204:	08006760 	.word	0x08006760
 8004208:	00000671 	.word	0x00000671
 800420c:	08006314 	.word	0x08006314
 8004210:	08006315 	.word	0x08006315
 8004214:	080067a4 	.word	0x080067a4

08004218 <prvTraceSetTaskInstanceFinished>:
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[TRACE_CLASS_TASK],
 8004218:	2353      	movs	r3, #83	; 0x53
{
 800421a:	b570      	push	{r4, r5, r6, lr}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[TRACE_CLASS_TASK],
 800421c:	4d37      	ldr	r5, [pc, #220]	; (80042fc <prvTraceSetTaskInstanceFinished+0xe4>)
 800421e:	682c      	ldr	r4, [r5, #0]
 8004220:	5ce3      	ldrb	r3, [r4, r3]
 8004222:	4283      	cmp	r3, r0
 8004224:	d339      	bcc.n	800429a <prvTraceSetTaskInstanceFinished+0x82>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 8004226:	2800      	cmp	r0, #0
 8004228:	d010      	beq.n	800424c <prvTraceSetTaskInstanceFinished+0x34>
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 800422a:	236b      	movs	r3, #107	; 0x6b
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 800422c:	227a      	movs	r2, #122	; 0x7a
 800422e:	5ce3      	ldrb	r3, [r4, r3]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8004230:	3801      	subs	r0, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8004232:	4343      	muls	r3, r0
 8004234:	5aa2      	ldrh	r2, [r4, r2]
 8004236:	189b      	adds	r3, r3, r2
 8004238:	0022      	movs	r2, r4
	TRACE_PROPERTY_OBJECT_STATE(TRACE_CLASS_TASK, handle) = 0;
 800423a:	b29b      	uxth	r3, r3
 800423c:	215f      	movs	r1, #95	; 0x5f
 800423e:	5c52      	ldrb	r2, [r2, r1]
 8004240:	18e3      	adds	r3, r4, r3
 8004242:	189b      	adds	r3, r3, r2
 8004244:	2200      	movs	r2, #0
 8004246:	3388      	adds	r3, #136	; 0x88
 8004248:	701a      	strb	r2, [r3, #0]
}
 800424a:	bd70      	pop	{r4, r5, r6, pc}
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800424c:	4b2c      	ldr	r3, [pc, #176]	; (8004300 <prvTraceSetTaskInstanceFinished+0xe8>)
		RecorderDataPtr->recorderActive = 0;
 800424e:	6320      	str	r0, [r4, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004250:	681b      	ldr	r3, [r3, #0]
 8004252:	2b00      	cmp	r3, #0
 8004254:	d047      	beq.n	80042e6 <prvTraceSetTaskInstanceFinished+0xce>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004256:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004258:	492a      	ldr	r1, [pc, #168]	; (8004304 <prvTraceSetTaskInstanceFinished+0xec>)
 800425a:	2300      	movs	r3, #0
 800425c:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 800425e:	682a      	ldr	r2, [r5, #0]
	if (traceErrorMessage == NULL)
 8004260:	2800      	cmp	r0, #0
 8004262:	d1eb      	bne.n	800423c <prvTraceSetTaskInstanceFinished+0x24>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004264:	4828      	ldr	r0, [pc, #160]	; (8004308 <prvTraceSetTaskInstanceFinished+0xf0>)
 8004266:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8004268:	2a00      	cmp	r2, #0
 800426a:	d0e7      	beq.n	800423c <prvTraceSetTaskInstanceFinished+0x24>
		dst[i] = src[i];
 800426c:	23ce      	movs	r3, #206	; 0xce
 800426e:	2154      	movs	r1, #84	; 0x54
 8004270:	00db      	lsls	r3, r3, #3
 8004272:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < maxLength; i++)
 8004274:	4925      	ldr	r1, [pc, #148]	; (800430c <prvTraceSetTaskInstanceFinished+0xf4>)
		dst[i] = src[i];
 8004276:	2300      	movs	r3, #0
 8004278:	468c      	mov	ip, r1
 800427a:	4825      	ldr	r0, [pc, #148]	; (8004310 <prvTraceSetTaskInstanceFinished+0xf8>)
 800427c:	4462      	add	r2, ip
 800427e:	5cc1      	ldrb	r1, [r0, r3]
 8004280:	54d1      	strb	r1, [r2, r3]
		if (src[i] == 0)
 8004282:	3301      	adds	r3, #1
 8004284:	2900      	cmp	r1, #0
 8004286:	d001      	beq.n	800428c <prvTraceSetTaskInstanceFinished+0x74>
	for (i = 0; i < maxLength; i++)
 8004288:	2b4f      	cmp	r3, #79	; 0x4f
 800428a:	d1f8      	bne.n	800427e <prvTraceSetTaskInstanceFinished+0x66>
			RecorderDataPtr->internalErrorOccured = 1;
 800428c:	23cd      	movs	r3, #205	; 0xcd
 800428e:	2101      	movs	r1, #1
 8004290:	682a      	ldr	r2, [r5, #0]
 8004292:	00db      	lsls	r3, r3, #3
 8004294:	50d1      	str	r1, [r2, r3]
 8004296:	2300      	movs	r3, #0
 8004298:	e7d0      	b.n	800423c <prvTraceSetTaskInstanceFinished+0x24>
		RecorderDataPtr->recorderActive = 0;
 800429a:	2300      	movs	r3, #0
 800429c:	6323      	str	r3, [r4, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800429e:	4b18      	ldr	r3, [pc, #96]	; (8004300 <prvTraceSetTaskInstanceFinished+0xe8>)
 80042a0:	681b      	ldr	r3, [r3, #0]
 80042a2:	2b00      	cmp	r3, #0
 80042a4:	d000      	beq.n	80042a8 <prvTraceSetTaskInstanceFinished+0x90>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80042a6:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80042a8:	4b16      	ldr	r3, [pc, #88]	; (8004304 <prvTraceSetTaskInstanceFinished+0xec>)
 80042aa:	681a      	ldr	r2, [r3, #0]
 80042ac:	2a00      	cmp	r2, #0
 80042ae:	d1cc      	bne.n	800424a <prvTraceSetTaskInstanceFinished+0x32>
		traceErrorMessage = (char*)(intptr_t) msg;
 80042b0:	4818      	ldr	r0, [pc, #96]	; (8004314 <prvTraceSetTaskInstanceFinished+0xfc>)
		if (RecorderDataPtr != NULL)
 80042b2:	6829      	ldr	r1, [r5, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80042b4:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80042b6:	2900      	cmp	r1, #0
 80042b8:	d0c7      	beq.n	800424a <prvTraceSetTaskInstanceFinished+0x32>
		dst[i] = src[i];
 80042ba:	23ce      	movs	r3, #206	; 0xce
 80042bc:	3254      	adds	r2, #84	; 0x54
 80042be:	00db      	lsls	r3, r3, #3
 80042c0:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80042c2:	4a12      	ldr	r2, [pc, #72]	; (800430c <prvTraceSetTaskInstanceFinished+0xf4>)
		dst[i] = src[i];
 80042c4:	2300      	movs	r3, #0
 80042c6:	4694      	mov	ip, r2
 80042c8:	3001      	adds	r0, #1
 80042ca:	4461      	add	r1, ip
 80042cc:	5cc2      	ldrb	r2, [r0, r3]
 80042ce:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80042d0:	3301      	adds	r3, #1
 80042d2:	2a00      	cmp	r2, #0
 80042d4:	d001      	beq.n	80042da <prvTraceSetTaskInstanceFinished+0xc2>
	for (i = 0; i < maxLength; i++)
 80042d6:	2b4f      	cmp	r3, #79	; 0x4f
 80042d8:	d1f8      	bne.n	80042cc <prvTraceSetTaskInstanceFinished+0xb4>
			RecorderDataPtr->internalErrorOccured = 1;
 80042da:	23cd      	movs	r3, #205	; 0xcd
 80042dc:	2101      	movs	r1, #1
 80042de:	682a      	ldr	r2, [r5, #0]
 80042e0:	00db      	lsls	r3, r3, #3
 80042e2:	50d1      	str	r1, [r2, r3]
 80042e4:	e7b1      	b.n	800424a <prvTraceSetTaskInstanceFinished+0x32>
	if (traceErrorMessage == NULL)
 80042e6:	4b07      	ldr	r3, [pc, #28]	; (8004304 <prvTraceSetTaskInstanceFinished+0xec>)
 80042e8:	681a      	ldr	r2, [r3, #0]
 80042ea:	2a00      	cmp	r2, #0
 80042ec:	d002      	beq.n	80042f4 <prvTraceSetTaskInstanceFinished+0xdc>
 80042ee:	0022      	movs	r2, r4
 80042f0:	2300      	movs	r3, #0
 80042f2:	e7a3      	b.n	800423c <prvTraceSetTaskInstanceFinished+0x24>
		traceErrorMessage = (char*)(intptr_t) msg;
 80042f4:	4a04      	ldr	r2, [pc, #16]	; (8004308 <prvTraceSetTaskInstanceFinished+0xf0>)
 80042f6:	601a      	str	r2, [r3, #0]
 80042f8:	0022      	movs	r2, r4
 80042fa:	e7b7      	b.n	800426c <prvTraceSetTaskInstanceFinished+0x54>
 80042fc:	200033f4 	.word	0x200033f4
 8004300:	20003498 	.word	0x20003498
 8004304:	20003488 	.word	0x20003488
 8004308:	08006314 	.word	0x08006314
 800430c:	00000671 	.word	0x00000671
 8004310:	08006315 	.word	0x08006315
 8004314:	080067e0 	.word	0x080067e0

08004318 <uiIndexOfObject>:
{
 8004318:	b570      	push	{r4, r5, r6, lr}
	if (RecorderDataPtr != NULL)
 800431a:	4c33      	ldr	r4, [pc, #204]	; (80043e8 <uiIndexOfObject+0xd0>)
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
 800431c:	2908      	cmp	r1, #8
 800431e:	d820      	bhi.n	8004362 <uiIndexOfObject+0x4a>
	if (RecorderDataPtr != NULL)
 8004320:	6822      	ldr	r2, [r4, #0]
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 8004322:	2800      	cmp	r0, #0
 8004324:	d05c      	beq.n	80043e0 <uiIndexOfObject+0xc8>
 8004326:	1853      	adds	r3, r2, r1
 8004328:	001d      	movs	r5, r3
 800432a:	3550      	adds	r5, #80	; 0x50
 800432c:	782d      	ldrb	r5, [r5, #0]
 800432e:	4285      	cmp	r5, r0
 8004330:	d20c      	bcs.n	800434c <uiIndexOfObject+0x34>
		RecorderDataPtr->recorderActive = 0;
 8004332:	2300      	movs	r3, #0
 8004334:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004336:	4b2d      	ldr	r3, [pc, #180]	; (80043ec <uiIndexOfObject+0xd4>)
 8004338:	681b      	ldr	r3, [r3, #0]
 800433a:	2b00      	cmp	r3, #0
 800433c:	d000      	beq.n	8004340 <uiIndexOfObject+0x28>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800433e:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004340:	4b2b      	ldr	r3, [pc, #172]	; (80043f0 <uiIndexOfObject+0xd8>)
 8004342:	681a      	ldr	r2, [r3, #0]
 8004344:	2a00      	cmp	r2, #0
 8004346:	d035      	beq.n	80043b4 <uiIndexOfObject+0x9c>
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
 8004348:	2000      	movs	r0, #0
}
 800434a:	bd70      	pop	{r4, r5, r6, pc}
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 800434c:	3368      	adds	r3, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 800434e:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8004350:	3801      	subs	r0, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8004352:	3138      	adds	r1, #56	; 0x38
 8004354:	4358      	muls	r0, r3
 8004356:	0049      	lsls	r1, r1, #1
 8004358:	1852      	adds	r2, r2, r1
 800435a:	8893      	ldrh	r3, [r2, #4]
 800435c:	18c0      	adds	r0, r0, r3
 800435e:	b280      	uxth	r0, r0
 8004360:	e7f3      	b.n	800434a <uiIndexOfObject+0x32>
	if (RecorderDataPtr != NULL)
 8004362:	6823      	ldr	r3, [r4, #0]
 8004364:	2b00      	cmp	r3, #0
 8004366:	d006      	beq.n	8004376 <uiIndexOfObject+0x5e>
		RecorderDataPtr->recorderActive = 0;
 8004368:	2200      	movs	r2, #0
 800436a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800436c:	4b1f      	ldr	r3, [pc, #124]	; (80043ec <uiIndexOfObject+0xd4>)
 800436e:	681b      	ldr	r3, [r3, #0]
 8004370:	2b00      	cmp	r3, #0
 8004372:	d000      	beq.n	8004376 <uiIndexOfObject+0x5e>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004374:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004376:	4b1e      	ldr	r3, [pc, #120]	; (80043f0 <uiIndexOfObject+0xd8>)
 8004378:	681a      	ldr	r2, [r3, #0]
 800437a:	2a00      	cmp	r2, #0
 800437c:	d1e4      	bne.n	8004348 <uiIndexOfObject+0x30>
		traceErrorMessage = (char*)(intptr_t) msg;
 800437e:	481d      	ldr	r0, [pc, #116]	; (80043f4 <uiIndexOfObject+0xdc>)
		if (RecorderDataPtr != NULL)
 8004380:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004382:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004384:	2900      	cmp	r1, #0
 8004386:	d0df      	beq.n	8004348 <uiIndexOfObject+0x30>
		dst[i] = src[i];
 8004388:	23ce      	movs	r3, #206	; 0xce
 800438a:	2254      	movs	r2, #84	; 0x54
 800438c:	00db      	lsls	r3, r3, #3
 800438e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004390:	4a19      	ldr	r2, [pc, #100]	; (80043f8 <uiIndexOfObject+0xe0>)
		dst[i] = src[i];
 8004392:	2300      	movs	r3, #0
 8004394:	4694      	mov	ip, r2
 8004396:	3001      	adds	r0, #1
 8004398:	4461      	add	r1, ip
 800439a:	5cc2      	ldrb	r2, [r0, r3]
 800439c:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 800439e:	3301      	adds	r3, #1
 80043a0:	2a00      	cmp	r2, #0
 80043a2:	d001      	beq.n	80043a8 <uiIndexOfObject+0x90>
	for (i = 0; i < maxLength; i++)
 80043a4:	2b4f      	cmp	r3, #79	; 0x4f
 80043a6:	d1f8      	bne.n	800439a <uiIndexOfObject+0x82>
			RecorderDataPtr->internalErrorOccured = 1;
 80043a8:	23cd      	movs	r3, #205	; 0xcd
 80043aa:	2101      	movs	r1, #1
 80043ac:	6822      	ldr	r2, [r4, #0]
 80043ae:	00db      	lsls	r3, r3, #3
 80043b0:	50d1      	str	r1, [r2, r3]
 80043b2:	e7c9      	b.n	8004348 <uiIndexOfObject+0x30>
		traceErrorMessage = (char*)(intptr_t) msg;
 80043b4:	4811      	ldr	r0, [pc, #68]	; (80043fc <uiIndexOfObject+0xe4>)
		if (RecorderDataPtr != NULL)
 80043b6:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80043b8:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80043ba:	2900      	cmp	r1, #0
 80043bc:	d0c4      	beq.n	8004348 <uiIndexOfObject+0x30>
		dst[i] = src[i];
 80043be:	23ce      	movs	r3, #206	; 0xce
 80043c0:	3254      	adds	r2, #84	; 0x54
 80043c2:	00db      	lsls	r3, r3, #3
 80043c4:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80043c6:	4a0c      	ldr	r2, [pc, #48]	; (80043f8 <uiIndexOfObject+0xe0>)
		dst[i] = src[i];
 80043c8:	2300      	movs	r3, #0
 80043ca:	4694      	mov	ip, r2
 80043cc:	3001      	adds	r0, #1
 80043ce:	4461      	add	r1, ip
 80043d0:	5cc2      	ldrb	r2, [r0, r3]
 80043d2:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80043d4:	3301      	adds	r3, #1
 80043d6:	2a00      	cmp	r2, #0
 80043d8:	d0e6      	beq.n	80043a8 <uiIndexOfObject+0x90>
	for (i = 0; i < maxLength; i++)
 80043da:	2b4f      	cmp	r3, #79	; 0x4f
 80043dc:	d1f8      	bne.n	80043d0 <uiIndexOfObject+0xb8>
 80043de:	e7e3      	b.n	80043a8 <uiIndexOfObject+0x90>
	if (RecorderDataPtr != NULL)
 80043e0:	2a00      	cmp	r2, #0
 80043e2:	d0ad      	beq.n	8004340 <uiIndexOfObject+0x28>
 80043e4:	e7a5      	b.n	8004332 <uiIndexOfObject+0x1a>
 80043e6:	46c0      	nop			; (mov r8, r8)
 80043e8:	200033f4 	.word	0x200033f4
 80043ec:	20003498 	.word	0x20003498
 80043f0:	20003488 	.word	0x20003488
 80043f4:	08006828 	.word	0x08006828
 80043f8:	00000671 	.word	0x00000671
 80043fc:	08006314 	.word	0x08006314

08004400 <prvTraceStoreTaskswitch>:
{
 8004400:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004402:	46de      	mov	lr, fp
 8004404:	4657      	mov	r7, sl
 8004406:	464e      	mov	r6, r9
 8004408:	4645      	mov	r5, r8
 800440a:	b5e0      	push	{r5, r6, r7, lr}
 800440c:	0004      	movs	r4, r0
 800440e:	b083      	sub	sp, #12
	TRACE_ASSERT(task_handle <= (TRC_CFG_NTASK),
 8004410:	2808      	cmp	r0, #8
 8004412:	d81d      	bhi.n	8004450 <prvTraceStoreTaskswitch+0x50>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004414:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004418:	2301      	movs	r3, #1
 800441a:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN_ON_CORTEX_M_ONLY();
 800441e:	4d9b      	ldr	r5, [pc, #620]	; (800468c <prvTraceStoreTaskswitch+0x28c>)
	if ((task_handle != handle_of_last_logged_task) && (RecorderDataPtr->recorderActive))
 8004420:	4f9b      	ldr	r7, [pc, #620]	; (8004690 <prvTraceStoreTaskswitch+0x290>)
	trcCRITICAL_SECTION_BEGIN_ON_CORTEX_M_ONLY();
 8004422:	682b      	ldr	r3, [r5, #0]
 8004424:	3301      	adds	r3, #1
 8004426:	602b      	str	r3, [r5, #0]
	if ((task_handle != handle_of_last_logged_task) && (RecorderDataPtr->recorderActive))
 8004428:	783b      	ldrb	r3, [r7, #0]
 800442a:	4283      	cmp	r3, r0
 800442c:	d004      	beq.n	8004438 <prvTraceStoreTaskswitch+0x38>
 800442e:	4e99      	ldr	r6, [pc, #612]	; (8004694 <prvTraceStoreTaskswitch+0x294>)
 8004430:	6833      	ldr	r3, [r6, #0]
 8004432:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004434:	2b00      	cmp	r3, #0
 8004436:	d135      	bne.n	80044a4 <prvTraceStoreTaskswitch+0xa4>
	trcCRITICAL_SECTION_END_ON_CORTEX_M_ONLY();
 8004438:	682b      	ldr	r3, [r5, #0]
 800443a:	3b01      	subs	r3, #1
 800443c:	602b      	str	r3, [r5, #0]
 800443e:	f388 8810 	msr	PRIMASK, r8
}
 8004442:	b003      	add	sp, #12
 8004444:	bcf0      	pop	{r4, r5, r6, r7}
 8004446:	46bb      	mov	fp, r7
 8004448:	46b2      	mov	sl, r6
 800444a:	46a9      	mov	r9, r5
 800444c:	46a0      	mov	r8, r4
 800444e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (RecorderDataPtr != NULL)
 8004450:	4e90      	ldr	r6, [pc, #576]	; (8004694 <prvTraceStoreTaskswitch+0x294>)
 8004452:	6833      	ldr	r3, [r6, #0]
 8004454:	2b00      	cmp	r3, #0
 8004456:	d006      	beq.n	8004466 <prvTraceStoreTaskswitch+0x66>
		RecorderDataPtr->recorderActive = 0;
 8004458:	2200      	movs	r2, #0
 800445a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800445c:	4b8e      	ldr	r3, [pc, #568]	; (8004698 <prvTraceStoreTaskswitch+0x298>)
 800445e:	681b      	ldr	r3, [r3, #0]
 8004460:	2b00      	cmp	r3, #0
 8004462:	d000      	beq.n	8004466 <prvTraceStoreTaskswitch+0x66>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004464:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004466:	4b8d      	ldr	r3, [pc, #564]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 8004468:	681a      	ldr	r2, [r3, #0]
 800446a:	2a00      	cmp	r2, #0
 800446c:	d1e9      	bne.n	8004442 <prvTraceStoreTaskswitch+0x42>
		traceErrorMessage = (char*)(intptr_t) msg;
 800446e:	488c      	ldr	r0, [pc, #560]	; (80046a0 <prvTraceStoreTaskswitch+0x2a0>)
		if (RecorderDataPtr != NULL)
 8004470:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004472:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004474:	2900      	cmp	r1, #0
 8004476:	d0e4      	beq.n	8004442 <prvTraceStoreTaskswitch+0x42>
		dst[i] = src[i];
 8004478:	23ce      	movs	r3, #206	; 0xce
 800447a:	3254      	adds	r2, #84	; 0x54
 800447c:	00db      	lsls	r3, r3, #3
 800447e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004480:	4a88      	ldr	r2, [pc, #544]	; (80046a4 <prvTraceStoreTaskswitch+0x2a4>)
		dst[i] = src[i];
 8004482:	2300      	movs	r3, #0
 8004484:	4694      	mov	ip, r2
 8004486:	3001      	adds	r0, #1
 8004488:	4461      	add	r1, ip
 800448a:	5cc2      	ldrb	r2, [r0, r3]
 800448c:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 800448e:	3301      	adds	r3, #1
 8004490:	2a00      	cmp	r2, #0
 8004492:	d001      	beq.n	8004498 <prvTraceStoreTaskswitch+0x98>
	for (i = 0; i < maxLength; i++)
 8004494:	2b4f      	cmp	r3, #79	; 0x4f
 8004496:	d1f8      	bne.n	800448a <prvTraceStoreTaskswitch+0x8a>
			RecorderDataPtr->internalErrorOccured = 1;
 8004498:	23cd      	movs	r3, #205	; 0xcd
 800449a:	2101      	movs	r1, #1
 800449c:	6832      	ldr	r2, [r6, #0]
 800449e:	00db      	lsls	r3, r3, #3
 80044a0:	50d1      	str	r1, [r2, r3]
 80044a2:	e7ce      	b.n	8004442 <prvTraceStoreTaskswitch+0x42>
		isPendingContextSwitch = 0;
 80044a4:	2200      	movs	r2, #0
 80044a6:	4b80      	ldr	r3, [pc, #512]	; (80046a8 <prvTraceStoreTaskswitch+0x2a8>)
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80044a8:	4880      	ldr	r0, [pc, #512]	; (80046ac <prvTraceStoreTaskswitch+0x2ac>)
		isPendingContextSwitch = 0;
 80044aa:	601a      	str	r2, [r3, #0]
 80044ac:	4693      	mov	fp, r2
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80044ae:	f7fe fbdf 	bl	8002c70 <prvTraceGetDTS>
	if (! RecorderDataPtr->recorderActive)
 80044b2:	6833      	ldr	r3, [r6, #0]
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
 80044b4:	9001      	str	r0, [sp, #4]
	if (! RecorderDataPtr->recorderActive)
 80044b6:	469a      	mov	sl, r3
 80044b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
		handle_of_last_logged_task = task_handle;
 80044ba:	703c      	strb	r4, [r7, #0]
	if (! RecorderDataPtr->recorderActive)
 80044bc:	2b00      	cmp	r3, #0
 80044be:	d0bb      	beq.n	8004438 <prvTraceStoreTaskswitch+0x38>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 80044c0:	4653      	mov	r3, sl
 80044c2:	69db      	ldr	r3, [r3, #28]
 80044c4:	4699      	mov	r9, r3
 80044c6:	23fa      	movs	r3, #250	; 0xfa
 80044c8:	009b      	lsls	r3, r3, #2
 80044ca:	4599      	cmp	r9, r3
 80044cc:	d300      	bcc.n	80044d0 <prvTraceStoreTaskswitch+0xd0>
 80044ce:	e083      	b.n	80045d8 <prvTraceStoreTaskswitch+0x1d8>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 80044d0:	2353      	movs	r3, #83	; 0x53
 80044d2:	4652      	mov	r2, sl
 80044d4:	5cd3      	ldrb	r3, [r2, r3]
 80044d6:	42a3      	cmp	r3, r4
 80044d8:	d351      	bcc.n	800457e <prvTraceStoreTaskswitch+0x17e>
	return TRACE_PROPERTY_OBJECT_STATE(objectclass, id);
 80044da:	2103      	movs	r1, #3
 80044dc:	0020      	movs	r0, r4
 80044de:	f7ff ff1b 	bl	8004318 <uiIndexOfObject>
 80044e2:	6833      	ldr	r3, [r6, #0]
 80044e4:	4450      	add	r0, sl
 80044e6:	469b      	mov	fp, r3
 80044e8:	235f      	movs	r3, #95	; 0x5f
 80044ea:	465a      	mov	r2, fp
 80044ec:	5cd3      	ldrb	r3, [r2, r3]
 80044ee:	18c0      	adds	r0, r0, r3
 80044f0:	3088      	adds	r0, #136	; 0x88
			if (prvTraceGetObjectState(TRACE_CLASS_TASK,
 80044f2:	7802      	ldrb	r2, [r0, #0]
				ts->type = TS_TASK_BEGIN;
 80044f4:	3a01      	subs	r2, #1
 80044f6:	4253      	negs	r3, r2
 80044f8:	415a      	adcs	r2, r3
 80044fa:	3206      	adds	r2, #6
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
 80044fc:	496c      	ldr	r1, [pc, #432]	; (80046b0 <prvTraceStoreTaskswitch+0x2b0>)
 80044fe:	464b      	mov	r3, r9
 8004500:	468c      	mov	ip, r1
 8004502:	009b      	lsls	r3, r3, #2
 8004504:	4463      	add	r3, ip
 8004506:	4453      	add	r3, sl
 8004508:	701a      	strb	r2, [r3, #0]
			ts->dts = dts3;
 800450a:	9a01      	ldr	r2, [sp, #4]
			ts->objHandle = hnd8;
 800450c:	705c      	strb	r4, [r3, #1]
			ts->dts = dts3;
 800450e:	805a      	strh	r2, [r3, #2]
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8004510:	2353      	movs	r3, #83	; 0x53
 8004512:	465a      	mov	r2, fp
			prvTraceSetObjectState(TRACE_CLASS_TASK,
 8004514:	7838      	ldrb	r0, [r7, #0]
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8004516:	5cd3      	ldrb	r3, [r2, r3]
 8004518:	4283      	cmp	r3, r0
 800451a:	d322      	bcc.n	8004562 <prvTraceStoreTaskswitch+0x162>
	TRACE_PROPERTY_OBJECT_STATE(objectclass, id) = value;
 800451c:	2103      	movs	r1, #3
 800451e:	f7ff fefb 	bl	8004318 <uiIndexOfObject>
 8004522:	225f      	movs	r2, #95	; 0x5f
 8004524:	2101      	movs	r1, #1
 8004526:	6833      	ldr	r3, [r6, #0]
 8004528:	4458      	add	r0, fp
 800452a:	5c9a      	ldrb	r2, [r3, r2]
 800452c:	1880      	adds	r0, r0, r2
 800452e:	3088      	adds	r0, #136	; 0x88
 8004530:	7001      	strb	r1, [r0, #0]
	if (RecorderDataPtr->recorderActive == 0)
 8004532:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004534:	2a00      	cmp	r2, #0
 8004536:	d100      	bne.n	800453a <prvTraceStoreTaskswitch+0x13a>
 8004538:	e77e      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800453a:	21fa      	movs	r1, #250	; 0xfa
	RecorderDataPtr->numEvents++;
 800453c:	695a      	ldr	r2, [r3, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800453e:	0089      	lsls	r1, r1, #2
	RecorderDataPtr->numEvents++;
 8004540:	3201      	adds	r2, #1
 8004542:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
 8004544:	69da      	ldr	r2, [r3, #28]
 8004546:	3201      	adds	r2, #1
 8004548:	61da      	str	r2, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
 800454a:	428a      	cmp	r2, r1
 800454c:	d200      	bcs.n	8004550 <prvTraceStoreTaskswitch+0x150>
 800454e:	e773      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		RecorderDataPtr->recorderActive = 0;
 8004550:	2200      	movs	r2, #0
 8004552:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004554:	4b50      	ldr	r3, [pc, #320]	; (8004698 <prvTraceStoreTaskswitch+0x298>)
 8004556:	681b      	ldr	r3, [r3, #0]
 8004558:	2b00      	cmp	r3, #0
 800455a:	d100      	bne.n	800455e <prvTraceStoreTaskswitch+0x15e>
 800455c:	e76c      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800455e:	4798      	blx	r3
 8004560:	e76a      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		RecorderDataPtr->recorderActive = 0;
 8004562:	2300      	movs	r3, #0
 8004564:	465a      	mov	r2, fp
 8004566:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004568:	4b4b      	ldr	r3, [pc, #300]	; (8004698 <prvTraceStoreTaskswitch+0x298>)
 800456a:	681b      	ldr	r3, [r3, #0]
 800456c:	2b00      	cmp	r3, #0
 800456e:	d07f      	beq.n	8004670 <prvTraceStoreTaskswitch+0x270>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004570:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004572:	4a4a      	ldr	r2, [pc, #296]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 8004574:	6813      	ldr	r3, [r2, #0]
 8004576:	2b00      	cmp	r3, #0
 8004578:	d057      	beq.n	800462a <prvTraceStoreTaskswitch+0x22a>
	if (RecorderDataPtr->recorderActive == 0)
 800457a:	6833      	ldr	r3, [r6, #0]
 800457c:	e7d9      	b.n	8004532 <prvTraceStoreTaskswitch+0x132>
		RecorderDataPtr->recorderActive = 0;
 800457e:	4653      	mov	r3, sl
 8004580:	465a      	mov	r2, fp
 8004582:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004584:	4b44      	ldr	r3, [pc, #272]	; (8004698 <prvTraceStoreTaskswitch+0x298>)
 8004586:	681b      	ldr	r3, [r3, #0]
 8004588:	2b00      	cmp	r3, #0
 800458a:	d06a      	beq.n	8004662 <prvTraceStoreTaskswitch+0x262>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800458c:	4798      	blx	r3
		if (RecorderDataPtr != NULL)
 800458e:	6833      	ldr	r3, [r6, #0]
				ts->type = TS_TASK_BEGIN;
 8004590:	2206      	movs	r2, #6
		if (RecorderDataPtr != NULL)
 8004592:	469b      	mov	fp, r3
	if (traceErrorMessage == NULL)
 8004594:	4b41      	ldr	r3, [pc, #260]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 8004596:	6819      	ldr	r1, [r3, #0]
 8004598:	2900      	cmp	r1, #0
 800459a:	d1af      	bne.n	80044fc <prvTraceStoreTaskswitch+0xfc>
		traceErrorMessage = (char*)(intptr_t) msg;
 800459c:	4945      	ldr	r1, [pc, #276]	; (80046b4 <prvTraceStoreTaskswitch+0x2b4>)
 800459e:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 80045a0:	465b      	mov	r3, fp
 80045a2:	2b00      	cmp	r3, #0
 80045a4:	d0aa      	beq.n	80044fc <prvTraceStoreTaskswitch+0xfc>
		dst[i] = src[i];
 80045a6:	23ce      	movs	r3, #206	; 0xce
 80045a8:	4659      	mov	r1, fp
 80045aa:	2254      	movs	r2, #84	; 0x54
 80045ac:	00db      	lsls	r3, r3, #3
 80045ae:	54ca      	strb	r2, [r1, r3]
 80045b0:	2300      	movs	r3, #0
 80045b2:	493c      	ldr	r1, [pc, #240]	; (80046a4 <prvTraceStoreTaskswitch+0x2a4>)
 80045b4:	4840      	ldr	r0, [pc, #256]	; (80046b8 <prvTraceStoreTaskswitch+0x2b8>)
 80045b6:	4459      	add	r1, fp
 80045b8:	5cc2      	ldrb	r2, [r0, r3]
 80045ba:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80045bc:	3301      	adds	r3, #1
 80045be:	2a00      	cmp	r2, #0
 80045c0:	d001      	beq.n	80045c6 <prvTraceStoreTaskswitch+0x1c6>
	for (i = 0; i < maxLength; i++)
 80045c2:	2b4f      	cmp	r3, #79	; 0x4f
 80045c4:	d1f8      	bne.n	80045b8 <prvTraceStoreTaskswitch+0x1b8>
			RecorderDataPtr->internalErrorOccured = 1;
 80045c6:	6833      	ldr	r3, [r6, #0]
 80045c8:	2201      	movs	r2, #1
 80045ca:	469b      	mov	fp, r3
 80045cc:	23cd      	movs	r3, #205	; 0xcd
 80045ce:	4659      	mov	r1, fp
 80045d0:	00db      	lsls	r3, r3, #3
 80045d2:	50ca      	str	r2, [r1, r3]
				ts->type = TS_TASK_BEGIN;
 80045d4:	3205      	adds	r2, #5
 80045d6:	e791      	b.n	80044fc <prvTraceStoreTaskswitch+0xfc>
		RecorderDataPtr->recorderActive = 0;
 80045d8:	4653      	mov	r3, sl
 80045da:	465a      	mov	r2, fp
 80045dc:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80045de:	4b2e      	ldr	r3, [pc, #184]	; (8004698 <prvTraceStoreTaskswitch+0x298>)
 80045e0:	681b      	ldr	r3, [r3, #0]
 80045e2:	2b00      	cmp	r3, #0
 80045e4:	d000      	beq.n	80045e8 <prvTraceStoreTaskswitch+0x1e8>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80045e6:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80045e8:	4b2c      	ldr	r3, [pc, #176]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 80045ea:	681a      	ldr	r2, [r3, #0]
 80045ec:	2a00      	cmp	r2, #0
 80045ee:	d000      	beq.n	80045f2 <prvTraceStoreTaskswitch+0x1f2>
 80045f0:	e722      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		traceErrorMessage = (char*)(intptr_t) msg;
 80045f2:	4832      	ldr	r0, [pc, #200]	; (80046bc <prvTraceStoreTaskswitch+0x2bc>)
		if (RecorderDataPtr != NULL)
 80045f4:	6831      	ldr	r1, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80045f6:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80045f8:	2900      	cmp	r1, #0
 80045fa:	d100      	bne.n	80045fe <prvTraceStoreTaskswitch+0x1fe>
 80045fc:	e71c      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		dst[i] = src[i];
 80045fe:	23ce      	movs	r3, #206	; 0xce
 8004600:	3241      	adds	r2, #65	; 0x41
 8004602:	00db      	lsls	r3, r3, #3
 8004604:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004606:	4a27      	ldr	r2, [pc, #156]	; (80046a4 <prvTraceStoreTaskswitch+0x2a4>)
		dst[i] = src[i];
 8004608:	2300      	movs	r3, #0
 800460a:	4694      	mov	ip, r2
 800460c:	3001      	adds	r0, #1
 800460e:	4461      	add	r1, ip
 8004610:	5cc2      	ldrb	r2, [r0, r3]
 8004612:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004614:	3301      	adds	r3, #1
 8004616:	2a00      	cmp	r2, #0
 8004618:	d001      	beq.n	800461e <prvTraceStoreTaskswitch+0x21e>
	for (i = 0; i < maxLength; i++)
 800461a:	2b4f      	cmp	r3, #79	; 0x4f
 800461c:	d1f8      	bne.n	8004610 <prvTraceStoreTaskswitch+0x210>
			RecorderDataPtr->internalErrorOccured = 1;
 800461e:	23cd      	movs	r3, #205	; 0xcd
 8004620:	2101      	movs	r1, #1
 8004622:	6832      	ldr	r2, [r6, #0]
 8004624:	00db      	lsls	r3, r3, #3
 8004626:	50d1      	str	r1, [r2, r3]
		if (ts != NULL)
 8004628:	e706      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		traceErrorMessage = (char*)(intptr_t) msg;
 800462a:	4925      	ldr	r1, [pc, #148]	; (80046c0 <prvTraceStoreTaskswitch+0x2c0>)
	if (RecorderDataPtr->recorderActive == 0)
 800462c:	6833      	ldr	r3, [r6, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 800462e:	6011      	str	r1, [r2, #0]
		if (RecorderDataPtr != NULL)
 8004630:	2b00      	cmp	r3, #0
 8004632:	d100      	bne.n	8004636 <prvTraceStoreTaskswitch+0x236>
 8004634:	e77d      	b.n	8004532 <prvTraceStoreTaskswitch+0x132>
		dst[i] = src[i];
 8004636:	22ce      	movs	r2, #206	; 0xce
 8004638:	2154      	movs	r1, #84	; 0x54
 800463a:	00d2      	lsls	r2, r2, #3
 800463c:	5499      	strb	r1, [r3, r2]
	for (i = 0; i < maxLength; i++)
 800463e:	4919      	ldr	r1, [pc, #100]	; (80046a4 <prvTraceStoreTaskswitch+0x2a4>)
		dst[i] = src[i];
 8004640:	2200      	movs	r2, #0
 8004642:	468c      	mov	ip, r1
 8004644:	481f      	ldr	r0, [pc, #124]	; (80046c4 <prvTraceStoreTaskswitch+0x2c4>)
 8004646:	4463      	add	r3, ip
 8004648:	5c81      	ldrb	r1, [r0, r2]
 800464a:	5499      	strb	r1, [r3, r2]
		if (src[i] == 0)
 800464c:	3201      	adds	r2, #1
 800464e:	2900      	cmp	r1, #0
 8004650:	d001      	beq.n	8004656 <prvTraceStoreTaskswitch+0x256>
	for (i = 0; i < maxLength; i++)
 8004652:	2a4f      	cmp	r2, #79	; 0x4f
 8004654:	d1f8      	bne.n	8004648 <prvTraceStoreTaskswitch+0x248>
			RecorderDataPtr->internalErrorOccured = 1;
 8004656:	22cd      	movs	r2, #205	; 0xcd
 8004658:	2101      	movs	r1, #1
 800465a:	6833      	ldr	r3, [r6, #0]
 800465c:	00d2      	lsls	r2, r2, #3
 800465e:	5099      	str	r1, [r3, r2]
 8004660:	e767      	b.n	8004532 <prvTraceStoreTaskswitch+0x132>
	if (traceErrorMessage == NULL)
 8004662:	4b0e      	ldr	r3, [pc, #56]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 8004664:	681a      	ldr	r2, [r3, #0]
 8004666:	2a00      	cmp	r2, #0
 8004668:	d00b      	beq.n	8004682 <prvTraceStoreTaskswitch+0x282>
 800466a:	46d3      	mov	fp, sl
				ts->type = TS_TASK_BEGIN;
 800466c:	2206      	movs	r2, #6
 800466e:	e745      	b.n	80044fc <prvTraceStoreTaskswitch+0xfc>
	if (traceErrorMessage == NULL)
 8004670:	4b0a      	ldr	r3, [pc, #40]	; (800469c <prvTraceStoreTaskswitch+0x29c>)
 8004672:	681a      	ldr	r2, [r3, #0]
 8004674:	2a00      	cmp	r2, #0
 8004676:	d000      	beq.n	800467a <prvTraceStoreTaskswitch+0x27a>
 8004678:	e6de      	b.n	8004438 <prvTraceStoreTaskswitch+0x38>
		traceErrorMessage = (char*)(intptr_t) msg;
 800467a:	4a11      	ldr	r2, [pc, #68]	; (80046c0 <prvTraceStoreTaskswitch+0x2c0>)
 800467c:	601a      	str	r2, [r3, #0]
 800467e:	465b      	mov	r3, fp
 8004680:	e7d9      	b.n	8004636 <prvTraceStoreTaskswitch+0x236>
 8004682:	4a0c      	ldr	r2, [pc, #48]	; (80046b4 <prvTraceStoreTaskswitch+0x2b4>)
 8004684:	46d3      	mov	fp, sl
 8004686:	601a      	str	r2, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004688:	e78d      	b.n	80045a6 <prvTraceStoreTaskswitch+0x1a6>
 800468a:	46c0      	nop			; (mov r8, r8)
 800468c:	20003480 	.word	0x20003480
 8004690:	200033fc 	.word	0x200033fc
 8004694:	200033f4 	.word	0x200033f4
 8004698:	20003498 	.word	0x20003498
 800469c:	20003488 	.word	0x20003488
 80046a0:	08006868 	.word	0x08006868
 80046a4:	00000671 	.word	0x00000671
 80046a8:	20003404 	.word	0x20003404
 80046ac:	0000ffff 	.word	0x0000ffff
 80046b0:	000006c4 	.word	0x000006c4
 80046b4:	080068b0 	.word	0x080068b0
 80046b8:	080068b1 	.word	0x080068b1
 80046bc:	080061c4 	.word	0x080061c4
 80046c0:	080067a4 	.word	0x080067a4
 80046c4:	080067a5 	.word	0x080067a5

080046c8 <prvTraceGetObjectHandle>:
{
 80046c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80046ca:	4647      	mov	r7, r8
 80046cc:	46ce      	mov	lr, r9
 80046ce:	b580      	push	{r7, lr}
	TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized, call vTraceEnable() first!", (traceHandle)0);
 80046d0:	4f54      	ldr	r7, [pc, #336]	; (8004824 <prvTraceGetObjectHandle+0x15c>)
{
 80046d2:	0003      	movs	r3, r0
	TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized, call vTraceEnable() first!", (traceHandle)0);
 80046d4:	683a      	ldr	r2, [r7, #0]
 80046d6:	2a00      	cmp	r2, #0
 80046d8:	d100      	bne.n	80046dc <prvTraceGetObjectHandle+0x14>
 80046da:	e09a      	b.n	8004812 <prvTraceGetObjectHandle+0x14a>
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
 80046dc:	2808      	cmp	r0, #8
 80046de:	d900      	bls.n	80046e2 <prvTraceGetObjectHandle+0x1a>
 80046e0:	e06e      	b.n	80047c0 <prvTraceGetObjectHandle+0xf8>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80046e2:	f3ef 8910 	mrs	r9, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80046e6:	2201      	movs	r2, #1
 80046e8:	f382 8810 	msr	PRIMASK, r2
	trcCRITICAL_SECTION_BEGIN();
 80046ec:	4c4e      	ldr	r4, [pc, #312]	; (8004828 <prvTraceGetObjectHandle+0x160>)
	indexOfHandle = objectHandleStacks.indexOfNextAvailableHandle[objectclass];
 80046ee:	494f      	ldr	r1, [pc, #316]	; (800482c <prvTraceGetObjectHandle+0x164>)
	trcCRITICAL_SECTION_BEGIN();
 80046f0:	6822      	ldr	r2, [r4, #0]
 80046f2:	3201      	adds	r2, #1
 80046f4:	6022      	str	r2, [r4, #0]
	indexOfHandle = objectHandleStacks.indexOfNextAvailableHandle[objectclass];
 80046f6:	0042      	lsls	r2, r0, #1
 80046f8:	4694      	mov	ip, r2
 80046fa:	5a8a      	ldrh	r2, [r1, r2]
	if (objectHandleStacks.objectHandles[indexOfHandle] == 0)
 80046fc:	188e      	adds	r6, r1, r2
 80046fe:	3648      	adds	r6, #72	; 0x48
 8004700:	7830      	ldrb	r0, [r6, #0]
 8004702:	2800      	cmp	r0, #0
 8004704:	d10f      	bne.n	8004726 <prvTraceGetObjectHandle+0x5e>
			objectHandleStacks.lowestIndexOfClass[objectclass]);
 8004706:	3008      	adds	r0, #8
 8004708:	4680      	mov	r8, r0
 800470a:	4498      	add	r8, r3
 800470c:	4640      	mov	r0, r8
 800470e:	0040      	lsls	r0, r0, #1
 8004710:	4680      	mov	r8, r0
 8004712:	4488      	add	r8, r1
			(traceHandle)(1 + indexOfHandle -
 8004714:	4640      	mov	r0, r8
 8004716:	8840      	ldrh	r0, [r0, #2]
 8004718:	1c55      	adds	r5, r2, #1
 800471a:	4680      	mov	r8, r0
 800471c:	0028      	movs	r0, r5
 800471e:	4645      	mov	r5, r8
 8004720:	1b40      	subs	r0, r0, r5
 8004722:	b2c0      	uxtb	r0, r0
		objectHandleStacks.objectHandles[indexOfHandle] =
 8004724:	7030      	strb	r0, [r6, #0]
		> objectHandleStacks.highestIndexOfClass[objectclass])
 8004726:	001e      	movs	r6, r3
 8004728:	3610      	adds	r6, #16
 800472a:	0076      	lsls	r6, r6, #1
 800472c:	198e      	adds	r6, r1, r6
	if (objectHandleStacks.indexOfNextAvailableHandle[objectclass]
 800472e:	88b6      	ldrh	r6, [r6, #4]
 8004730:	4296      	cmp	r6, r2
 8004732:	d31a      	bcc.n	800476a <prvTraceGetObjectHandle+0xa2>
		objectHandleStacks.indexOfNextAvailableHandle[objectclass]++;
 8004734:	4666      	mov	r6, ip
 8004736:	3201      	adds	r2, #1
 8004738:	b292      	uxth	r2, r2
 800473a:	538a      	strh	r2, [r1, r6]
			objectHandleStacks.lowestIndexOfClass[objectclass];
 800473c:	001e      	movs	r6, r3
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
 800473e:	3318      	adds	r3, #24
			objectHandleStacks.lowestIndexOfClass[objectclass];
 8004740:	3608      	adds	r6, #8
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
 8004742:	005b      	lsls	r3, r3, #1
			objectHandleStacks.lowestIndexOfClass[objectclass];
 8004744:	0076      	lsls	r6, r6, #1
 8004746:	198e      	adds	r6, r1, r6
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
 8004748:	18c9      	adds	r1, r1, r3
			objectHandleStacks.lowestIndexOfClass[objectclass];
 800474a:	8876      	ldrh	r6, [r6, #2]
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
 800474c:	88cb      	ldrh	r3, [r1, #6]
		hndCount = objectHandleStacks.indexOfNextAvailableHandle[objectclass] -
 800474e:	1b92      	subs	r2, r2, r6
		if (hndCount >
 8004750:	4293      	cmp	r3, r2
 8004752:	da01      	bge.n	8004758 <prvTraceGetObjectHandle+0x90>
				(traceHandle)hndCount;
 8004754:	b2d2      	uxtb	r2, r2
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass] =
 8004756:	80ca      	strh	r2, [r1, #6]
	trcCRITICAL_SECTION_END();
 8004758:	6823      	ldr	r3, [r4, #0]
 800475a:	3b01      	subs	r3, #1
 800475c:	6023      	str	r3, [r4, #0]
 800475e:	f389 8810 	msr	PRIMASK, r9
}
 8004762:	bcc0      	pop	{r6, r7}
 8004764:	46b9      	mov	r9, r7
 8004766:	46b0      	mov	r8, r6
 8004768:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
 800476a:	0018      	movs	r0, r3
 800476c:	f7fe fa74 	bl	8002c58 <pszTraceGetErrorNotEnoughHandles>
	if (RecorderDataPtr != NULL)
 8004770:	683b      	ldr	r3, [r7, #0]
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
 8004772:	0006      	movs	r6, r0
	if (RecorderDataPtr != NULL)
 8004774:	2b00      	cmp	r3, #0
 8004776:	d006      	beq.n	8004786 <prvTraceGetObjectHandle+0xbe>
		RecorderDataPtr->recorderActive = 0;
 8004778:	2200      	movs	r2, #0
 800477a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 800477c:	4b2c      	ldr	r3, [pc, #176]	; (8004830 <prvTraceGetObjectHandle+0x168>)
 800477e:	681b      	ldr	r3, [r3, #0]
 8004780:	2b00      	cmp	r3, #0
 8004782:	d000      	beq.n	8004786 <prvTraceGetObjectHandle+0xbe>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004784:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004786:	4b2b      	ldr	r3, [pc, #172]	; (8004834 <prvTraceGetObjectHandle+0x16c>)
 8004788:	681a      	ldr	r2, [r3, #0]
 800478a:	2a00      	cmp	r2, #0
 800478c:	d001      	beq.n	8004792 <prvTraceGetObjectHandle+0xca>
		handle = 0;
 800478e:	2000      	movs	r0, #0
 8004790:	e7e2      	b.n	8004758 <prvTraceGetObjectHandle+0x90>
		if (RecorderDataPtr != NULL)
 8004792:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004794:	601e      	str	r6, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004796:	2900      	cmp	r1, #0
 8004798:	d0f9      	beq.n	800478e <prvTraceGetObjectHandle+0xc6>
 800479a:	22ce      	movs	r2, #206	; 0xce
 800479c:	00d2      	lsls	r2, r2, #3
 800479e:	4694      	mov	ip, r2
	for (i = 0; i < maxLength; i++)
 80047a0:	2300      	movs	r3, #0
 80047a2:	4461      	add	r1, ip
		dst[i] = src[i];
 80047a4:	5cf2      	ldrb	r2, [r6, r3]
 80047a6:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80047a8:	2a00      	cmp	r2, #0
 80047aa:	d002      	beq.n	80047b2 <prvTraceGetObjectHandle+0xea>
	for (i = 0; i < maxLength; i++)
 80047ac:	3301      	adds	r3, #1
 80047ae:	2b50      	cmp	r3, #80	; 0x50
 80047b0:	d1f8      	bne.n	80047a4 <prvTraceGetObjectHandle+0xdc>
			RecorderDataPtr->internalErrorOccured = 1;
 80047b2:	23cd      	movs	r3, #205	; 0xcd
 80047b4:	2101      	movs	r1, #1
 80047b6:	683a      	ldr	r2, [r7, #0]
 80047b8:	00db      	lsls	r3, r3, #3
		handle = 0;
 80047ba:	2000      	movs	r0, #0
			RecorderDataPtr->internalErrorOccured = 1;
 80047bc:	50d1      	str	r1, [r2, r3]
 80047be:	e7cb      	b.n	8004758 <prvTraceGetObjectHandle+0x90>
		RecorderDataPtr->recorderActive = 0;
 80047c0:	2300      	movs	r3, #0
 80047c2:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80047c4:	4b1a      	ldr	r3, [pc, #104]	; (8004830 <prvTraceGetObjectHandle+0x168>)
 80047c6:	681b      	ldr	r3, [r3, #0]
 80047c8:	2b00      	cmp	r3, #0
 80047ca:	d000      	beq.n	80047ce <prvTraceGetObjectHandle+0x106>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80047cc:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80047ce:	4b19      	ldr	r3, [pc, #100]	; (8004834 <prvTraceGetObjectHandle+0x16c>)
 80047d0:	681a      	ldr	r2, [r3, #0]
 80047d2:	2a00      	cmp	r2, #0
 80047d4:	d001      	beq.n	80047da <prvTraceGetObjectHandle+0x112>
	TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized, call vTraceEnable() first!", (traceHandle)0);
 80047d6:	2000      	movs	r0, #0
}
 80047d8:	e7c3      	b.n	8004762 <prvTraceGetObjectHandle+0x9a>
		traceErrorMessage = (char*)(intptr_t) msg;
 80047da:	4817      	ldr	r0, [pc, #92]	; (8004838 <prvTraceGetObjectHandle+0x170>)
		if (RecorderDataPtr != NULL)
 80047dc:	6839      	ldr	r1, [r7, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80047de:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 80047e0:	2900      	cmp	r1, #0
 80047e2:	d0f8      	beq.n	80047d6 <prvTraceGetObjectHandle+0x10e>
		dst[i] = src[i];
 80047e4:	23ce      	movs	r3, #206	; 0xce
 80047e6:	3254      	adds	r2, #84	; 0x54
 80047e8:	00db      	lsls	r3, r3, #3
 80047ea:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 80047ec:	4a13      	ldr	r2, [pc, #76]	; (800483c <prvTraceGetObjectHandle+0x174>)
		dst[i] = src[i];
 80047ee:	2300      	movs	r3, #0
 80047f0:	4694      	mov	ip, r2
 80047f2:	3001      	adds	r0, #1
 80047f4:	4461      	add	r1, ip
 80047f6:	5cc2      	ldrb	r2, [r0, r3]
 80047f8:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80047fa:	3301      	adds	r3, #1
 80047fc:	2a00      	cmp	r2, #0
 80047fe:	d001      	beq.n	8004804 <prvTraceGetObjectHandle+0x13c>
	for (i = 0; i < maxLength; i++)
 8004800:	2b4f      	cmp	r3, #79	; 0x4f
 8004802:	d1f8      	bne.n	80047f6 <prvTraceGetObjectHandle+0x12e>
			RecorderDataPtr->internalErrorOccured = 1;
 8004804:	23cd      	movs	r3, #205	; 0xcd
 8004806:	2101      	movs	r1, #1
 8004808:	683a      	ldr	r2, [r7, #0]
 800480a:	00db      	lsls	r3, r3, #3
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
 800480c:	2000      	movs	r0, #0
			RecorderDataPtr->internalErrorOccured = 1;
 800480e:	50d1      	str	r1, [r2, r3]
 8004810:	e7a7      	b.n	8004762 <prvTraceGetObjectHandle+0x9a>
	if (traceErrorMessage == NULL)
 8004812:	4b08      	ldr	r3, [pc, #32]	; (8004834 <prvTraceGetObjectHandle+0x16c>)
 8004814:	681a      	ldr	r2, [r3, #0]
 8004816:	2a00      	cmp	r2, #0
 8004818:	d1dd      	bne.n	80047d6 <prvTraceGetObjectHandle+0x10e>
		traceErrorMessage = (char*)(intptr_t) msg;
 800481a:	4a09      	ldr	r2, [pc, #36]	; (8004840 <prvTraceGetObjectHandle+0x178>)
	TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized, call vTraceEnable() first!", (traceHandle)0);
 800481c:	2000      	movs	r0, #0
		traceErrorMessage = (char*)(intptr_t) msg;
 800481e:	601a      	str	r2, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004820:	e79f      	b.n	8004762 <prvTraceGetObjectHandle+0x9a>
 8004822:	46c0      	nop			; (mov r8, r8)
 8004824:	200033f4 	.word	0x200033f4
 8004828:	20003480 	.word	0x20003480
 800482c:	20003414 	.word	0x20003414
 8004830:	20003498 	.word	0x20003498
 8004834:	20003488 	.word	0x20003488
 8004838:	080068ec 	.word	0x080068ec
 800483c:	00000671 	.word	0x00000671
 8004840:	080061ec 	.word	0x080061ec

08004844 <prvMarkObjectAsUsed>:
{
 8004844:	b570      	push	{r4, r5, r6, lr}
	if (RecorderDataPtr != NULL)
 8004846:	4c43      	ldr	r4, [pc, #268]	; (8004954 <prvMarkObjectAsUsed+0x110>)
 8004848:	6822      	ldr	r2, [r4, #0]
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
 800484a:	2808      	cmp	r0, #8
 800484c:	d83d      	bhi.n	80048ca <prvMarkObjectAsUsed+0x86>
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
 800484e:	2900      	cmp	r1, #0
 8004850:	d066      	beq.n	8004920 <prvMarkObjectAsUsed+0xdc>
 8004852:	1813      	adds	r3, r2, r0
 8004854:	001d      	movs	r5, r3
 8004856:	3550      	adds	r5, #80	; 0x50
 8004858:	782d      	ldrb	r5, [r5, #0]
 800485a:	428d      	cmp	r5, r1
 800485c:	d226      	bcs.n	80048ac <prvMarkObjectAsUsed+0x68>
		RecorderDataPtr->recorderActive = 0;
 800485e:	2300      	movs	r3, #0
 8004860:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004862:	4b3d      	ldr	r3, [pc, #244]	; (8004958 <prvMarkObjectAsUsed+0x114>)
 8004864:	681b      	ldr	r3, [r3, #0]
 8004866:	2b00      	cmp	r3, #0
 8004868:	d064      	beq.n	8004934 <prvMarkObjectAsUsed+0xf0>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 800486a:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 800486c:	493b      	ldr	r1, [pc, #236]	; (800495c <prvMarkObjectAsUsed+0x118>)
 800486e:	2300      	movs	r3, #0
 8004870:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8004872:	6822      	ldr	r2, [r4, #0]
	if (traceErrorMessage == NULL)
 8004874:	2800      	cmp	r0, #0
 8004876:	d123      	bne.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004878:	4839      	ldr	r0, [pc, #228]	; (8004960 <prvMarkObjectAsUsed+0x11c>)
 800487a:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 800487c:	2a00      	cmp	r2, #0
 800487e:	d01f      	beq.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		dst[i] = src[i];
 8004880:	23ce      	movs	r3, #206	; 0xce
 8004882:	2154      	movs	r1, #84	; 0x54
 8004884:	00db      	lsls	r3, r3, #3
 8004886:	54d1      	strb	r1, [r2, r3]
 8004888:	2300      	movs	r3, #0
 800488a:	4936      	ldr	r1, [pc, #216]	; (8004964 <prvMarkObjectAsUsed+0x120>)
 800488c:	4836      	ldr	r0, [pc, #216]	; (8004968 <prvMarkObjectAsUsed+0x124>)
 800488e:	1851      	adds	r1, r2, r1
 8004890:	5cc2      	ldrb	r2, [r0, r3]
 8004892:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004894:	3301      	adds	r3, #1
 8004896:	2a00      	cmp	r2, #0
 8004898:	d001      	beq.n	800489e <prvMarkObjectAsUsed+0x5a>
	for (i = 0; i < maxLength; i++)
 800489a:	2b4f      	cmp	r3, #79	; 0x4f
 800489c:	d1f8      	bne.n	8004890 <prvMarkObjectAsUsed+0x4c>
			RecorderDataPtr->internalErrorOccured = 1;
 800489e:	23cd      	movs	r3, #205	; 0xcd
 80048a0:	2101      	movs	r1, #1
 80048a2:	6822      	ldr	r2, [r4, #0]
 80048a4:	00db      	lsls	r3, r3, #3
 80048a6:	50d1      	str	r1, [r2, r3]
 80048a8:	2300      	movs	r3, #0
 80048aa:	e009      	b.n	80048c0 <prvMarkObjectAsUsed+0x7c>
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 80048ac:	3368      	adds	r3, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 80048ae:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 80048b0:	3901      	subs	r1, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 80048b2:	3038      	adds	r0, #56	; 0x38
 80048b4:	434b      	muls	r3, r1
 80048b6:	0040      	lsls	r0, r0, #1
 80048b8:	1810      	adds	r0, r2, r0
 80048ba:	8881      	ldrh	r1, [r0, #4]
 80048bc:	185b      	adds	r3, r3, r1
	RecorderDataPtr->ObjectPropertyTable.objbytes[idx] = 1;
 80048be:	b29b      	uxth	r3, r3
 80048c0:	18d3      	adds	r3, r2, r3
 80048c2:	2201      	movs	r2, #1
 80048c4:	3388      	adds	r3, #136	; 0x88
 80048c6:	701a      	strb	r2, [r3, #0]
}
 80048c8:	bd70      	pop	{r4, r5, r6, pc}
	if (RecorderDataPtr != NULL)
 80048ca:	2a00      	cmp	r2, #0
 80048cc:	d020      	beq.n	8004910 <prvMarkObjectAsUsed+0xcc>
		RecorderDataPtr->recorderActive = 0;
 80048ce:	2300      	movs	r3, #0
 80048d0:	6313      	str	r3, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80048d2:	4b21      	ldr	r3, [pc, #132]	; (8004958 <prvMarkObjectAsUsed+0x114>)
 80048d4:	681b      	ldr	r3, [r3, #0]
 80048d6:	2b00      	cmp	r3, #0
 80048d8:	d035      	beq.n	8004946 <prvMarkObjectAsUsed+0x102>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80048da:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80048dc:	491f      	ldr	r1, [pc, #124]	; (800495c <prvMarkObjectAsUsed+0x118>)
 80048de:	2300      	movs	r3, #0
 80048e0:	6808      	ldr	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 80048e2:	6822      	ldr	r2, [r4, #0]
	if (traceErrorMessage == NULL)
 80048e4:	2800      	cmp	r0, #0
 80048e6:	d1eb      	bne.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		traceErrorMessage = (char*)(intptr_t) msg;
 80048e8:	4820      	ldr	r0, [pc, #128]	; (800496c <prvMarkObjectAsUsed+0x128>)
 80048ea:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 80048ec:	2a00      	cmp	r2, #0
 80048ee:	d0e7      	beq.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		dst[i] = src[i];
 80048f0:	23ce      	movs	r3, #206	; 0xce
 80048f2:	2154      	movs	r1, #84	; 0x54
 80048f4:	00db      	lsls	r3, r3, #3
 80048f6:	54d1      	strb	r1, [r2, r3]
 80048f8:	2300      	movs	r3, #0
 80048fa:	491a      	ldr	r1, [pc, #104]	; (8004964 <prvMarkObjectAsUsed+0x120>)
 80048fc:	481c      	ldr	r0, [pc, #112]	; (8004970 <prvMarkObjectAsUsed+0x12c>)
 80048fe:	1851      	adds	r1, r2, r1
 8004900:	5cc2      	ldrb	r2, [r0, r3]
 8004902:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004904:	3301      	adds	r3, #1
 8004906:	2a00      	cmp	r2, #0
 8004908:	d0c9      	beq.n	800489e <prvMarkObjectAsUsed+0x5a>
	for (i = 0; i < maxLength; i++)
 800490a:	2b4f      	cmp	r3, #79	; 0x4f
 800490c:	d1f8      	bne.n	8004900 <prvMarkObjectAsUsed+0xbc>
 800490e:	e7c6      	b.n	800489e <prvMarkObjectAsUsed+0x5a>
	if (traceErrorMessage == NULL)
 8004910:	4912      	ldr	r1, [pc, #72]	; (800495c <prvMarkObjectAsUsed+0x118>)
 8004912:	2300      	movs	r3, #0
 8004914:	6808      	ldr	r0, [r1, #0]
 8004916:	2800      	cmp	r0, #0
 8004918:	d1d2      	bne.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		traceErrorMessage = (char*)(intptr_t) msg;
 800491a:	4814      	ldr	r0, [pc, #80]	; (800496c <prvMarkObjectAsUsed+0x128>)
 800491c:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 800491e:	e7cf      	b.n	80048c0 <prvMarkObjectAsUsed+0x7c>
	if (RecorderDataPtr != NULL)
 8004920:	2a00      	cmp	r2, #0
 8004922:	d19c      	bne.n	800485e <prvMarkObjectAsUsed+0x1a>
	if (traceErrorMessage == NULL)
 8004924:	490d      	ldr	r1, [pc, #52]	; (800495c <prvMarkObjectAsUsed+0x118>)
 8004926:	2300      	movs	r3, #0
 8004928:	6808      	ldr	r0, [r1, #0]
 800492a:	2800      	cmp	r0, #0
 800492c:	d1c8      	bne.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		traceErrorMessage = (char*)(intptr_t) msg;
 800492e:	480c      	ldr	r0, [pc, #48]	; (8004960 <prvMarkObjectAsUsed+0x11c>)
 8004930:	6008      	str	r0, [r1, #0]
		if (RecorderDataPtr != NULL)
 8004932:	e7c5      	b.n	80048c0 <prvMarkObjectAsUsed+0x7c>
	if (traceErrorMessage == NULL)
 8004934:	4b09      	ldr	r3, [pc, #36]	; (800495c <prvMarkObjectAsUsed+0x118>)
 8004936:	6819      	ldr	r1, [r3, #0]
 8004938:	2900      	cmp	r1, #0
 800493a:	d001      	beq.n	8004940 <prvMarkObjectAsUsed+0xfc>
 800493c:	2300      	movs	r3, #0
 800493e:	e7bf      	b.n	80048c0 <prvMarkObjectAsUsed+0x7c>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004940:	4907      	ldr	r1, [pc, #28]	; (8004960 <prvMarkObjectAsUsed+0x11c>)
 8004942:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004944:	e79c      	b.n	8004880 <prvMarkObjectAsUsed+0x3c>
	if (traceErrorMessage == NULL)
 8004946:	4b05      	ldr	r3, [pc, #20]	; (800495c <prvMarkObjectAsUsed+0x118>)
 8004948:	6819      	ldr	r1, [r3, #0]
 800494a:	2900      	cmp	r1, #0
 800494c:	d1f6      	bne.n	800493c <prvMarkObjectAsUsed+0xf8>
		traceErrorMessage = (char*)(intptr_t) msg;
 800494e:	4907      	ldr	r1, [pc, #28]	; (800496c <prvMarkObjectAsUsed+0x128>)
 8004950:	6019      	str	r1, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004952:	e7cd      	b.n	80048f0 <prvMarkObjectAsUsed+0xac>
 8004954:	200033f4 	.word	0x200033f4
 8004958:	20003498 	.word	0x20003498
 800495c:	20003488 	.word	0x20003488
 8004960:	08006314 	.word	0x08006314
 8004964:	00000671 	.word	0x00000671
 8004968:	08006315 	.word	0x08006315
 800496c:	08006828 	.word	0x08006828
 8004970:	08006829 	.word	0x08006829

08004974 <prvTraceSetObjectName>:
{
 8004974:	b570      	push	{r4, r5, r6, lr}
	if (RecorderDataPtr != NULL)
 8004976:	4c60      	ldr	r4, [pc, #384]	; (8004af8 <prvTraceSetObjectName+0x184>)
 8004978:	6823      	ldr	r3, [r4, #0]
	TRACE_ASSERT(name != NULL, "prvTraceSetObjectName: name == NULL", TRC_UNUSED);
 800497a:	2a00      	cmp	r2, #0
 800497c:	d100      	bne.n	8004980 <prvTraceSetObjectName+0xc>
 800497e:	e07a      	b.n	8004a76 <prvTraceSetObjectName+0x102>
	if (objectclass >= TRACE_NCLASSES)
 8004980:	2808      	cmp	r0, #8
 8004982:	d833      	bhi.n	80049ec <prvTraceSetObjectName+0x78>
	if (handle == 0)
 8004984:	2900      	cmp	r1, #0
 8004986:	d054      	beq.n	8004a32 <prvTraceSetObjectName+0xbe>
	if (handle > RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass])
 8004988:	181d      	adds	r5, r3, r0
 800498a:	002e      	movs	r6, r5
 800498c:	3650      	adds	r6, #80	; 0x50
 800498e:	7836      	ldrb	r6, [r6, #0]
 8004990:	428e      	cmp	r6, r1
 8004992:	d226      	bcs.n	80049e2 <prvTraceSetObjectName+0x6e>
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
 8004994:	f7fe f960 	bl	8002c58 <pszTraceGetErrorNotEnoughHandles>
	if (RecorderDataPtr != NULL)
 8004998:	6823      	ldr	r3, [r4, #0]
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
 800499a:	0005      	movs	r5, r0
	if (RecorderDataPtr != NULL)
 800499c:	2b00      	cmp	r3, #0
 800499e:	d006      	beq.n	80049ae <prvTraceSetObjectName+0x3a>
		RecorderDataPtr->recorderActive = 0;
 80049a0:	2200      	movs	r2, #0
 80049a2:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80049a4:	4b55      	ldr	r3, [pc, #340]	; (8004afc <prvTraceSetObjectName+0x188>)
 80049a6:	681b      	ldr	r3, [r3, #0]
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	d000      	beq.n	80049ae <prvTraceSetObjectName+0x3a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80049ac:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80049ae:	4b54      	ldr	r3, [pc, #336]	; (8004b00 <prvTraceSetObjectName+0x18c>)
 80049b0:	681a      	ldr	r2, [r3, #0]
 80049b2:	2a00      	cmp	r2, #0
 80049b4:	d119      	bne.n	80049ea <prvTraceSetObjectName+0x76>
		if (RecorderDataPtr != NULL)
 80049b6:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 80049b8:	601d      	str	r5, [r3, #0]
		if (RecorderDataPtr != NULL)
 80049ba:	2900      	cmp	r1, #0
 80049bc:	d015      	beq.n	80049ea <prvTraceSetObjectName+0x76>
 80049be:	22ce      	movs	r2, #206	; 0xce
 80049c0:	00d2      	lsls	r2, r2, #3
 80049c2:	4694      	mov	ip, r2
	for (i = 0; i < maxLength; i++)
 80049c4:	2300      	movs	r3, #0
 80049c6:	4461      	add	r1, ip
		dst[i] = src[i];
 80049c8:	5cea      	ldrb	r2, [r5, r3]
 80049ca:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 80049cc:	2a00      	cmp	r2, #0
 80049ce:	d002      	beq.n	80049d6 <prvTraceSetObjectName+0x62>
	for (i = 0; i < maxLength; i++)
 80049d0:	3301      	adds	r3, #1
 80049d2:	2b50      	cmp	r3, #80	; 0x50
 80049d4:	d1f8      	bne.n	80049c8 <prvTraceSetObjectName+0x54>
			RecorderDataPtr->internalErrorOccured = 1;
 80049d6:	23cd      	movs	r3, #205	; 0xcd
 80049d8:	2101      	movs	r1, #1
 80049da:	6822      	ldr	r2, [r4, #0]
 80049dc:	00db      	lsls	r3, r3, #3
 80049de:	50d1      	str	r1, [r2, r3]
 80049e0:	e003      	b.n	80049ea <prvTraceSetObjectName+0x76>
		if (traceErrorMessage == NULL)
 80049e2:	4c47      	ldr	r4, [pc, #284]	; (8004b00 <prvTraceSetObjectName+0x18c>)
 80049e4:	6824      	ldr	r4, [r4, #0]
 80049e6:	2c00      	cmp	r4, #0
 80049e8:	d068      	beq.n	8004abc <prvTraceSetObjectName+0x148>
}
 80049ea:	bd70      	pop	{r4, r5, r6, pc}
	if (RecorderDataPtr != NULL)
 80049ec:	2b00      	cmp	r3, #0
 80049ee:	d006      	beq.n	80049fe <prvTraceSetObjectName+0x8a>
		RecorderDataPtr->recorderActive = 0;
 80049f0:	2200      	movs	r2, #0
 80049f2:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 80049f4:	4b41      	ldr	r3, [pc, #260]	; (8004afc <prvTraceSetObjectName+0x188>)
 80049f6:	681b      	ldr	r3, [r3, #0]
 80049f8:	2b00      	cmp	r3, #0
 80049fa:	d000      	beq.n	80049fe <prvTraceSetObjectName+0x8a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 80049fc:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 80049fe:	4b40      	ldr	r3, [pc, #256]	; (8004b00 <prvTraceSetObjectName+0x18c>)
 8004a00:	681a      	ldr	r2, [r3, #0]
 8004a02:	2a00      	cmp	r2, #0
 8004a04:	d1f1      	bne.n	80049ea <prvTraceSetObjectName+0x76>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a06:	483f      	ldr	r0, [pc, #252]	; (8004b04 <prvTraceSetObjectName+0x190>)
		if (RecorderDataPtr != NULL)
 8004a08:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a0a:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004a0c:	2900      	cmp	r1, #0
 8004a0e:	d0ec      	beq.n	80049ea <prvTraceSetObjectName+0x76>
		dst[i] = src[i];
 8004a10:	23ce      	movs	r3, #206	; 0xce
 8004a12:	3249      	adds	r2, #73	; 0x49
 8004a14:	00db      	lsls	r3, r3, #3
 8004a16:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004a18:	4a3b      	ldr	r2, [pc, #236]	; (8004b08 <prvTraceSetObjectName+0x194>)
		dst[i] = src[i];
 8004a1a:	2300      	movs	r3, #0
 8004a1c:	4694      	mov	ip, r2
 8004a1e:	3001      	adds	r0, #1
 8004a20:	4461      	add	r1, ip
 8004a22:	5cc2      	ldrb	r2, [r0, r3]
 8004a24:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004a26:	3301      	adds	r3, #1
 8004a28:	2a00      	cmp	r2, #0
 8004a2a:	d0d4      	beq.n	80049d6 <prvTraceSetObjectName+0x62>
	for (i = 0; i < maxLength; i++)
 8004a2c:	2b4f      	cmp	r3, #79	; 0x4f
 8004a2e:	d1f8      	bne.n	8004a22 <prvTraceSetObjectName+0xae>
 8004a30:	e7d1      	b.n	80049d6 <prvTraceSetObjectName+0x62>
	if (RecorderDataPtr != NULL)
 8004a32:	2b00      	cmp	r3, #0
 8004a34:	d005      	beq.n	8004a42 <prvTraceSetObjectName+0xce>
		RecorderDataPtr->recorderActive = 0;
 8004a36:	6319      	str	r1, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004a38:	4b30      	ldr	r3, [pc, #192]	; (8004afc <prvTraceSetObjectName+0x188>)
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	2b00      	cmp	r3, #0
 8004a3e:	d000      	beq.n	8004a42 <prvTraceSetObjectName+0xce>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004a40:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004a42:	4b2f      	ldr	r3, [pc, #188]	; (8004b00 <prvTraceSetObjectName+0x18c>)
 8004a44:	681a      	ldr	r2, [r3, #0]
 8004a46:	2a00      	cmp	r2, #0
 8004a48:	d1cf      	bne.n	80049ea <prvTraceSetObjectName+0x76>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a4a:	4830      	ldr	r0, [pc, #192]	; (8004b0c <prvTraceSetObjectName+0x198>)
		if (RecorderDataPtr != NULL)
 8004a4c:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a4e:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004a50:	2900      	cmp	r1, #0
 8004a52:	d0ca      	beq.n	80049ea <prvTraceSetObjectName+0x76>
		dst[i] = src[i];
 8004a54:	23ce      	movs	r3, #206	; 0xce
 8004a56:	3249      	adds	r2, #73	; 0x49
 8004a58:	00db      	lsls	r3, r3, #3
 8004a5a:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004a5c:	4a2a      	ldr	r2, [pc, #168]	; (8004b08 <prvTraceSetObjectName+0x194>)
		dst[i] = src[i];
 8004a5e:	2300      	movs	r3, #0
 8004a60:	4694      	mov	ip, r2
 8004a62:	3001      	adds	r0, #1
 8004a64:	4461      	add	r1, ip
 8004a66:	5cc2      	ldrb	r2, [r0, r3]
 8004a68:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004a6a:	3301      	adds	r3, #1
 8004a6c:	2a00      	cmp	r2, #0
 8004a6e:	d0b2      	beq.n	80049d6 <prvTraceSetObjectName+0x62>
	for (i = 0; i < maxLength; i++)
 8004a70:	2b4f      	cmp	r3, #79	; 0x4f
 8004a72:	d1f8      	bne.n	8004a66 <prvTraceSetObjectName+0xf2>
 8004a74:	e7af      	b.n	80049d6 <prvTraceSetObjectName+0x62>
	if (RecorderDataPtr != NULL)
 8004a76:	2b00      	cmp	r3, #0
 8004a78:	d005      	beq.n	8004a86 <prvTraceSetObjectName+0x112>
		RecorderDataPtr->recorderActive = 0;
 8004a7a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004a7c:	4b1f      	ldr	r3, [pc, #124]	; (8004afc <prvTraceSetObjectName+0x188>)
 8004a7e:	681b      	ldr	r3, [r3, #0]
 8004a80:	2b00      	cmp	r3, #0
 8004a82:	d000      	beq.n	8004a86 <prvTraceSetObjectName+0x112>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004a84:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004a86:	4b1e      	ldr	r3, [pc, #120]	; (8004b00 <prvTraceSetObjectName+0x18c>)
 8004a88:	681a      	ldr	r2, [r3, #0]
 8004a8a:	2a00      	cmp	r2, #0
 8004a8c:	d1ad      	bne.n	80049ea <prvTraceSetObjectName+0x76>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a8e:	4820      	ldr	r0, [pc, #128]	; (8004b10 <prvTraceSetObjectName+0x19c>)
		if (RecorderDataPtr != NULL)
 8004a90:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004a92:	6018      	str	r0, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004a94:	2900      	cmp	r1, #0
 8004a96:	d0a8      	beq.n	80049ea <prvTraceSetObjectName+0x76>
		dst[i] = src[i];
 8004a98:	23ce      	movs	r3, #206	; 0xce
 8004a9a:	3254      	adds	r2, #84	; 0x54
 8004a9c:	00db      	lsls	r3, r3, #3
 8004a9e:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004aa0:	4a19      	ldr	r2, [pc, #100]	; (8004b08 <prvTraceSetObjectName+0x194>)
		dst[i] = src[i];
 8004aa2:	2300      	movs	r3, #0
 8004aa4:	4694      	mov	ip, r2
 8004aa6:	3001      	adds	r0, #1
 8004aa8:	4461      	add	r1, ip
 8004aaa:	5cc2      	ldrb	r2, [r0, r3]
 8004aac:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004aae:	3301      	adds	r3, #1
 8004ab0:	2a00      	cmp	r2, #0
 8004ab2:	d100      	bne.n	8004ab6 <prvTraceSetObjectName+0x142>
 8004ab4:	e78f      	b.n	80049d6 <prvTraceSetObjectName+0x62>
	for (i = 0; i < maxLength; i++)
 8004ab6:	2b4f      	cmp	r3, #79	; 0x4f
 8004ab8:	d1f7      	bne.n	8004aaa <prvTraceSetObjectName+0x136>
 8004aba:	e78c      	b.n	80049d6 <prvTraceSetObjectName+0x62>
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8004abc:	002c      	movs	r4, r5
 8004abe:	3468      	adds	r4, #104	; 0x68
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8004ac0:	7824      	ldrb	r4, [r4, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
 8004ac2:	3901      	subs	r1, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8004ac4:	3038      	adds	r0, #56	; 0x38
 8004ac6:	4361      	muls	r1, r4
 8004ac8:	0040      	lsls	r0, r0, #1
 8004aca:	1818      	adds	r0, r3, r0
 8004acc:	8880      	ldrh	r0, [r0, #4]
				RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[ objectclass ]);
 8004ace:	355c      	adds	r5, #92	; 0x5c
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
 8004ad0:	1809      	adds	r1, r1, r0
			prvStrncpy((char*)&(RecorderDataPtr->ObjectPropertyTable.objbytes[idx]),
 8004ad2:	b289      	uxth	r1, r1
 8004ad4:	782c      	ldrb	r4, [r5, #0]
 8004ad6:	3188      	adds	r1, #136	; 0x88
 8004ad8:	1858      	adds	r0, r3, r1
	for (i = 0; i < maxLength; i++)
 8004ada:	2c00      	cmp	r4, #0
 8004adc:	d100      	bne.n	8004ae0 <prvTraceSetObjectName+0x16c>
 8004ade:	e784      	b.n	80049ea <prvTraceSetObjectName+0x76>
 8004ae0:	2300      	movs	r3, #0
 8004ae2:	e003      	b.n	8004aec <prvTraceSetObjectName+0x178>
 8004ae4:	3301      	adds	r3, #1
 8004ae6:	429c      	cmp	r4, r3
 8004ae8:	d800      	bhi.n	8004aec <prvTraceSetObjectName+0x178>
 8004aea:	e77e      	b.n	80049ea <prvTraceSetObjectName+0x76>
		dst[i] = src[i];
 8004aec:	5cd1      	ldrb	r1, [r2, r3]
 8004aee:	54c1      	strb	r1, [r0, r3]
		if (src[i] == 0)
 8004af0:	2900      	cmp	r1, #0
 8004af2:	d1f7      	bne.n	8004ae4 <prvTraceSetObjectName+0x170>
 8004af4:	e779      	b.n	80049ea <prvTraceSetObjectName+0x76>
 8004af6:	46c0      	nop			; (mov r8, r8)
 8004af8:	200033f4 	.word	0x200033f4
 8004afc:	20003498 	.word	0x20003498
 8004b00:	20003488 	.word	0x20003488
 8004b04:	08006968 	.word	0x08006968
 8004b08:	00000671 	.word	0x00000671
 8004b0c:	080062a4 	.word	0x080062a4
 8004b10:	08006934 	.word	0x08006934

08004b14 <vTraceStart>:
{
 8004b14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b16:	46d6      	mov	lr, sl
 8004b18:	464f      	mov	r7, r9
 8004b1a:	4646      	mov	r6, r8
	if (RecorderDataPtr == NULL)
 8004b1c:	4c3b      	ldr	r4, [pc, #236]	; (8004c0c <vTraceStart+0xf8>)
{
 8004b1e:	b5c0      	push	{r6, r7, lr}
	if (RecorderDataPtr == NULL)
 8004b20:	6823      	ldr	r3, [r4, #0]
 8004b22:	2b00      	cmp	r3, #0
 8004b24:	d02a      	beq.n	8004b7c <vTraceStart+0x68>
	if (RecorderDataPtr->recorderActive == 1)
 8004b26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004b28:	2b01      	cmp	r3, #1
 8004b2a:	d003      	beq.n	8004b34 <vTraceStart+0x20>
	if (traceErrorMessage == NULL)
 8004b2c:	4e38      	ldr	r6, [pc, #224]	; (8004c10 <vTraceStart+0xfc>)
 8004b2e:	6835      	ldr	r5, [r6, #0]
 8004b30:	2d00      	cmp	r5, #0
 8004b32:	d004      	beq.n	8004b3e <vTraceStart+0x2a>
}
 8004b34:	bce0      	pop	{r5, r6, r7}
 8004b36:	46ba      	mov	sl, r7
 8004b38:	46b1      	mov	r9, r6
 8004b3a:	46a8      	mov	r8, r5
 8004b3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004b3e:	f3ef 8910 	mrs	r9, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b42:	2201      	movs	r2, #1
 8004b44:	f382 8810 	msr	PRIMASK, r2
		trcCRITICAL_SECTION_BEGIN();
 8004b48:	4b32      	ldr	r3, [pc, #200]	; (8004c14 <vTraceStart+0x100>)
 8004b4a:	4698      	mov	r8, r3
 8004b4c:	4641      	mov	r1, r8
 8004b4e:	681b      	ldr	r3, [r3, #0]
 8004b50:	3301      	adds	r3, #1
 8004b52:	600b      	str	r3, [r1, #0]
		RecorderDataPtr->recorderActive = 1;
 8004b54:	6823      	ldr	r3, [r4, #0]
 8004b56:	631a      	str	r2, [r3, #48]	; 0x30
		handle = TRACE_GET_TASK_NUMBER(TRACE_GET_CURRENT_TASK());
 8004b58:	f7fd ffe2 	bl	8002b20 <prvTraceGetCurrentTaskHandle>
 8004b5c:	f7fd ff94 	bl	8002a88 <prvTraceGetTaskNumberLow16>
 8004b60:	b2c7      	uxtb	r7, r0
		if (handle == 0)
 8004b62:	2f00      	cmp	r7, #0
 8004b64:	d011      	beq.n	8004b8a <vTraceStart+0x76>
		prvTraceStoreTaskswitch(handle); /* Register the currently running task */
 8004b66:	0038      	movs	r0, r7
 8004b68:	f7ff fc4a 	bl	8004400 <prvTraceStoreTaskswitch>
		trcCRITICAL_SECTION_END();
 8004b6c:	4643      	mov	r3, r8
 8004b6e:	4642      	mov	r2, r8
 8004b70:	681b      	ldr	r3, [r3, #0]
 8004b72:	3b01      	subs	r3, #1
 8004b74:	6013      	str	r3, [r2, #0]
 8004b76:	f389 8810 	msr	PRIMASK, r9
}
 8004b7a:	e7db      	b.n	8004b34 <vTraceStart+0x20>
	if (traceErrorMessage == NULL)
 8004b7c:	4b24      	ldr	r3, [pc, #144]	; (8004c10 <vTraceStart+0xfc>)
 8004b7e:	681a      	ldr	r2, [r3, #0]
 8004b80:	2a00      	cmp	r2, #0
 8004b82:	d1d7      	bne.n	8004b34 <vTraceStart+0x20>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004b84:	4a24      	ldr	r2, [pc, #144]	; (8004c18 <vTraceStart+0x104>)
 8004b86:	601a      	str	r2, [r3, #0]
}
 8004b88:	e7d4      	b.n	8004b34 <vTraceStart+0x20>
			handle = prvTraceGetObjectHandle(TRACE_CLASS_TASK);
 8004b8a:	2003      	movs	r0, #3
 8004b8c:	f7ff fd9c 	bl	80046c8 <prvTraceGetObjectHandle>
			prvTraceSetObjectName(TRACE_CLASS_TASK, handle, "(startup)");
 8004b90:	4a22      	ldr	r2, [pc, #136]	; (8004c1c <vTraceStart+0x108>)
 8004b92:	0001      	movs	r1, r0
			handle = prvTraceGetObjectHandle(TRACE_CLASS_TASK);
 8004b94:	0007      	movs	r7, r0
			prvTraceSetObjectName(TRACE_CLASS_TASK, handle, "(startup)");
 8004b96:	2003      	movs	r0, #3
 8004b98:	f7ff feec 	bl	8004974 <prvTraceSetObjectName>
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
 8004b9c:	6823      	ldr	r3, [r4, #0]
 8004b9e:	469a      	mov	sl, r3
 8004ba0:	2353      	movs	r3, #83	; 0x53
 8004ba2:	4652      	mov	r2, sl
 8004ba4:	5cd3      	ldrb	r3, [r2, r3]
 8004ba6:	42bb      	cmp	r3, r7
 8004ba8:	d30b      	bcc.n	8004bc2 <vTraceStart+0xae>
	TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id) = value;
 8004baa:	2103      	movs	r1, #3
 8004bac:	0038      	movs	r0, r7
 8004bae:	f7ff fbb3 	bl	8004318 <uiIndexOfObject>
 8004bb2:	235f      	movs	r3, #95	; 0x5f
 8004bb4:	6822      	ldr	r2, [r4, #0]
 8004bb6:	4450      	add	r0, sl
 8004bb8:	5cd3      	ldrb	r3, [r2, r3]
 8004bba:	18c0      	adds	r0, r0, r3
 8004bbc:	3089      	adds	r0, #137	; 0x89
 8004bbe:	7005      	strb	r5, [r0, #0]
 8004bc0:	e7d1      	b.n	8004b66 <vTraceStart+0x52>
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004bc2:	4b17      	ldr	r3, [pc, #92]	; (8004c20 <vTraceStart+0x10c>)
		RecorderDataPtr->recorderActive = 0;
 8004bc4:	6315      	str	r5, [r2, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	2b00      	cmp	r3, #0
 8004bca:	d000      	beq.n	8004bce <vTraceStart+0xba>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004bcc:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004bce:	6833      	ldr	r3, [r6, #0]
 8004bd0:	2b00      	cmp	r3, #0
 8004bd2:	d1c8      	bne.n	8004b66 <vTraceStart+0x52>
		traceErrorMessage = (char*)(intptr_t) msg;
 8004bd4:	4813      	ldr	r0, [pc, #76]	; (8004c24 <vTraceStart+0x110>)
		if (RecorderDataPtr != NULL)
 8004bd6:	6821      	ldr	r1, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004bd8:	6030      	str	r0, [r6, #0]
		if (RecorderDataPtr != NULL)
 8004bda:	2900      	cmp	r1, #0
 8004bdc:	d0c3      	beq.n	8004b66 <vTraceStart+0x52>
		dst[i] = src[i];
 8004bde:	23ce      	movs	r3, #206	; 0xce
 8004be0:	2254      	movs	r2, #84	; 0x54
 8004be2:	00db      	lsls	r3, r3, #3
 8004be4:	54ca      	strb	r2, [r1, r3]
	for (i = 0; i < maxLength; i++)
 8004be6:	4a10      	ldr	r2, [pc, #64]	; (8004c28 <vTraceStart+0x114>)
		dst[i] = src[i];
 8004be8:	2300      	movs	r3, #0
 8004bea:	4694      	mov	ip, r2
 8004bec:	3001      	adds	r0, #1
 8004bee:	4461      	add	r1, ip
 8004bf0:	5cc2      	ldrb	r2, [r0, r3]
 8004bf2:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004bf4:	3301      	adds	r3, #1
 8004bf6:	2a00      	cmp	r2, #0
 8004bf8:	d001      	beq.n	8004bfe <vTraceStart+0xea>
	for (i = 0; i < maxLength; i++)
 8004bfa:	2b4f      	cmp	r3, #79	; 0x4f
 8004bfc:	d1f8      	bne.n	8004bf0 <vTraceStart+0xdc>
			RecorderDataPtr->internalErrorOccured = 1;
 8004bfe:	23cd      	movs	r3, #205	; 0xcd
 8004c00:	2101      	movs	r1, #1
 8004c02:	6822      	ldr	r2, [r4, #0]
 8004c04:	00db      	lsls	r3, r3, #3
 8004c06:	50d1      	str	r1, [r2, r3]
 8004c08:	e7ad      	b.n	8004b66 <vTraceStart+0x52>
 8004c0a:	46c0      	nop			; (mov r8, r8)
 8004c0c:	200033f4 	.word	0x200033f4
 8004c10:	20003488 	.word	0x20003488
 8004c14:	20003480 	.word	0x20003480
 8004c18:	08006998 	.word	0x08006998
 8004c1c:	080069dc 	.word	0x080069dc
 8004c20:	20003498 	.word	0x20003498
 8004c24:	080062d4 	.word	0x080062d4
 8004c28:	00000671 	.word	0x00000671

08004c2c <prvTraceError>:
{
 8004c2c:	b570      	push	{r4, r5, r6, lr}
	if (RecorderDataPtr != NULL)
 8004c2e:	4d13      	ldr	r5, [pc, #76]	; (8004c7c <prvTraceError+0x50>)
{
 8004c30:	0004      	movs	r4, r0
	if (RecorderDataPtr != NULL)
 8004c32:	682b      	ldr	r3, [r5, #0]
 8004c34:	2b00      	cmp	r3, #0
 8004c36:	d006      	beq.n	8004c46 <prvTraceError+0x1a>
		RecorderDataPtr->recorderActive = 0;
 8004c38:	2200      	movs	r2, #0
 8004c3a:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
 8004c3c:	4b10      	ldr	r3, [pc, #64]	; (8004c80 <prvTraceError+0x54>)
 8004c3e:	681b      	ldr	r3, [r3, #0]
 8004c40:	2b00      	cmp	r3, #0
 8004c42:	d000      	beq.n	8004c46 <prvTraceError+0x1a>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
 8004c44:	4798      	blx	r3
	if (traceErrorMessage == NULL)
 8004c46:	4b0f      	ldr	r3, [pc, #60]	; (8004c84 <prvTraceError+0x58>)
 8004c48:	681a      	ldr	r2, [r3, #0]
 8004c4a:	2a00      	cmp	r2, #0
 8004c4c:	d000      	beq.n	8004c50 <prvTraceError+0x24>
}
 8004c4e:	bd70      	pop	{r4, r5, r6, pc}
		if (RecorderDataPtr != NULL)
 8004c50:	6829      	ldr	r1, [r5, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
 8004c52:	601c      	str	r4, [r3, #0]
		if (RecorderDataPtr != NULL)
 8004c54:	2900      	cmp	r1, #0
 8004c56:	d0fa      	beq.n	8004c4e <prvTraceError+0x22>
 8004c58:	22ce      	movs	r2, #206	; 0xce
 8004c5a:	00d2      	lsls	r2, r2, #3
 8004c5c:	4694      	mov	ip, r2
	for (i = 0; i < maxLength; i++)
 8004c5e:	2300      	movs	r3, #0
 8004c60:	4461      	add	r1, ip
		dst[i] = src[i];
 8004c62:	5ce2      	ldrb	r2, [r4, r3]
 8004c64:	54ca      	strb	r2, [r1, r3]
		if (src[i] == 0)
 8004c66:	2a00      	cmp	r2, #0
 8004c68:	d002      	beq.n	8004c70 <prvTraceError+0x44>
	for (i = 0; i < maxLength; i++)
 8004c6a:	3301      	adds	r3, #1
 8004c6c:	2b50      	cmp	r3, #80	; 0x50
 8004c6e:	d1f8      	bne.n	8004c62 <prvTraceError+0x36>
			RecorderDataPtr->internalErrorOccured = 1;
 8004c70:	23cd      	movs	r3, #205	; 0xcd
 8004c72:	2101      	movs	r1, #1
 8004c74:	682a      	ldr	r2, [r5, #0]
 8004c76:	00db      	lsls	r3, r3, #3
 8004c78:	50d1      	str	r1, [r2, r3]
}
 8004c7a:	e7e8      	b.n	8004c4e <prvTraceError+0x22>
 8004c7c:	200033f4 	.word	0x200033f4
 8004c80:	20003498 	.word	0x20003498
 8004c84:	20003488 	.word	0x20003488

08004c88 <prvTracePortGetTimeStamp>:
{
 8004c88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c8a:	46c6      	mov	lr, r8
	if (trace_disable_timestamp == 1)
 8004c8c:	4b1f      	ldr	r3, [pc, #124]	; (8004d0c <prvTracePortGetTimeStamp+0x84>)
{
 8004c8e:	b500      	push	{lr}
	if (trace_disable_timestamp == 1)
 8004c90:	681b      	ldr	r3, [r3, #0]
 8004c92:	2b01      	cmp	r3, #1
 8004c94:	d033      	beq.n	8004cfe <prvTracePortGetTimeStamp+0x76>
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004c96:	4a1e      	ldr	r2, [pc, #120]	; (8004d10 <prvTracePortGetTimeStamp+0x88>)
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8004c98:	4b1e      	ldr	r3, [pc, #120]	; (8004d14 <prvTracePortGetTimeStamp+0x8c>)
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004c9a:	6812      	ldr	r2, [r2, #0]
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8004c9c:	6819      	ldr	r1, [r3, #0]
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004c9e:	43d4      	mvns	r4, r2
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8004ca0:	4b1d      	ldr	r3, [pc, #116]	; (8004d18 <prvTracePortGetTimeStamp+0x90>)
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004ca2:	4d1e      	ldr	r5, [pc, #120]	; (8004d1c <prvTracePortGetTimeStamp+0x94>)
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
 8004ca4:	681b      	ldr	r3, [r3, #0]
 8004ca6:	3101      	adds	r1, #1
 8004ca8:	1ac9      	subs	r1, r1, r3
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004caa:	682b      	ldr	r3, [r5, #0]
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
 8004cac:	4e1c      	ldr	r6, [pc, #112]	; (8004d20 <prvTracePortGetTimeStamp+0x98>)
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
 8004cae:	42dc      	cmn	r4, r3
 8004cb0:	d40b      	bmi.n	8004cca <prvTracePortGetTimeStamp+0x42>
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
 8004cb2:	6832      	ldr	r2, [r6, #0]
		traceTickCount++;
 8004cb4:	4291      	cmp	r1, r2
 8004cb6:	4192      	sbcs	r2, r2
 8004cb8:	4252      	negs	r2, r2
 8004cba:	189a      	adds	r2, r3, r2
	if (pTimestamp)
 8004cbc:	2800      	cmp	r0, #0
 8004cbe:	d108      	bne.n	8004cd2 <prvTracePortGetTimeStamp+0x4a>
	last_traceTickCount = traceTickCount;
 8004cc0:	602a      	str	r2, [r5, #0]
	last_hwtc_count = hwtc_count;
 8004cc2:	6031      	str	r1, [r6, #0]
}
 8004cc4:	bc80      	pop	{r7}
 8004cc6:	46b8      	mov	r8, r7
 8004cc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
 8004cca:	4293      	cmp	r3, r2
 8004ccc:	d0f1      	beq.n	8004cb2 <prvTracePortGetTimeStamp+0x2a>
	if (pTimestamp)
 8004cce:	2800      	cmp	r0, #0
 8004cd0:	d0f6      	beq.n	8004cc0 <prvTracePortGetTimeStamp+0x38>
		last_timestamp = traceTickCount * ((TRC_HWTC_PERIOD) / (TRC_HWTC_DIVISOR));
 8004cd2:	4b10      	ldr	r3, [pc, #64]	; (8004d14 <prvTracePortGetTimeStamp+0x8c>)
 8004cd4:	4f13      	ldr	r7, [pc, #76]	; (8004d24 <prvTracePortGetTimeStamp+0x9c>)
 8004cd6:	681c      	ldr	r4, [r3, #0]
 8004cd8:	3401      	adds	r4, #1
 8004cda:	08a4      	lsrs	r4, r4, #2
 8004cdc:	4354      	muls	r4, r2
 8004cde:	603c      	str	r4, [r7, #0]
		last_timestamp += (hwtc_count + traceTickCount * ((TRC_HWTC_PERIOD) % (TRC_HWTC_DIVISOR))) / (TRC_HWTC_DIVISOR);
 8004ce0:	681b      	ldr	r3, [r3, #0]
		last_timestamp = traceTickCount * ((TRC_HWTC_PERIOD) / (TRC_HWTC_DIVISOR));
 8004ce2:	46a0      	mov	r8, r4
		last_timestamp += (hwtc_count + traceTickCount * ((TRC_HWTC_PERIOD) % (TRC_HWTC_DIVISOR))) / (TRC_HWTC_DIVISOR);
 8004ce4:	3301      	adds	r3, #1
 8004ce6:	469c      	mov	ip, r3
 8004ce8:	2303      	movs	r3, #3
 8004cea:	4664      	mov	r4, ip
 8004cec:	4023      	ands	r3, r4
 8004cee:	4353      	muls	r3, r2
 8004cf0:	185b      	adds	r3, r3, r1
 8004cf2:	089b      	lsrs	r3, r3, #2
 8004cf4:	4443      	add	r3, r8
 8004cf6:	603b      	str	r3, [r7, #0]
	last_traceTickCount = traceTickCount;
 8004cf8:	602a      	str	r2, [r5, #0]
		*pTimestamp = last_timestamp;
 8004cfa:	6003      	str	r3, [r0, #0]
 8004cfc:	e7e1      	b.n	8004cc2 <prvTracePortGetTimeStamp+0x3a>
		if (pTimestamp)
 8004cfe:	2800      	cmp	r0, #0
 8004d00:	d0e0      	beq.n	8004cc4 <prvTracePortGetTimeStamp+0x3c>
			*pTimestamp = last_timestamp;
 8004d02:	4b08      	ldr	r3, [pc, #32]	; (8004d24 <prvTracePortGetTimeStamp+0x9c>)
 8004d04:	681b      	ldr	r3, [r3, #0]
 8004d06:	6003      	str	r3, [r0, #0]
 8004d08:	e7dc      	b.n	8004cc4 <prvTracePortGetTimeStamp+0x3c>
 8004d0a:	46c0      	nop			; (mov r8, r8)
 8004d0c:	2000348c 	.word	0x2000348c
 8004d10:	20003494 	.word	0x20003494
 8004d14:	e000e014 	.word	0xe000e014
 8004d18:	e000e018 	.word	0xe000e018
 8004d1c:	20003410 	.word	0x20003410
 8004d20:	20003408 	.word	0x20003408
 8004d24:	2000340c 	.word	0x2000340c

08004d28 <vTaskPalettiseur>:
	}
}


void vTaskPalettiseur(void *pvParameters)
{
 8004d28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004d2a:	464e      	mov	r6, r9
 8004d2c:	46de      	mov	lr, fp
 8004d2e:	4657      	mov	r7, sl
 8004d30:	4645      	mov	r5, r8
 8004d32:	b5e0      	push	{r5, r6, r7, lr}
 8004d34:	b08d      	sub	sp, #52	; 0x34
	portTickType xLastWakeTime;

	// Timing initialization
	xLastWakeTime = xTaskGetTickCount();
 8004d36:	f7fc fe31 	bl	800199c <xTaskGetTickCount>
 8004d3a:	4b72      	ldr	r3, [pc, #456]	; (8004f04 <vTaskPalettiseur+0x1dc>)
 8004d3c:	4f72      	ldr	r7, [pc, #456]	; (8004f08 <vTaskPalettiseur+0x1e0>)
 8004d3e:	4699      	mov	r9, r3
 8004d40:	4b72      	ldr	r3, [pc, #456]	; (8004f0c <vTaskPalettiseur+0x1e4>)
 8004d42:	4e73      	ldr	r6, [pc, #460]	; (8004f10 <vTaskPalettiseur+0x1e8>)
 8004d44:	9003      	str	r0, [sp, #12]

	command_message_t *m_cmd;
	command_message_t command;

	command.state = 0;
	command.mask = 0;
 8004d46:	ac09      	add	r4, sp, #36	; 0x24
 8004d48:	9301      	str	r3, [sp, #4]
{
 8004d4a:	2303      	movs	r3, #3
 8004d4c:	469b      	mov	fp, r3
	while (1)
	{
		for (int i = 0; i <3; i++)
		{
			//Turn on the cardboard distribution
			command.mask = Distribution_Cartons_MSK;
 8004d4e:	2201      	movs	r2, #1
 8004d50:	2301      	movs	r3, #1
 8004d52:	9206      	str	r2, [sp, #24]
 8004d54:	9307      	str	r3, [sp, #28]
			command.state = Distribution_Cartons_ON;
			m_cmd = &command;
 8004d56:	ab06      	add	r3, sp, #24
 8004d58:	9305      	str	r3, [sp, #20]
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004d5a:	464b      	mov	r3, r9
 8004d5c:	2200      	movs	r2, #0
 8004d5e:	6818      	ldr	r0, [r3, #0]
 8004d60:	a905      	add	r1, sp, #20
 8004d62:	2300      	movs	r3, #0
 8004d64:	f7fb fb88 	bl	8000478 <xQueueGenericSend>

			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Carton_Envoye_MSK;
 8004d68:	2302      	movs	r3, #2
			mPalletiseur.sem_id = 1;
 8004d6a:	2501      	movs	r5, #1
			mPalletiseur.sensor_id = Carton_Envoye_MSK;
 8004d6c:	6063      	str	r3, [r4, #4]
			mPalletiseur.sensor_state = Carton_Envoye_OFF;
 8004d6e:	2300      	movs	r3, #0
			ps = &mPalletiseur;

			// Send message to Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004d70:	2200      	movs	r2, #0
 8004d72:	a904      	add	r1, sp, #16
 8004d74:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sensor_state = Carton_Envoye_OFF;
 8004d76:	4698      	mov	r8, r3
 8004d78:	60a3      	str	r3, [r4, #8]
			mPalletiseur.sem_id = 1;
 8004d7a:	7025      	strb	r5, [r4, #0]
			ps = &mPalletiseur;
 8004d7c:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004d7e:	f7fb fb7b 	bl	8000478 <xQueueGenericSend>

			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004d82:	2101      	movs	r1, #1
 8004d84:	6830      	ldr	r0, [r6, #0]
 8004d86:	4249      	negs	r1, r1
 8004d88:	f7fc f8f2 	bl	8000f70 <xQueueSemaphoreTake>

			//Subscribe for the sensor change
			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Carton_Distribue_MSK;
			mPalletiseur.sensor_state = Carton_Distribue_OFF;
 8004d8c:	4643      	mov	r3, r8
			ps = &mPalletiseur;

			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004d8e:	2200      	movs	r2, #0
 8004d90:	a904      	add	r1, sp, #16
 8004d92:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sensor_state = Carton_Distribue_OFF;
 8004d94:	60a3      	str	r3, [r4, #8]
			mPalletiseur.sem_id = 1;
 8004d96:	7025      	strb	r5, [r4, #0]
			mPalletiseur.sensor_id = Carton_Distribue_MSK;
 8004d98:	6065      	str	r5, [r4, #4]
			ps = &mPalletiseur;
 8004d9a:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004d9c:	f7fb fb6c 	bl	8000478 <xQueueGenericSend>

			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004da0:	2101      	movs	r1, #1
 8004da2:	6830      	ldr	r0, [r6, #0]
 8004da4:	4249      	negs	r1, r1
 8004da6:	f7fc f8e3 	bl	8000f70 <xQueueSemaphoreTake>

			//Turn off the cardboard distribution
			command.mask = Distribution_Cartons_MSK;
 8004daa:	2201      	movs	r2, #1
 8004dac:	2300      	movs	r3, #0
 8004dae:	9206      	str	r2, [sp, #24]
 8004db0:	9307      	str	r3, [sp, #28]
			command.state = Distribution_Cartons_OFF;
			m_cmd = &command;
 8004db2:	ab06      	add	r3, sp, #24
 8004db4:	9305      	str	r3, [sp, #20]
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004db6:	464b      	mov	r3, r9
 8004db8:	2200      	movs	r2, #0
 8004dba:	6818      	ldr	r0, [r3, #0]
 8004dbc:	a905      	add	r1, sp, #20
 8004dbe:	2300      	movs	r3, #0
 8004dc0:	f7fb fb5a 	bl	8000478 <xQueueGenericSend>

			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Entree_Palettiseur_MSK;
 8004dc4:	2304      	movs	r3, #4
 8004dc6:	469a      	mov	sl, r3
 8004dc8:	6063      	str	r3, [r4, #4]
			mPalletiseur.sensor_state = Entree_Palettiseur_OFF;
 8004dca:	4643      	mov	r3, r8
			ps = &mPalletiseur;
			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004dcc:	2200      	movs	r2, #0
 8004dce:	a904      	add	r1, sp, #16
 8004dd0:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sensor_state = Entree_Palettiseur_OFF;
 8004dd2:	60a3      	str	r3, [r4, #8]
			mPalletiseur.sem_id = 1;
 8004dd4:	7025      	strb	r5, [r4, #0]
			ps = &mPalletiseur;
 8004dd6:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004dd8:	f7fb fb4e 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004ddc:	2101      	movs	r1, #1
 8004dde:	6830      	ldr	r0, [r6, #0]
 8004de0:	4249      	negs	r1, r1
 8004de2:	f7fc f8c5 	bl	8000f70 <xQueueSemaphoreTake>


			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Entree_Palettiseur_MSK;
 8004de6:	4653      	mov	r3, sl
			mPalletiseur.sensor_state = Entree_Palettiseur_ON;
			ps = &mPalletiseur;
			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004de8:	2200      	movs	r2, #0
			mPalletiseur.sensor_id = Entree_Palettiseur_MSK;
 8004dea:	6063      	str	r3, [r4, #4]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004dec:	a904      	add	r1, sp, #16
 8004dee:	2300      	movs	r3, #0
 8004df0:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sem_id = 1;
 8004df2:	7025      	strb	r5, [r4, #0]
			mPalletiseur.sensor_state = Entree_Palettiseur_ON;
 8004df4:	60a5      	str	r5, [r4, #8]
			ps = &mPalletiseur;
 8004df6:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004df8:	f7fb fb3e 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004dfc:	2101      	movs	r1, #1
 8004dfe:	6830      	ldr	r0, [r6, #0]
 8004e00:	4249      	negs	r1, r1
 8004e02:	f7fc f8b5 	bl	8000f70 <xQueueSemaphoreTake>


			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Entree_Palettiseur_MSK;
 8004e06:	4653      	mov	r3, sl
 8004e08:	6063      	str	r3, [r4, #4]
			mPalletiseur.sensor_state = Entree_Palettiseur_OFF;
 8004e0a:	4643      	mov	r3, r8
			ps = &mPalletiseur;
			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e0c:	2200      	movs	r2, #0
 8004e0e:	a904      	add	r1, sp, #16
 8004e10:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sensor_state = Entree_Palettiseur_OFF;
 8004e12:	60a3      	str	r3, [r4, #8]
			mPalletiseur.sem_id = 1;
 8004e14:	7025      	strb	r5, [r4, #0]
			ps = &mPalletiseur;
 8004e16:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e18:	f7fb fb2e 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004e1c:	2101      	movs	r1, #1
 8004e1e:	6830      	ldr	r0, [r6, #0]
 8004e20:	4249      	negs	r1, r1
 8004e22:	f7fc f8a5 	bl	8000f70 <xQueueSemaphoreTake>

			//Open the Blockage
			command.mask = (Blocage_Entree_Palettiseur_MSK | Charger_Palettetiseur_MSK);
 8004e26:	2380      	movs	r3, #128	; 0x80
 8004e28:	4a3a      	ldr	r2, [pc, #232]	; (8004f14 <vTaskPalettiseur+0x1ec>)
 8004e2a:	025b      	lsls	r3, r3, #9
 8004e2c:	9206      	str	r2, [sp, #24]
 8004e2e:	9307      	str	r3, [sp, #28]
			command.state = Blocage_Entree_Palettiseur_OFF | Charger_Palettetiseur_ON;
			m_cmd = &command;
 8004e30:	ab06      	add	r3, sp, #24
 8004e32:	9305      	str	r3, [sp, #20]
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004e34:	464b      	mov	r3, r9
 8004e36:	2200      	movs	r2, #0
 8004e38:	6818      	ldr	r0, [r3, #0]
 8004e3a:	a905      	add	r1, sp, #20
 8004e3c:	2300      	movs	r3, #0
 8004e3e:	f7fb fb1b 	bl	8000478 <xQueueGenericSend>

			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Butee_Carton_MSK;
 8004e42:	2380      	movs	r3, #128	; 0x80
 8004e44:	01db      	lsls	r3, r3, #7
			mPalletiseur.sensor_state = Butee_Carton_ON;
			ps = &mPalletiseur;
			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e46:	2200      	movs	r2, #0
			mPalletiseur.sensor_id = Butee_Carton_MSK;
 8004e48:	6063      	str	r3, [r4, #4]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e4a:	a904      	add	r1, sp, #16
 8004e4c:	2300      	movs	r3, #0
 8004e4e:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sem_id = 1;
 8004e50:	7025      	strb	r5, [r4, #0]
			mPalletiseur.sensor_state = Butee_Carton_ON;
 8004e52:	60a5      	str	r5, [r4, #8]
			ps = &mPalletiseur;
 8004e54:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e56:	f7fb fb0f 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004e5a:	2101      	movs	r1, #1
 8004e5c:	6830      	ldr	r0, [r6, #0]
 8004e5e:	4249      	negs	r1, r1
 8004e60:	f7fc f886 	bl	8000f70 <xQueueSemaphoreTake>

			//Close the barrier
			command.mask = (Blocage_Entree_Palettiseur_MSK | Charger_Palettetiseur_MSK | Poussoir_MSK);
 8004e64:	2314      	movs	r3, #20
 8004e66:	4a2c      	ldr	r2, [pc, #176]	; (8004f18 <vTaskPalettiseur+0x1f0>)
			command.state = Blocage_Entree_Palettiseur_ON | Charger_Palettetiseur_OFF| Poussoir_ON;
			m_cmd = &command;
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004e68:	a905      	add	r1, sp, #20
			command.mask = (Blocage_Entree_Palettiseur_MSK | Charger_Palettetiseur_MSK | Poussoir_MSK);
 8004e6a:	9206      	str	r2, [sp, #24]
 8004e6c:	9307      	str	r3, [sp, #28]
			m_cmd = &command;
 8004e6e:	ab06      	add	r3, sp, #24
 8004e70:	9305      	str	r3, [sp, #20]
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004e72:	464b      	mov	r3, r9
 8004e74:	2200      	movs	r2, #0
 8004e76:	6818      	ldr	r0, [r3, #0]
 8004e78:	2300      	movs	r3, #0
 8004e7a:	f7fb fafd 	bl	8000478 <xQueueGenericSend>

			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Limite_Poussoir_MSK;
 8004e7e:	2310      	movs	r3, #16
 8004e80:	469a      	mov	sl, r3
 8004e82:	6063      	str	r3, [r4, #4]
			mPalletiseur.sensor_state = Limite_Poussoir_OFF;
 8004e84:	4643      	mov	r3, r8
			ps = &mPalletiseur;

			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e86:	2200      	movs	r2, #0
 8004e88:	a904      	add	r1, sp, #16
 8004e8a:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sensor_state = Limite_Poussoir_OFF;
 8004e8c:	60a3      	str	r3, [r4, #8]
			mPalletiseur.sem_id = 1;
 8004e8e:	7025      	strb	r5, [r4, #0]
			ps = &mPalletiseur;
 8004e90:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004e92:	f7fb faf1 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004e96:	2101      	movs	r1, #1
 8004e98:	6830      	ldr	r0, [r6, #0]
 8004e9a:	4249      	negs	r1, r1
 8004e9c:	f7fc f868 	bl	8000f70 <xQueueSemaphoreTake>

			mPalletiseur.sem_id = 1;
			mPalletiseur.sensor_id = Limite_Poussoir_MSK;
 8004ea0:	4653      	mov	r3, sl
			mPalletiseur.sensor_state = Limite_Poussoir_ON;
			ps = &mPalletiseur;
			// Send message to the Subscribe Queue
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004ea2:	2200      	movs	r2, #0
			mPalletiseur.sensor_id = Limite_Poussoir_MSK;
 8004ea4:	6063      	str	r3, [r4, #4]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004ea6:	a904      	add	r1, sp, #16
 8004ea8:	2300      	movs	r3, #0
 8004eaa:	6838      	ldr	r0, [r7, #0]
			mPalletiseur.sem_id = 1;
 8004eac:	7025      	strb	r5, [r4, #0]
			mPalletiseur.sensor_state = Limite_Poussoir_ON;
 8004eae:	60a5      	str	r5, [r4, #8]
			ps = &mPalletiseur;
 8004eb0:	9404      	str	r4, [sp, #16]
			xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004eb2:	f7fb fae1 	bl	8000478 <xQueueGenericSend>
			// wait forever for the semaphore
			xSemaphoreTake(xSemCarton, portMAX_DELAY);
 8004eb6:	2101      	movs	r1, #1
 8004eb8:	6830      	ldr	r0, [r6, #0]
 8004eba:	4249      	negs	r1, r1
 8004ebc:	f7fc f858 	bl	8000f70 <xQueueSemaphoreTake>

			//Return of the "pusher"
			command.mask = (Poussoir_MSK);
 8004ec0:	2210      	movs	r2, #16
 8004ec2:	2300      	movs	r3, #0
 8004ec4:	9206      	str	r2, [sp, #24]
 8004ec6:	9307      	str	r3, [sp, #28]
			command.state =  Poussoir_OFF;
			m_cmd = &command;
 8004ec8:	ab06      	add	r3, sp, #24
 8004eca:	9305      	str	r3, [sp, #20]
			xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004ecc:	464b      	mov	r3, r9
 8004ece:	2200      	movs	r2, #0
 8004ed0:	6818      	ldr	r0, [r3, #0]
 8004ed2:	a905      	add	r1, sp, #20
 8004ed4:	2300      	movs	r3, #0
 8004ed6:	f7fb facf 	bl	8000478 <xQueueGenericSend>
		for (int i = 0; i <3; i++)
 8004eda:	2301      	movs	r3, #1
 8004edc:	425b      	negs	r3, r3
 8004ede:	469c      	mov	ip, r3
 8004ee0:	44e3      	add	fp, ip
 8004ee2:	465b      	mov	r3, fp
 8004ee4:	2b00      	cmp	r3, #0
 8004ee6:	d000      	beq.n	8004eea <vTaskPalettiseur+0x1c2>
 8004ee8:	e731      	b.n	8004d4e <vTaskPalettiseur+0x26>
		}

		xSemaphoreGive(xSem3);
 8004eea:	9b01      	ldr	r3, [sp, #4]
 8004eec:	2200      	movs	r2, #0
 8004eee:	2100      	movs	r1, #0
 8004ef0:	6818      	ldr	r0, [r3, #0]
 8004ef2:	2300      	movs	r3, #0
 8004ef4:	f7fb fac0 	bl	8000478 <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, 100 / portTICK_RATE_MS); //100 ms wait
 8004ef8:	2164      	movs	r1, #100	; 0x64
 8004efa:	a803      	add	r0, sp, #12
 8004efc:	f7fc fee6 	bl	8001ccc <xTaskDelayUntil>
		for (int i = 0; i <3; i++)
 8004f00:	e723      	b.n	8004d4a <vTaskPalettiseur+0x22>
 8004f02:	46c0      	nop			; (mov r8, r8)
 8004f04:	2000349c 	.word	0x2000349c
 8004f08:	200034c4 	.word	0x200034c4
 8004f0c:	200034ac 	.word	0x200034ac
 8004f10:	200034b4 	.word	0x200034b4
 8004f14:	00010004 	.word	0x00010004
 8004f18:	00010014 	.word	0x00010014

08004f1c <vTaskAscenseur>:
	}

}

void vTaskAscenseur(void *pvParameters) {
 8004f1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f1e:	46de      	mov	lr, fp
 8004f20:	4657      	mov	r7, sl
 8004f22:	464e      	mov	r6, r9
 8004f24:	4645      	mov	r5, r8
 8004f26:	b5e0      	push	{r5, r6, r7, lr}
 8004f28:	b08d      	sub	sp, #52	; 0x34
    portTickType xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
 8004f2a:	f7fc fd37 	bl	800199c <xTaskGetTickCount>
    subscribe_message_t *ps;
    command_message_t *m_cmd;
    command_message_t command;

    command.state = 0;
    command.mask = 0;
 8004f2e:	2300      	movs	r3, #0
 8004f30:	2200      	movs	r2, #0
 8004f32:	9206      	str	r2, [sp, #24]
 8004f34:	9307      	str	r3, [sp, #28]
 8004f36:	4b94      	ldr	r3, [pc, #592]	; (8005188 <vTaskAscenseur+0x26c>)
 8004f38:	4e94      	ldr	r6, [pc, #592]	; (800518c <vTaskAscenseur+0x270>)
 8004f3a:	469b      	mov	fp, r3
 8004f3c:	4b94      	ldr	r3, [pc, #592]	; (8005190 <vTaskAscenseur+0x274>)
    xLastWakeTime = xTaskGetTickCount();
 8004f3e:	9003      	str	r0, [sp, #12]
    command.mask = 0;
 8004f40:	469a      	mov	sl, r3
 8004f42:	4b94      	ldr	r3, [pc, #592]	; (8005194 <vTaskAscenseur+0x278>)
 8004f44:	af06      	add	r7, sp, #24
 8004f46:	4699      	mov	r9, r3
 8004f48:	4b93      	ldr	r3, [pc, #588]	; (8005198 <vTaskAscenseur+0x27c>)
 8004f4a:	ac09      	add	r4, sp, #36	; 0x24
 8004f4c:	9301      	str	r3, [sp, #4]

    while (1)
    {
        //Semaphore of sync
        xSemaphoreTake(xSem3, portMAX_DELAY);
 8004f4e:	465b      	mov	r3, fp
 8004f50:	2101      	movs	r1, #1
 8004f52:	6818      	ldr	r0, [r3, #0]
 8004f54:	4249      	negs	r1, r1
 8004f56:	f7fc f80b 	bl	8000f70 <xQueueSemaphoreTake>

        //Move the elevator
        command.mask = (Monter_Ascenseur_MSK | Ascenceur_to_limit_MSK );
 8004f5a:	2290      	movs	r2, #144	; 0x90
 8004f5c:	2390      	movs	r3, #144	; 0x90
 8004f5e:	0092      	lsls	r2, r2, #2
 8004f60:	009b      	lsls	r3, r3, #2
 8004f62:	9206      	str	r2, [sp, #24]
 8004f64:	9307      	str	r3, [sp, #28]
        command.state = Monter_Ascenseur_ON | Ascenceur_to_limit_ON ;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004f66:	a905      	add	r1, sp, #20
 8004f68:	2300      	movs	r3, #0
 8004f6a:	2200      	movs	r2, #0
 8004f6c:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8004f6e:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004f70:	f7fb fa82 	bl	8000478 <xQueueGenericSend>

        //wait to go up
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Ascenceur_Etage_1_MSK;
        mAscenseur.sensor_state = Ascenceur_Etage_1_ON;
 8004f74:	2201      	movs	r2, #1
        mAscenseur.sensor_id = Ascenceur_Etage_1_MSK;
 8004f76:	2380      	movs	r3, #128	; 0x80
        mAscenseur.sensor_state = Ascenceur_Etage_1_ON;
 8004f78:	4690      	mov	r8, r2
 8004f7a:	60a2      	str	r2, [r4, #8]
        ps = &mAscenseur;

        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004f7c:	4652      	mov	r2, sl
        mAscenseur.sem_id = 3;
 8004f7e:	2503      	movs	r5, #3
        mAscenseur.sensor_id = Ascenceur_Etage_1_MSK;
 8004f80:	005b      	lsls	r3, r3, #1
 8004f82:	6063      	str	r3, [r4, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004f84:	a904      	add	r1, sp, #16
 8004f86:	2300      	movs	r3, #0
 8004f88:	6810      	ldr	r0, [r2, #0]
 8004f8a:	2200      	movs	r2, #0
        mAscenseur.sem_id = 3;
 8004f8c:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 8004f8e:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004f90:	f7fb fa72 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 8004f94:	464a      	mov	r2, r9
 8004f96:	2101      	movs	r1, #1
 8004f98:	6810      	ldr	r0, [r2, #0]
 8004f9a:	4249      	negs	r1, r1
 8004f9c:	f7fb ffe8 	bl	8000f70 <xQueueSemaphoreTake>

        //Semaphore of sync
        xSemaphoreTake(xSem3, portMAX_DELAY);
 8004fa0:	465a      	mov	r2, fp
 8004fa2:	2101      	movs	r1, #1
 8004fa4:	6810      	ldr	r0, [r2, #0]
 8004fa6:	4249      	negs	r1, r1
 8004fa8:	f7fb ffe2 	bl	8000f70 <xQueueSemaphoreTake>

        // Clamp -- I don't know the name in English
        command.mask = (Clamp_MSK);
 8004fac:	2220      	movs	r2, #32
 8004fae:	2320      	movs	r3, #32
        command.state = Clamp_ON ;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004fb0:	a905      	add	r1, sp, #20
        command.mask = (Clamp_MSK);
 8004fb2:	9206      	str	r2, [sp, #24]
 8004fb4:	9307      	str	r3, [sp, #28]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004fb6:	6830      	ldr	r0, [r6, #0]
 8004fb8:	2300      	movs	r3, #0
 8004fba:	2200      	movs	r2, #0
        m_cmd = &command;
 8004fbc:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004fbe:	f7fb fa5b 	bl	8000478 <xQueueGenericSend>

        //wait for the clamp
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Clamped_MSK;
        mAscenseur.sensor_state = Clamped_ON;
 8004fc2:	4642      	mov	r2, r8
        mAscenseur.sensor_id = Clamped_MSK;
 8004fc4:	2320      	movs	r3, #32
        mAscenseur.sensor_state = Clamped_ON;
 8004fc6:	60a2      	str	r2, [r4, #8]
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004fc8:	4652      	mov	r2, sl
        mAscenseur.sensor_id = Clamped_MSK;
 8004fca:	6063      	str	r3, [r4, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004fcc:	a904      	add	r1, sp, #16
 8004fce:	2300      	movs	r3, #0
 8004fd0:	6810      	ldr	r0, [r2, #0]
 8004fd2:	2200      	movs	r2, #0
        mAscenseur.sem_id = 3;
 8004fd4:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 8004fd6:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8004fd8:	f7fb fa4e 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 8004fdc:	464a      	mov	r2, r9
 8004fde:	2101      	movs	r1, #1
 8004fe0:	6810      	ldr	r0, [r2, #0]
 8004fe2:	4249      	negs	r1, r1
 8004fe4:	f7fb ffc4 	bl	8000f70 <xQueueSemaphoreTake>

        // open the door
        command.mask = (Porte_MSK |Ascenceur_to_limit_MSK|Monter_Ascenseur_MSK);
 8004fe8:	2292      	movs	r2, #146	; 0x92
 8004fea:	2308      	movs	r3, #8
 8004fec:	0092      	lsls	r2, r2, #2
 8004fee:	9206      	str	r2, [sp, #24]
 8004ff0:	9307      	str	r3, [sp, #28]
        command.state = Porte_ON |Ascenceur_to_limit_OFF|Monter_Ascenseur_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004ff2:	a905      	add	r1, sp, #20
 8004ff4:	2300      	movs	r3, #0
 8004ff6:	2200      	movs	r2, #0
 8004ff8:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8004ffa:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8004ffc:	f7fb fa3c 	bl	8000478 <xQueueGenericSend>

        // wait to open it
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
        mAscenseur.sensor_state = Porte_Ouverte_ON ;
 8005000:	4641      	mov	r1, r8
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
 8005002:	2208      	movs	r2, #8
        mAscenseur.sensor_state = Porte_Ouverte_ON ;
 8005004:	60a1      	str	r1, [r4, #8]
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005006:	4651      	mov	r1, sl
 8005008:	2300      	movs	r3, #0
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
 800500a:	6062      	str	r2, [r4, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800500c:	6808      	ldr	r0, [r1, #0]
 800500e:	2200      	movs	r2, #0
 8005010:	a904      	add	r1, sp, #16
        mAscenseur.sem_id = 3;
 8005012:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 8005014:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005016:	f7fb fa2f 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 800501a:	4649      	mov	r1, r9
 800501c:	6808      	ldr	r0, [r1, #0]
 800501e:	2101      	movs	r1, #1
 8005020:	4249      	negs	r1, r1
 8005022:	f7fb ffa5 	bl	8000f70 <xQueueSemaphoreTake>

        // wait for the door limit
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Limite_Porte_MSK;
 8005026:	2180      	movs	r1, #128	; 0x80
        mAscenseur.sensor_state = Limite_Porte_OFF;
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005028:	4653      	mov	r3, sl
        mAscenseur.sensor_state = Limite_Porte_OFF;
 800502a:	2000      	movs	r0, #0
        mAscenseur.sensor_id = Limite_Porte_MSK;
 800502c:	0109      	lsls	r1, r1, #4
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800502e:	2200      	movs	r2, #0
        mAscenseur.sensor_id = Limite_Porte_MSK;
 8005030:	6061      	str	r1, [r4, #4]
        mAscenseur.sensor_state = Limite_Porte_OFF;
 8005032:	60a0      	str	r0, [r4, #8]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005034:	a904      	add	r1, sp, #16
 8005036:	6818      	ldr	r0, [r3, #0]
 8005038:	2300      	movs	r3, #0
        mAscenseur.sem_id = 3;
 800503a:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 800503c:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800503e:	f7fb fa1b 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 8005042:	464b      	mov	r3, r9
 8005044:	2101      	movs	r1, #1
 8005046:	6818      	ldr	r0, [r3, #0]
 8005048:	4249      	negs	r1, r1
 800504a:	f7fb ff91 	bl	8000f70 <xQueueSemaphoreTake>

        // go down
        command.mask = (Descendre_Ascenseur_MSK);
 800504e:	2280      	movs	r2, #128	; 0x80
 8005050:	2380      	movs	r3, #128	; 0x80
 8005052:	0052      	lsls	r2, r2, #1
 8005054:	005b      	lsls	r3, r3, #1
 8005056:	9206      	str	r2, [sp, #24]
 8005058:	9307      	str	r3, [sp, #28]
        command.state =  Descendre_Ascenseur_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800505a:	a905      	add	r1, sp, #20
 800505c:	2300      	movs	r3, #0
 800505e:	2200      	movs	r2, #0
 8005060:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8005062:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005064:	f7fb fa08 	bl	8000478 <xQueueGenericSend>

        // wait for the elevator to go down
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Ascenceur_Etage_1_MSK;
 8005068:	2380      	movs	r3, #128	; 0x80
 800506a:	005b      	lsls	r3, r3, #1
 800506c:	6063      	str	r3, [r4, #4]
        mAscenseur.sensor_state = Ascenceur_Etage_1_OFF;
 800506e:	2000      	movs	r0, #0
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005070:	4653      	mov	r3, sl
 8005072:	2200      	movs	r2, #0
        mAscenseur.sensor_state = Ascenceur_Etage_1_OFF;
 8005074:	60a0      	str	r0, [r4, #8]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005076:	a904      	add	r1, sp, #16
 8005078:	6818      	ldr	r0, [r3, #0]
 800507a:	2300      	movs	r3, #0
        mAscenseur.sem_id = 3;
 800507c:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 800507e:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005080:	f7fb f9fa 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 8005084:	464b      	mov	r3, r9
 8005086:	2101      	movs	r1, #1
 8005088:	6818      	ldr	r0, [r3, #0]
 800508a:	4249      	negs	r1, r1
 800508c:	f7fb ff70 	bl	8000f70 <xQueueSemaphoreTake>

        // close the door and turn off the clamp
        command.mask = ( Clamp_MSK|Porte_MSK);
 8005090:	2228      	movs	r2, #40	; 0x28
 8005092:	2300      	movs	r3, #0
        command.state = Clamp_OFF| Porte_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005094:	a905      	add	r1, sp, #20
        command.mask = ( Clamp_MSK|Porte_MSK);
 8005096:	9206      	str	r2, [sp, #24]
 8005098:	9307      	str	r3, [sp, #28]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800509a:	6830      	ldr	r0, [r6, #0]
 800509c:	2200      	movs	r2, #0
 800509e:	2300      	movs	r3, #0
        m_cmd = &command;
 80050a0:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80050a2:	f7fb f9e9 	bl	8000478 <xQueueGenericSend>

        // Semaphore of sync
        xSemaphoreTake(xSem3, portMAX_DELAY);
 80050a6:	465b      	mov	r3, fp
 80050a8:	2101      	movs	r1, #1
 80050aa:	6818      	ldr	r0, [r3, #0]
 80050ac:	4249      	negs	r1, r1
 80050ae:	f7fb ff5f 	bl	8000f70 <xQueueSemaphoreTake>

        // clamp again (second time)
        command.mask = (Clamp_MSK|Porte_MSK);
 80050b2:	2228      	movs	r2, #40	; 0x28
 80050b4:	2328      	movs	r3, #40	; 0x28
        command.state = Clamp_ON |Porte_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80050b6:	a905      	add	r1, sp, #20
        command.mask = (Clamp_MSK|Porte_MSK);
 80050b8:	9206      	str	r2, [sp, #24]
 80050ba:	9307      	str	r3, [sp, #28]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80050bc:	6830      	ldr	r0, [r6, #0]
 80050be:	2300      	movs	r3, #0
 80050c0:	2200      	movs	r2, #0
        m_cmd = &command;
 80050c2:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80050c4:	f7fb f9d8 	bl	8000478 <xQueueGenericSend>

        // Wait for door open
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
        mAscenseur.sensor_state = Porte_Ouverte_ON ;
 80050c8:	4643      	mov	r3, r8
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
 80050ca:	2208      	movs	r2, #8
        mAscenseur.sensor_state = Porte_Ouverte_ON ;
 80050cc:	60a3      	str	r3, [r4, #8]
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050ce:	4653      	mov	r3, sl
        mAscenseur.sensor_id = Porte_Ouverte_MSK ;
 80050d0:	6062      	str	r2, [r4, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050d2:	a904      	add	r1, sp, #16
 80050d4:	2200      	movs	r2, #0
 80050d6:	6818      	ldr	r0, [r3, #0]
 80050d8:	2300      	movs	r3, #0
        mAscenseur.sem_id = 3;
 80050da:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 80050dc:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050de:	f7fb f9cb 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 80050e2:	464b      	mov	r3, r9
 80050e4:	2101      	movs	r1, #1
 80050e6:	6818      	ldr	r0, [r3, #0]
 80050e8:	4249      	negs	r1, r1
 80050ea:	f7fb ff41 	bl	8000f70 <xQueueSemaphoreTake>

        // Wait for door limit
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Limite_Porte_MSK;
        mAscenseur.sensor_state = Limite_Porte_ON;
 80050ee:	4643      	mov	r3, r8
        mAscenseur.sensor_id = Limite_Porte_MSK;
 80050f0:	2180      	movs	r1, #128	; 0x80
        mAscenseur.sensor_state = Limite_Porte_ON;
 80050f2:	60a3      	str	r3, [r4, #8]
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050f4:	4653      	mov	r3, sl
        mAscenseur.sensor_id = Limite_Porte_MSK;
 80050f6:	0109      	lsls	r1, r1, #4
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050f8:	2200      	movs	r2, #0
        mAscenseur.sensor_id = Limite_Porte_MSK;
 80050fa:	6061      	str	r1, [r4, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80050fc:	6818      	ldr	r0, [r3, #0]
 80050fe:	a904      	add	r1, sp, #16
 8005100:	2300      	movs	r3, #0
        mAscenseur.sem_id = 3;
 8005102:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 8005104:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005106:	f7fb f9b7 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 800510a:	464b      	mov	r3, r9
 800510c:	2101      	movs	r1, #1
 800510e:	6818      	ldr	r0, [r3, #0]
 8005110:	4249      	negs	r1, r1
 8005112:	f7fb ff2d 	bl	8000f70 <xQueueSemaphoreTake>

        // descend to the limit
        command.mask = ( Descendre_Ascenseur_MSK | Ascenceur_to_limit_MSK);
 8005116:	22c0      	movs	r2, #192	; 0xc0
 8005118:	23c0      	movs	r3, #192	; 0xc0
 800511a:	0092      	lsls	r2, r2, #2
 800511c:	009b      	lsls	r3, r3, #2
 800511e:	9206      	str	r2, [sp, #24]
 8005120:	9307      	str	r3, [sp, #28]
        command.state =  Descendre_Ascenseur_ON | Ascenceur_to_limit_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005122:	a905      	add	r1, sp, #20
 8005124:	2300      	movs	r3, #0
 8005126:	2200      	movs	r2, #0
 8005128:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 800512a:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800512c:	f7fb f9a4 	bl	8000478 <xQueueGenericSend>

        // Wait for elevator to descend
        mAscenseur.sem_id = 3;
        mAscenseur.sensor_id = Ascenceur_Etage_RDC_MSK;
 8005130:	2340      	movs	r3, #64	; 0x40
 8005132:	6063      	str	r3, [r4, #4]
        mAscenseur.sensor_state = Ascenceur_Etage_RDC_ON;
 8005134:	4643      	mov	r3, r8
 8005136:	60a3      	str	r3, [r4, #8]
        ps = &mAscenseur;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005138:	4653      	mov	r3, sl
 800513a:	2200      	movs	r2, #0
 800513c:	a904      	add	r1, sp, #16
 800513e:	6818      	ldr	r0, [r3, #0]
 8005140:	2300      	movs	r3, #0
        mAscenseur.sem_id = 3;
 8005142:	7025      	strb	r5, [r4, #0]
        ps = &mAscenseur;
 8005144:	9404      	str	r4, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005146:	f7fb f997 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemAscenseur, portMAX_DELAY);
 800514a:	464b      	mov	r3, r9
 800514c:	2101      	movs	r1, #1
 800514e:	6818      	ldr	r0, [r3, #0]
 8005150:	4249      	negs	r1, r1
 8005152:	f7fb ff0d 	bl	8000f70 <xQueueSemaphoreTake>

        // Close the door and deactivate the limit
        command.mask = (Ascenceur_to_limit_MSK | Porte_MSK | Clamped_MSK | Descendre_Ascenseur_MSK);
 8005156:	22ca      	movs	r2, #202	; 0xca
 8005158:	2300      	movs	r3, #0
 800515a:	0092      	lsls	r2, r2, #2
 800515c:	9206      	str	r2, [sp, #24]
 800515e:	9307      	str	r3, [sp, #28]
        command.state = Ascenceur_to_limit_OFF | Porte_OFF | Clamped_OFF | Descendre_Ascenseur_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005160:	a905      	add	r1, sp, #20
 8005162:	2300      	movs	r3, #0
 8005164:	2200      	movs	r2, #0
 8005166:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8005168:	9705      	str	r7, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800516a:	f7fb f985 	bl	8000478 <xQueueGenericSend>
        xSemaphoreGive(xSem2);
 800516e:	9b01      	ldr	r3, [sp, #4]
 8005170:	2200      	movs	r2, #0
 8005172:	2100      	movs	r1, #0
 8005174:	6818      	ldr	r0, [r3, #0]
 8005176:	2300      	movs	r3, #0
 8005178:	f7fb f97e 	bl	8000478 <xQueueGenericSend>

        vTaskDelayUntil(&xLastWakeTime, 100 / portTICK_RATE_MS); //200 ms wait
 800517c:	2164      	movs	r1, #100	; 0x64
 800517e:	a803      	add	r0, sp, #12
 8005180:	f7fc fda4 	bl	8001ccc <xTaskDelayUntil>
    while (1)
 8005184:	e6e3      	b.n	8004f4e <vTaskAscenseur+0x32>
 8005186:	46c0      	nop			; (mov r8, r8)
 8005188:	200034ac 	.word	0x200034ac
 800518c:	2000349c 	.word	0x2000349c
 8005190:	200034c4 	.word	0x200034c4
 8005194:	200034b0 	.word	0x200034b0
 8005198:	200034a8 	.word	0x200034a8

0800519c <vTaskPalette>:
    }
}


void vTaskPalette(void *pvParameters)
{
 800519c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800519e:	4657      	mov	r7, sl
 80051a0:	4645      	mov	r5, r8
 80051a2:	46de      	mov	lr, fp
 80051a4:	464e      	mov	r6, r9
 80051a6:	b5e0      	push	{r5, r6, r7, lr}
 80051a8:	b08d      	sub	sp, #52	; 0x34
    portTickType xLastWakeTime;
    // Initialize timing
    xLastWakeTime = xTaskGetTickCount();
 80051aa:	f7fc fbf7 	bl	800199c <xTaskGetTickCount>

    command_message_t *m_cmd;
    command_message_t command;

    command.state = 0;
    command.mask = 0;
 80051ae:	2300      	movs	r3, #0
 80051b0:	2200      	movs	r2, #0
 80051b2:	9206      	str	r2, [sp, #24]
 80051b4:	9307      	str	r3, [sp, #28]
 80051b6:	4b5b      	ldr	r3, [pc, #364]	; (8005324 <vTaskPalette+0x188>)
 80051b8:	4d5b      	ldr	r5, [pc, #364]	; (8005328 <vTaskPalette+0x18c>)
 80051ba:	469a      	mov	sl, r3
 80051bc:	4b5b      	ldr	r3, [pc, #364]	; (800532c <vTaskPalette+0x190>)
    xLastWakeTime = xTaskGetTickCount();
 80051be:	9003      	str	r0, [sp, #12]
    command.mask = 0;
 80051c0:	4698      	mov	r8, r3
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
        // Synchronization semaphore
        xSemaphoreTake(xSemPalette, portMAX_DELAY);

        // Turn on the pallet distribution
        command.mask = Distribution_Palette_MSK;
 80051c2:	4646      	mov	r6, r8
 80051c4:	46a8      	mov	r8, r5
 80051c6:	4b5a      	ldr	r3, [pc, #360]	; (8005330 <vTaskPalette+0x194>)
 80051c8:	af09      	add	r7, sp, #36	; 0x24
 80051ca:	ac06      	add	r4, sp, #24
 80051cc:	9301      	str	r3, [sp, #4]
        mPalette.sensor_id = Sortie_Palette_MSK;
 80051ce:	2380      	movs	r3, #128	; 0x80
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80051d0:	4652      	mov	r2, sl
        mPalette.sensor_id = Sortie_Palette_MSK;
 80051d2:	00db      	lsls	r3, r3, #3
        mPalette.sem_id = 2;
 80051d4:	2502      	movs	r5, #2
        mPalette.sensor_id = Sortie_Palette_MSK;
 80051d6:	4699      	mov	r9, r3
 80051d8:	607b      	str	r3, [r7, #4]
        mPalette.sensor_state = Sortie_Palette_OFF;
 80051da:	2300      	movs	r3, #0
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80051dc:	a904      	add	r1, sp, #16
 80051de:	6810      	ldr	r0, [r2, #0]
 80051e0:	2200      	movs	r2, #0
        mPalette.sensor_state = Sortie_Palette_OFF;
 80051e2:	60bb      	str	r3, [r7, #8]
        mPalette.sem_id = 2;
 80051e4:	703d      	strb	r5, [r7, #0]
        ps = &mPalette;
 80051e6:	9704      	str	r7, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80051e8:	f7fb f946 	bl	8000478 <xQueueGenericSend>
        xSemaphoreTake(xSemPalette, portMAX_DELAY);
 80051ec:	4642      	mov	r2, r8
 80051ee:	2101      	movs	r1, #1
 80051f0:	6810      	ldr	r0, [r2, #0]
 80051f2:	4249      	negs	r1, r1
 80051f4:	f7fb febc 	bl	8000f70 <xQueueSemaphoreTake>
        command.mask = Distribution_Palette_MSK;
 80051f8:	2280      	movs	r2, #128	; 0x80
 80051fa:	2380      	movs	r3, #128	; 0x80
 80051fc:	00d2      	lsls	r2, r2, #3
 80051fe:	00db      	lsls	r3, r3, #3
 8005200:	9206      	str	r2, [sp, #24]
 8005202:	9307      	str	r3, [sp, #28]
        command.state = Distribution_Palette_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005204:	a905      	add	r1, sp, #20
 8005206:	2300      	movs	r3, #0
 8005208:	2200      	movs	r2, #0
 800520a:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 800520c:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800520e:	f7fb f933 	bl	8000478 <xQueueGenericSend>

        // Wait for the distribution
        vTaskDelay(500);
 8005212:	20fa      	movs	r0, #250	; 0xfa
 8005214:	0040      	lsls	r0, r0, #1
 8005216:	f7fc fde7 	bl	8001de8 <vTaskDelay>

        // Turn off the pallet distribution
        command.mask = Distribution_Palette_MSK;
 800521a:	2280      	movs	r2, #128	; 0x80
 800521c:	2300      	movs	r3, #0
 800521e:	00d2      	lsls	r2, r2, #3
 8005220:	9206      	str	r2, [sp, #24]
 8005222:	9307      	str	r3, [sp, #28]
        command.state = Distribution_Palette_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005224:	a905      	add	r1, sp, #20
 8005226:	2300      	movs	r3, #0
 8005228:	2200      	movs	r2, #0
 800522a:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 800522c:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800522e:	f7fb f923 	bl	8000478 <xQueueGenericSend>


        // Wait for the pallet to arrive
        mPalette.sem_id = 2;
        mPalette.sensor_id = Entree_Palette_MSK;
        mPalette.sensor_state = Entree_Palette_ON;
 8005232:	2201      	movs	r2, #1
        mPalette.sensor_id = Entree_Palette_MSK;
 8005234:	2380      	movs	r3, #128	; 0x80
        mPalette.sensor_state = Entree_Palette_ON;
 8005236:	4693      	mov	fp, r2
 8005238:	60ba      	str	r2, [r7, #8]
        ps = &mPalette;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800523a:	4652      	mov	r2, sl
        mPalette.sensor_id = Entree_Palette_MSK;
 800523c:	019b      	lsls	r3, r3, #6
 800523e:	607b      	str	r3, [r7, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 8005240:	a904      	add	r1, sp, #16
 8005242:	2300      	movs	r3, #0
 8005244:	6810      	ldr	r0, [r2, #0]
 8005246:	2200      	movs	r2, #0
        mPalette.sem_id = 2;
 8005248:	703d      	strb	r5, [r7, #0]
        ps = &mPalette;
 800524a:	9704      	str	r7, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800524c:	f7fb f914 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemPalette, portMAX_DELAY);
 8005250:	4642      	mov	r2, r8
 8005252:	2101      	movs	r1, #1
 8005254:	6810      	ldr	r0, [r2, #0]
 8005256:	4249      	negs	r1, r1
 8005258:	f7fb fe8a 	bl	8000f70 <xQueueSemaphoreTake>

        // Turn on the pallet loading conveyor
        command.mask = Charger_Palette_MSK;
 800525c:	2280      	movs	r2, #128	; 0x80
 800525e:	2380      	movs	r3, #128	; 0x80
 8005260:	0112      	lsls	r2, r2, #4
 8005262:	011b      	lsls	r3, r3, #4
 8005264:	9206      	str	r2, [sp, #24]
 8005266:	9307      	str	r3, [sp, #28]
        command.state = Charger_Palette_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005268:	a905      	add	r1, sp, #20
 800526a:	2300      	movs	r3, #0
 800526c:	2200      	movs	r2, #0
 800526e:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8005270:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005272:	f7fb f901 	bl	8000478 <xQueueGenericSend>


        // Wait for the pallet to arrive at the exit
        mPalette.sem_id = 2;
        mPalette.sensor_id = Sortie_Palette_MSK;
 8005276:	4649      	mov	r1, r9
 8005278:	6079      	str	r1, [r7, #4]
        mPalette.sensor_state = Sortie_Palette_ON;
 800527a:	4659      	mov	r1, fp
 800527c:	60b9      	str	r1, [r7, #8]
        ps = &mPalette;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800527e:	4651      	mov	r1, sl
 8005280:	2300      	movs	r3, #0
 8005282:	2200      	movs	r2, #0
 8005284:	6808      	ldr	r0, [r1, #0]
 8005286:	a904      	add	r1, sp, #16
        mPalette.sem_id = 2;
 8005288:	703d      	strb	r5, [r7, #0]
        ps = &mPalette;
 800528a:	9704      	str	r7, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 800528c:	f7fb f8f4 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemPalette, portMAX_DELAY);
 8005290:	4641      	mov	r1, r8
 8005292:	6808      	ldr	r0, [r1, #0]
 8005294:	2101      	movs	r1, #1
 8005296:	4249      	negs	r1, r1
 8005298:	f7fb fe6a 	bl	8000f70 <xQueueSemaphoreTake>

        // Turn off the pallet loading conveyor
        command.mask = Charger_Palette_MSK;
 800529c:	2180      	movs	r1, #128	; 0x80
 800529e:	2200      	movs	r2, #0
 80052a0:	0109      	lsls	r1, r1, #4
 80052a2:	9106      	str	r1, [sp, #24]
 80052a4:	9207      	str	r2, [sp, #28]
        command.state = Charger_Palette_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80052a6:	2300      	movs	r3, #0
 80052a8:	2200      	movs	r2, #0
 80052aa:	a905      	add	r1, sp, #20
 80052ac:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 80052ae:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80052b0:	f7fb f8e2 	bl	8000478 <xQueueGenericSend>

        // Synchronization semaphore
        xSemaphoreTake(xSem2, portMAX_DELAY);
 80052b4:	2101      	movs	r1, #1
 80052b6:	9801      	ldr	r0, [sp, #4]
 80052b8:	4249      	negs	r1, r1
 80052ba:	6800      	ldr	r0, [r0, #0]
 80052bc:	f7fb fe58 	bl	8000f70 <xQueueSemaphoreTake>

        // Turn on the pallet loading conveyor
        command.mask = Charger_Palette_MSK;
 80052c0:	2280      	movs	r2, #128	; 0x80
 80052c2:	2380      	movs	r3, #128	; 0x80
 80052c4:	0112      	lsls	r2, r2, #4
 80052c6:	011b      	lsls	r3, r3, #4
 80052c8:	9206      	str	r2, [sp, #24]
 80052ca:	9307      	str	r3, [sp, #28]
        command.state = Charger_Palette_ON;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80052cc:	a905      	add	r1, sp, #20
 80052ce:	2300      	movs	r3, #0
 80052d0:	2200      	movs	r2, #0
 80052d2:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 80052d4:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 80052d6:	f7fb f8cf 	bl	8000478 <xQueueGenericSend>


        // Wait for the pallet to exit
        mPalette.sem_id = 2;
        mPalette.sensor_id = Sortie_Palette_MSK;
        mPalette.sensor_state = Sortie_Palette_OFF;
 80052da:	2300      	movs	r3, #0
        mPalette.sensor_id = Sortie_Palette_MSK;
 80052dc:	464a      	mov	r2, r9
        mPalette.sensor_state = Sortie_Palette_OFF;
 80052de:	60bb      	str	r3, [r7, #8]
        ps = &mPalette;
        // Send message to the Subscribe Queue
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80052e0:	4653      	mov	r3, sl
        mPalette.sem_id = 2;
 80052e2:	703d      	strb	r5, [r7, #0]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80052e4:	ad04      	add	r5, sp, #16
 80052e6:	0029      	movs	r1, r5
        mPalette.sensor_id = Sortie_Palette_MSK;
 80052e8:	607a      	str	r2, [r7, #4]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80052ea:	6818      	ldr	r0, [r3, #0]
 80052ec:	2200      	movs	r2, #0
 80052ee:	2300      	movs	r3, #0
        ps = &mPalette;
 80052f0:	9704      	str	r7, [sp, #16]
        xQueueSendToBack(xSubcribeQueue, &ps, 0);
 80052f2:	f7fb f8c1 	bl	8000478 <xQueueGenericSend>
        // wait forever for the semaphore
        xSemaphoreTake(xSemPalette, portMAX_DELAY);
 80052f6:	4643      	mov	r3, r8
 80052f8:	2101      	movs	r1, #1
 80052fa:	6818      	ldr	r0, [r3, #0]
 80052fc:	4249      	negs	r1, r1
 80052fe:	f7fb fe37 	bl	8000f70 <xQueueSemaphoreTake>

        // Turn off the pallet loading conveyor
        command.mask = Charger_Palette_MSK;
 8005302:	2180      	movs	r1, #128	; 0x80
 8005304:	2200      	movs	r2, #0
 8005306:	0109      	lsls	r1, r1, #4
 8005308:	9106      	str	r1, [sp, #24]
 800530a:	9207      	str	r2, [sp, #28]
        command.state = Charger_Palette_OFF;
        m_cmd = &command;
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 800530c:	2300      	movs	r3, #0
 800530e:	a905      	add	r1, sp, #20
 8005310:	2200      	movs	r2, #0
 8005312:	6830      	ldr	r0, [r6, #0]
        m_cmd = &command;
 8005314:	9405      	str	r4, [sp, #20]
        xQueueSendToBack(xComQueue, &m_cmd, 0);
 8005316:	f7fb f8af 	bl	8000478 <xQueueGenericSend>

        vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_RATE_MS); //200 ms wait
 800531a:	21c8      	movs	r1, #200	; 0xc8
 800531c:	a803      	add	r0, sp, #12
 800531e:	f7fc fcd5 	bl	8001ccc <xTaskDelayUntil>
    while (1)
 8005322:	e754      	b.n	80051ce <vTaskPalette+0x32>
 8005324:	200034c4 	.word	0x200034c4
 8005328:	200034b8 	.word	0x200034b8
 800532c:	2000349c 	.word	0x2000349c
 8005330:	200034a8 	.word	0x200034a8

08005334 <vTaskWrite>:
    }
}


void vTaskWrite(void *pvParameters)
{
 8005334:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005336:	46de      	mov	lr, fp
 8005338:	464e      	mov	r6, r9
 800533a:	4657      	mov	r7, sl
 800533c:	4645      	mov	r5, r8
 800533e:	b5e0      	push	{r5, r6, r7, lr}
 8005340:	b083      	sub	sp, #12
    command_message_t *c_message;

    portTickType xLastWakeTime;

    // Initialize timing
    xLastWakeTime = xTaskGetTickCount();
 8005342:	f7fc fb2b 	bl	800199c <xTaskGetTickCount>
 8005346:	9001      	str	r0, [sp, #4]
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8005348:	20c2      	movs	r0, #194	; 0xc2
 800534a:	2180      	movs	r1, #128	; 0x80
 800534c:	4a2e      	ldr	r2, [pc, #184]	; (8005408 <vTaskWrite+0xd4>)
 800534e:	0080      	lsls	r0, r0, #2
 8005350:	5813      	ldr	r3, [r2, r0]
 8005352:	0609      	lsls	r1, r1, #24
 8005354:	021b      	lsls	r3, r3, #8
 8005356:	0a1b      	lsrs	r3, r3, #8
 8005358:	430b      	orrs	r3, r1
 800535a:	5013      	str	r3, [r2, r0]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800535c:	2380      	movs	r3, #128	; 0x80
 800535e:	011b      	lsls	r3, r3, #4
 8005360:	6013      	str	r3, [r2, #0]
 8005362:	4b2a      	ldr	r3, [pc, #168]	; (800540c <vTaskWrite+0xd8>)
    uint32_t memoire = 0;
 8005364:	2500      	movs	r5, #0
 8005366:	469b      	mov	fp, r3
 8005368:	4b29      	ldr	r3, [pc, #164]	; (8005410 <vTaskWrite+0xdc>)
 800536a:	4e2a      	ldr	r6, [pc, #168]	; (8005414 <vTaskWrite+0xe0>)
 800536c:	469a      	mov	sl, r3
 800536e:	4b2a      	ldr	r3, [pc, #168]	; (8005418 <vTaskWrite+0xe4>)
 8005370:	4699      	mov	r9, r3

    // Now enter the task loop
    while (1)
    {
        // Wait for something in the message Queue
        xStatus = xQueueReceive(xComQueue, &c_message, portMAX_DELAY);
 8005372:	465b      	mov	r3, fp
 8005374:	2201      	movs	r2, #1
 8005376:	4669      	mov	r1, sp
 8005378:	6818      	ldr	r0, [r3, #0]
 800537a:	4252      	negs	r2, r2
 800537c:	f7fb fbbc 	bl	8000af8 <xQueueReceive>

        // Take Mutex
        xSemaphoreTake(xConsoleMutex, portMAX_DELAY);
 8005380:	4653      	mov	r3, sl
 8005382:	2101      	movs	r1, #1
        xStatus = xQueueReceive(xComQueue, &c_message, portMAX_DELAY);
 8005384:	0004      	movs	r4, r0
        xSemaphoreTake(xConsoleMutex, portMAX_DELAY);
 8005386:	4249      	negs	r1, r1
 8005388:	6818      	ldr	r0, [r3, #0]
 800538a:	f7fb fdf1 	bl	8000f70 <xQueueSemaphoreTake>

        // Test if the message is received
        if (xStatus == pdPASS)
 800538e:	2c01      	cmp	r4, #1
 8005390:	d134      	bne.n	80053fc <vTaskWrite+0xc8>
        {
            /********************************************************************************************/
            // Definition of bits for FactorIO
            cmd = *c_message;
 8005392:	9b00      	ldr	r3, [sp, #0]
            tx_dma_buffer[5] = 0x00;                                // CRC (not yet implemented)
            tx_dma_buffer[6] = '\n';                                // End byte
            /********************************************************************************************/

            // Set Memory Buffer size
            DMA1_Channel4->CNDTR = 7;
 8005394:	4f21      	ldr	r7, [pc, #132]	; (800541c <vTaskWrite+0xe8>)
            memoire &= ~cmd.mask;
 8005396:	681a      	ldr	r2, [r3, #0]
            memoire |= cmd.state;
 8005398:	685b      	ldr	r3, [r3, #4]
            memoire &= ~cmd.mask;
 800539a:	4395      	bics	r5, r2
            memoire |= cmd.state;
 800539c:	431d      	orrs	r5, r3
            tx_dma_buffer[0] = TAG_ACTUATORS;                     // Actuators tag
 800539e:	23ad      	movs	r3, #173	; 0xad
 80053a0:	7033      	strb	r3, [r6, #0]
            tx_dma_buffer[2] = (uint8_t) ((memoire & 0x0000FF00) >> 8U); // data byte #2
 80053a2:	0a2b      	lsrs	r3, r5, #8
 80053a4:	70b3      	strb	r3, [r6, #2]
            tx_dma_buffer[3] = (uint8_t) ((memoire & 0x00FF0000) >> 16U);// data byte #2
 80053a6:	0c2b      	lsrs	r3, r5, #16
 80053a8:	70f3      	strb	r3, [r6, #3]
            tx_dma_buffer[4] = (uint8_t) ((memoire & 0xFF000000) >> 24U);// data byte #2
 80053aa:	0e2b      	lsrs	r3, r5, #24
 80053ac:	7133      	strb	r3, [r6, #4]
            tx_dma_buffer[5] = 0x00;                                // CRC (not yet implemented)
 80053ae:	2300      	movs	r3, #0
 80053b0:	7173      	strb	r3, [r6, #5]
            tx_dma_buffer[6] = '\n';                                // End byte
 80053b2:	330a      	adds	r3, #10
 80053b4:	71b3      	strb	r3, [r6, #6]
            DMA1_Channel4->CNDTR = 7;
 80053b6:	3b03      	subs	r3, #3
            tx_dma_buffer[1] = (uint8_t) (memoire & 0x000000FF);  // data byte #1
 80053b8:	7075      	strb	r5, [r6, #1]
            DMA1_Channel4->CNDTR = 7;
 80053ba:	607b      	str	r3, [r7, #4]

            // Enable DMA1 Channel 4
            DMA1_Channel4->CCR |= DMA_CCR_EN;
 80053bc:	683b      	ldr	r3, [r7, #0]

            // Enable USART2 DMA Request on T
            USART2->CR3 |= USART_CR3_DMAT;
 80053be:	2280      	movs	r2, #128	; 0x80
            DMA1_Channel4->CCR |= DMA_CCR_EN;
 80053c0:	4323      	orrs	r3, r4
 80053c2:	603b      	str	r3, [r7, #0]
            USART2->CR3 |= USART_CR3_DMAT;
 80053c4:	4b16      	ldr	r3, [pc, #88]	; (8005420 <vTaskWrite+0xec>)
 80053c6:	4698      	mov	r8, r3
 80053c8:	4641      	mov	r1, r8
 80053ca:	689b      	ldr	r3, [r3, #8]
 80053cc:	4313      	orrs	r3, r2
 80053ce:	608b      	str	r3, [r1, #8]

            // Wait for Semaphore endlessly
            xSemaphoreTake(xSem_DMA_TC, portMAX_DELAY);
 80053d0:	464b      	mov	r3, r9
 80053d2:	2101      	movs	r1, #1
 80053d4:	6818      	ldr	r0, [r3, #0]
 80053d6:	4249      	negs	r1, r1
 80053d8:	f7fb fdca 	bl	8000f70 <xQueueSemaphoreTake>

            // Disable USART2 DMA Request on Tx
            USART2->CR3 &= ~USART_CR3_DMAT;
 80053dc:	4643      	mov	r3, r8
 80053de:	2280      	movs	r2, #128	; 0x80
 80053e0:	689b      	ldr	r3, [r3, #8]
            // Disable DMA1 Channel 4
            DMA1_Channel4->CCR &= ~DMA_CCR_EN;

            /****************************************************************************************************/
            // Release Mutex
            xSemaphoreGive(xConsoleMutex);
 80053e2:	2100      	movs	r1, #0
            USART2->CR3 &= ~USART_CR3_DMAT;
 80053e4:	4393      	bics	r3, r2
 80053e6:	4642      	mov	r2, r8
 80053e8:	6093      	str	r3, [r2, #8]
            DMA1_Channel4->CCR &= ~DMA_CCR_EN;
 80053ea:	683b      	ldr	r3, [r7, #0]
            xSemaphoreGive(xConsoleMutex);
 80053ec:	2200      	movs	r2, #0
            DMA1_Channel4->CCR &= ~DMA_CCR_EN;
 80053ee:	43a3      	bics	r3, r4
 80053f0:	603b      	str	r3, [r7, #0]
            xSemaphoreGive(xConsoleMutex);
 80053f2:	4653      	mov	r3, sl
 80053f4:	6818      	ldr	r0, [r3, #0]
 80053f6:	2300      	movs	r3, #0
 80053f8:	f7fb f83e 	bl	8000478 <xQueueGenericSend>
        }
        vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_RATE_MS); //200 ms wait
 80053fc:	21c8      	movs	r1, #200	; 0xc8
 80053fe:	a801      	add	r0, sp, #4
 8005400:	f7fc fc64 	bl	8001ccc <xTaskDelayUntil>
        xStatus = xQueueReceive(xComQueue, &c_message, portMAX_DELAY);
 8005404:	e7b5      	b.n	8005372 <vTaskWrite+0x3e>
 8005406:	46c0      	nop			; (mov r8, r8)
 8005408:	e000e100 	.word	0xe000e100
 800540c:	2000349c 	.word	0x2000349c
 8005410:	200034a0 	.word	0x200034a0
 8005414:	200034d8 	.word	0x200034d8
 8005418:	200034bc 	.word	0x200034bc
 800541c:	40020044 	.word	0x40020044
 8005420:	40004400 	.word	0x40004400

08005424 <vTaskRead>:
{
 8005424:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005426:	46de      	mov	lr, fp
 8005428:	4657      	mov	r7, sl
 800542a:	464e      	mov	r6, r9
 800542c:	4645      	mov	r5, r8
 800542e:	b5e0      	push	{r5, r6, r7, lr}
 8005430:	b0c5      	sub	sp, #276	; 0x114
    xLastWakeTime = xTaskGetTickCount();
 8005432:	f7fc fab3 	bl	800199c <xTaskGetTickCount>
void init_tab(subscribe_message_t *t)
{
    // Initialize the array to 0
    for (int i = 0; i < SIZE; i++)
    {
        t[i].sem_id = 0;
 8005436:	2300      	movs	r3, #0
 8005438:	ac08      	add	r4, sp, #32
 800543a:	7023      	strb	r3, [r4, #0]
        t[i].sensor_id = 0;
 800543c:	6063      	str	r3, [r4, #4]
        t[i].sensor_state = 0;
 800543e:	60a3      	str	r3, [r4, #8]
        t[i].sensor_id = 0;
 8005440:	6123      	str	r3, [r4, #16]
        t[i].sensor_state = 0;
 8005442:	6163      	str	r3, [r4, #20]
        t[i].sensor_id = 0;
 8005444:	61e3      	str	r3, [r4, #28]
        t[i].sensor_state = 0;
 8005446:	6223      	str	r3, [r4, #32]
        t[i].sensor_id = 0;
 8005448:	62a3      	str	r3, [r4, #40]	; 0x28
        t[i].sensor_state = 0;
 800544a:	62e3      	str	r3, [r4, #44]	; 0x2c
    xSemaphoreGive(xSem1);
 800544c:	4bca      	ldr	r3, [pc, #808]	; (8005778 <vTaskRead+0x354>)
    xLastWakeTime = xTaskGetTickCount();
 800544e:	9007      	str	r0, [sp, #28]
    xSemaphoreGive(xSem1);
 8005450:	2200      	movs	r2, #0
 8005452:	6818      	ldr	r0, [r3, #0]
 8005454:	2100      	movs	r1, #0
 8005456:	2300      	movs	r3, #0
 8005458:	f7fb f80e 	bl	8000478 <xQueueGenericSend>
 800545c:	2300      	movs	r3, #0
 800545e:	4699      	mov	r9, r3
 8005460:	4698      	mov	r8, r3
    int aux = 1;
 8005462:	3301      	adds	r3, #1
 8005464:	469b      	mov	fp, r3
 8005466:	4bc5      	ldr	r3, [pc, #788]	; (800577c <vTaskRead+0x358>)
    xSemaphoreGive(xSem1);
 8005468:	2700      	movs	r7, #0
 800546a:	469a      	mov	sl, r3
 800546c:	4bc4      	ldr	r3, [pc, #784]	; (8005780 <vTaskRead+0x35c>)
 800546e:	2600      	movs	r6, #0
 8005470:	9301      	str	r3, [sp, #4]
 8005472:	4bc4      	ldr	r3, [pc, #784]	; (8005784 <vTaskRead+0x360>)
 8005474:	4dc4      	ldr	r5, [pc, #784]	; (8005788 <vTaskRead+0x364>)
 8005476:	9302      	str	r3, [sp, #8]
 8005478:	4bc4      	ldr	r3, [pc, #784]	; (800578c <vTaskRead+0x368>)
 800547a:	9305      	str	r3, [sp, #20]
 800547c:	4bc4      	ldr	r3, [pc, #784]	; (8005790 <vTaskRead+0x36c>)
 800547e:	9303      	str	r3, [sp, #12]
 8005480:	e011      	b.n	80054a6 <vTaskRead+0x82>
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 8005482:	4643      	mov	r3, r8
 8005484:	2b00      	cmp	r3, #0
 8005486:	d13a      	bne.n	80054fe <vTaskRead+0xda>
 8005488:	2f00      	cmp	r7, #0
 800548a:	d154      	bne.n	8005536 <vTaskRead+0x112>
 800548c:	464b      	mov	r3, r9
 800548e:	2b00      	cmp	r3, #0
 8005490:	d16d      	bne.n	800556e <vTaskRead+0x14a>
        xSemaphoreGive(xConsoleMutex);
 8005492:	2100      	movs	r1, #0
 8005494:	2300      	movs	r3, #0
 8005496:	2200      	movs	r2, #0
 8005498:	6828      	ldr	r0, [r5, #0]
 800549a:	f7fa ffed 	bl	8000478 <xQueueGenericSend>
        vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_RATE_MS); //200 ms wait
 800549e:	21c8      	movs	r1, #200	; 0xc8
 80054a0:	a807      	add	r0, sp, #28
 80054a2:	f7fc fc13 	bl	8001ccc <xTaskDelayUntil>
        xStatus = xQueueReceive(xSubcribeQueue, &s_message, 0);
 80054a6:	4653      	mov	r3, sl
 80054a8:	2200      	movs	r2, #0
 80054aa:	6818      	ldr	r0, [r3, #0]
 80054ac:	a906      	add	r1, sp, #24
 80054ae:	f7fb fb23 	bl	8000af8 <xQueueReceive>
        if (xStatus == pdPASS)
 80054b2:	2801      	cmp	r0, #1
 80054b4:	d076      	beq.n	80055a4 <vTaskRead+0x180>
        xSemaphoreTake(xConsoleMutex, portMAX_DELAY);
 80054b6:	2101      	movs	r1, #1
 80054b8:	6828      	ldr	r0, [r5, #0]
 80054ba:	4249      	negs	r1, r1
 80054bc:	f7fb fd58 	bl	8000f70 <xQueueSemaphoreTake>
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 80054c0:	2e00      	cmp	r6, #0
 80054c2:	d0de      	beq.n	8005482 <vTaskRead+0x5e>
                if (FACTORY_IO_Sensors_Get(tab[i].sensor_id) == tab[i].sensor_state) // If the state of the sensors matches the sensor identifier
 80054c4:	6860      	ldr	r0, [r4, #4]
 80054c6:	f000 fbbd 	bl	8005c44 <FACTORY_IO_Sensors_Get>
 80054ca:	68a3      	ldr	r3, [r4, #8]
 80054cc:	4298      	cmp	r0, r3
 80054ce:	d1d8      	bne.n	8005482 <vTaskRead+0x5e>
                    if (tab[i].sem_id == 1)
 80054d0:	2e01      	cmp	r6, #1
 80054d2:	d100      	bne.n	80054d6 <vTaskRead+0xb2>
 80054d4:	e139      	b.n	800574a <vTaskRead+0x326>
                    if (tab[i].sem_id == 2)
 80054d6:	2e02      	cmp	r6, #2
 80054d8:	d100      	bne.n	80054dc <vTaskRead+0xb8>
 80054da:	e119      	b.n	8005710 <vTaskRead+0x2ec>
                    if (tab[i].sem_id == 3)
 80054dc:	2e03      	cmp	r6, #3
 80054de:	d1d0      	bne.n	8005482 <vTaskRead+0x5e>
                        xSemaphoreGive(xSemAscenseur);
 80054e0:	9b01      	ldr	r3, [sp, #4]
                        xSemaphoreGive(xSemCarton);
 80054e2:	6818      	ldr	r0, [r3, #0]
 80054e4:	2200      	movs	r2, #0
 80054e6:	2300      	movs	r3, #0
 80054e8:	2100      	movs	r1, #0
 80054ea:	f7fa ffc5 	bl	8000478 <xQueueGenericSend>
                        tab[i].sem_id = 0;
 80054ee:	2300      	movs	r3, #0
 80054f0:	7023      	strb	r3, [r4, #0]
                        tab[i].sensor_id = 0;
 80054f2:	6063      	str	r3, [r4, #4]
                        tab[i].sensor_state = 0;
 80054f4:	60a3      	str	r3, [r4, #8]
 80054f6:	2600      	movs	r6, #0
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 80054f8:	4643      	mov	r3, r8
 80054fa:	2b00      	cmp	r3, #0
 80054fc:	d0c4      	beq.n	8005488 <vTaskRead+0x64>
                if (FACTORY_IO_Sensors_Get(tab[i].sensor_id) == tab[i].sensor_state) // If the state of the sensors matches the sensor identifier
 80054fe:	6920      	ldr	r0, [r4, #16]
 8005500:	f000 fba0 	bl	8005c44 <FACTORY_IO_Sensors_Get>
 8005504:	6963      	ldr	r3, [r4, #20]
 8005506:	4298      	cmp	r0, r3
 8005508:	d1be      	bne.n	8005488 <vTaskRead+0x64>
                    if (tab[i].sem_id == 1)
 800550a:	4643      	mov	r3, r8
 800550c:	2b01      	cmp	r3, #1
 800550e:	d100      	bne.n	8005512 <vTaskRead+0xee>
 8005510:	e0e9      	b.n	80056e6 <vTaskRead+0x2c2>
                    if (tab[i].sem_id == 2)
 8005512:	2b02      	cmp	r3, #2
 8005514:	d100      	bne.n	8005518 <vTaskRead+0xf4>
 8005516:	e0b3      	b.n	8005680 <vTaskRead+0x25c>
                    if (tab[i].sem_id == 3)
 8005518:	2b03      	cmp	r3, #3
 800551a:	d1b5      	bne.n	8005488 <vTaskRead+0x64>
                        xSemaphoreGive(xSemAscenseur);
 800551c:	9b01      	ldr	r3, [sp, #4]
                        xSemaphoreGive(xSemCarton);
 800551e:	6818      	ldr	r0, [r3, #0]
 8005520:	2200      	movs	r2, #0
 8005522:	2300      	movs	r3, #0
 8005524:	2100      	movs	r1, #0
 8005526:	f7fa ffa7 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 800552a:	2300      	movs	r3, #0
                        tab[i].sensor_state = 0;
 800552c:	4698      	mov	r8, r3
                        tab[i].sensor_id = 0;
 800552e:	6123      	str	r3, [r4, #16]
                        tab[i].sensor_state = 0;
 8005530:	6163      	str	r3, [r4, #20]
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 8005532:	2f00      	cmp	r7, #0
 8005534:	d0aa      	beq.n	800548c <vTaskRead+0x68>
                if (FACTORY_IO_Sensors_Get(tab[i].sensor_id) == tab[i].sensor_state) // If the state of the sensors matches the sensor identifier
 8005536:	69e0      	ldr	r0, [r4, #28]
 8005538:	f000 fb84 	bl	8005c44 <FACTORY_IO_Sensors_Get>
 800553c:	6a23      	ldr	r3, [r4, #32]
 800553e:	4298      	cmp	r0, r3
 8005540:	d1a4      	bne.n	800548c <vTaskRead+0x68>
                    if (tab[i].sem_id == 1)
 8005542:	2f01      	cmp	r7, #1
 8005544:	d100      	bne.n	8005548 <vTaskRead+0x124>
 8005546:	e0cc      	b.n	80056e2 <vTaskRead+0x2be>
                    if (tab[i].sem_id == 2)
 8005548:	2f02      	cmp	r7, #2
 800554a:	d100      	bne.n	800554e <vTaskRead+0x12a>
 800554c:	e0ad      	b.n	80056aa <vTaskRead+0x286>
                    if (tab[i].sem_id == 3)
 800554e:	2f03      	cmp	r7, #3
 8005550:	d19c      	bne.n	800548c <vTaskRead+0x68>
                        xSemaphoreGive(xSemAscenseur);
 8005552:	9b01      	ldr	r3, [sp, #4]
                        xSemaphoreGive(xSemCarton);
 8005554:	6818      	ldr	r0, [r3, #0]
 8005556:	2200      	movs	r2, #0
 8005558:	2300      	movs	r3, #0
 800555a:	2100      	movs	r1, #0
 800555c:	f7fa ff8c 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 8005560:	2300      	movs	r3, #0
 8005562:	61e3      	str	r3, [r4, #28]
                        tab[i].sensor_state = 0;
 8005564:	6223      	str	r3, [r4, #32]
 8005566:	2700      	movs	r7, #0
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 8005568:	464b      	mov	r3, r9
 800556a:	2b00      	cmp	r3, #0
 800556c:	d091      	beq.n	8005492 <vTaskRead+0x6e>
                if (FACTORY_IO_Sensors_Get(tab[i].sensor_id) == tab[i].sensor_state) // If the state of the sensors matches the sensor identifier
 800556e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005570:	f000 fb68 	bl	8005c44 <FACTORY_IO_Sensors_Get>
 8005574:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005576:	4298      	cmp	r0, r3
 8005578:	d18b      	bne.n	8005492 <vTaskRead+0x6e>
                    if (tab[i].sem_id == 1)
 800557a:	464b      	mov	r3, r9
 800557c:	2b01      	cmp	r3, #1
 800557e:	d100      	bne.n	8005582 <vTaskRead+0x15e>
 8005580:	e091      	b.n	80056a6 <vTaskRead+0x282>
                    if (tab[i].sem_id == 2)
 8005582:	2b02      	cmp	r3, #2
 8005584:	d100      	bne.n	8005588 <vTaskRead+0x164>
 8005586:	e0b0      	b.n	80056ea <vTaskRead+0x2c6>
                    if (tab[i].sem_id == 3)
 8005588:	2b03      	cmp	r3, #3
 800558a:	d182      	bne.n	8005492 <vTaskRead+0x6e>
                        xSemaphoreGive(xSemAscenseur);
 800558c:	9b01      	ldr	r3, [sp, #4]
                        xSemaphoreGive(xSemCarton);
 800558e:	6818      	ldr	r0, [r3, #0]
 8005590:	2200      	movs	r2, #0
 8005592:	2300      	movs	r3, #0
 8005594:	2100      	movs	r1, #0
 8005596:	f7fa ff6f 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 800559a:	2300      	movs	r3, #0
                        tab[i].sensor_state = 0;
 800559c:	4699      	mov	r9, r3
                        tab[i].sensor_id = 0;
 800559e:	62a3      	str	r3, [r4, #40]	; 0x28
                        tab[i].sensor_state = 0;
 80055a0:	62e3      	str	r3, [r4, #44]	; 0x2c
                    if (tab[i].sem_id == 3)
 80055a2:	e776      	b.n	8005492 <vTaskRead+0x6e>
                if ((s_message->sem_id == tab[i].sem_id)
 80055a4:	2100      	movs	r1, #0
 80055a6:	9b06      	ldr	r3, [sp, #24]
 80055a8:	9100      	str	r1, [sp, #0]
 80055aa:	781a      	ldrb	r2, [r3, #0]
 80055ac:	4296      	cmp	r6, r2
 80055ae:	d05a      	beq.n	8005666 <vTaskRead+0x242>
 80055b0:	4590      	cmp	r8, r2
 80055b2:	d04c      	beq.n	800564e <vTaskRead+0x22a>
 80055b4:	4297      	cmp	r7, r2
 80055b6:	d017      	beq.n	80055e8 <vTaskRead+0x1c4>
 80055b8:	4591      	cmp	r9, r2
 80055ba:	d031      	beq.n	8005620 <vTaskRead+0x1fc>
                if ((tab[i].sem_id == 0) && (existe == 0))
 80055bc:	0030      	movs	r0, r6
 80055be:	9900      	ldr	r1, [sp, #0]
 80055c0:	4308      	orrs	r0, r1
 80055c2:	d123      	bne.n	800560c <vTaskRead+0x1e8>
                    tab[i].sensor_id = s_message->sensor_id;
 80055c4:	6899      	ldr	r1, [r3, #8]
 80055c6:	6858      	ldr	r0, [r3, #4]
 80055c8:	910a      	str	r1, [sp, #40]	; 0x28
                    existe = 1;
 80055ca:	2101      	movs	r1, #1
                    tab[i].sem_id = s_message->sem_id;
 80055cc:	7022      	strb	r2, [r4, #0]
                    tab[i].sensor_id = s_message->sensor_id;
 80055ce:	9009      	str	r0, [sp, #36]	; 0x24
                    existe = 1;
 80055d0:	9100      	str	r1, [sp, #0]
                if ((tab[i].sem_id == 0) && (existe == 0))
 80055d2:	4648      	mov	r0, r9
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 80055d4:	7826      	ldrb	r6, [r4, #0]
                if ((tab[i].sem_id == 0) && (existe == 0))
 80055d6:	4301      	orrs	r1, r0
 80055d8:	d000      	beq.n	80055dc <vTaskRead+0x1b8>
 80055da:	e76c      	b.n	80054b6 <vTaskRead+0x92>
                    tab[i].sensor_id = s_message->sensor_id;
 80055dc:	6899      	ldr	r1, [r3, #8]
 80055de:	685b      	ldr	r3, [r3, #4]
                if ((s_message->sem_id == tab[i].sem_id)
 80055e0:	4691      	mov	r9, r2
                    tab[i].sensor_id = s_message->sensor_id;
 80055e2:	9312      	str	r3, [sp, #72]	; 0x48
 80055e4:	9113      	str	r1, [sp, #76]	; 0x4c
                    existe = 1;
 80055e6:	e766      	b.n	80054b6 <vTaskRead+0x92>
                        && (s_message->sensor_id == tab[i].sensor_id)
 80055e8:	6858      	ldr	r0, [r3, #4]
 80055ea:	4684      	mov	ip, r0
 80055ec:	69e0      	ldr	r0, [r4, #28]
 80055ee:	4584      	cmp	ip, r0
 80055f0:	d1e2      	bne.n	80055b8 <vTaskRead+0x194>
                        && (s_message->sensor_state == tab[i].sensor_state))
 80055f2:	6899      	ldr	r1, [r3, #8]
 80055f4:	6a20      	ldr	r0, [r4, #32]
 80055f6:	9104      	str	r1, [sp, #16]
 80055f8:	4281      	cmp	r1, r0
 80055fa:	d1dd      	bne.n	80055b8 <vTaskRead+0x194>
                if ((s_message->sem_id == tab[i].sem_id)
 80055fc:	2101      	movs	r1, #1
 80055fe:	9100      	str	r1, [sp, #0]
 8005600:	45b9      	cmp	r9, r7
 8005602:	d119      	bne.n	8005638 <vTaskRead+0x214>
                        && (s_message->sensor_id == tab[i].sensor_id)
 8005604:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005606:	9904      	ldr	r1, [sp, #16]
 8005608:	4584      	cmp	ip, r0
 800560a:	d010      	beq.n	800562e <vTaskRead+0x20a>
                if ((tab[i].sem_id == 0) && (existe == 0))
 800560c:	4640      	mov	r0, r8
 800560e:	9900      	ldr	r1, [sp, #0]
 8005610:	4308      	orrs	r0, r1
 8005612:	d111      	bne.n	8005638 <vTaskRead+0x214>
                    tab[i].sensor_id = s_message->sensor_id;
 8005614:	6899      	ldr	r1, [r3, #8]
 8005616:	685b      	ldr	r3, [r3, #4]
                if ((s_message->sem_id == tab[i].sem_id)
 8005618:	4690      	mov	r8, r2
                    tab[i].sensor_id = s_message->sensor_id;
 800561a:	930c      	str	r3, [sp, #48]	; 0x30
 800561c:	910d      	str	r1, [sp, #52]	; 0x34
                if ((tab[i].sem_id == 0) && (existe == 0))
 800561e:	e74a      	b.n	80054b6 <vTaskRead+0x92>
                        && (s_message->sensor_id == tab[i].sensor_id)
 8005620:	6858      	ldr	r0, [r3, #4]
 8005622:	4684      	mov	ip, r0
 8005624:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005626:	4584      	cmp	ip, r0
 8005628:	d1c8      	bne.n	80055bc <vTaskRead+0x198>
 800562a:	6899      	ldr	r1, [r3, #8]
 800562c:	9104      	str	r1, [sp, #16]
                        && (s_message->sensor_state == tab[i].sensor_state))
 800562e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005630:	4281      	cmp	r1, r0
 8005632:	d1c3      	bne.n	80055bc <vTaskRead+0x198>
 8005634:	2101      	movs	r1, #1
 8005636:	9100      	str	r1, [sp, #0]
                if ((tab[i].sem_id == 0) && (existe == 0))
 8005638:	0038      	movs	r0, r7
 800563a:	9900      	ldr	r1, [sp, #0]
 800563c:	4308      	orrs	r0, r1
 800563e:	d1c8      	bne.n	80055d2 <vTaskRead+0x1ae>
                    tab[i].sensor_id = s_message->sensor_id;
 8005640:	6899      	ldr	r1, [r3, #8]
 8005642:	685b      	ldr	r3, [r3, #4]
 8005644:	9110      	str	r1, [sp, #64]	; 0x40
 8005646:	930f      	str	r3, [sp, #60]	; 0x3c
                if ((s_message->sem_id == tab[i].sem_id)
 8005648:	0017      	movs	r7, r2
            if (tab[i].sem_id != 0) // Checking in the subscription queue if there is a request/demand
 800564a:	7826      	ldrb	r6, [r4, #0]
 800564c:	e733      	b.n	80054b6 <vTaskRead+0x92>
                        && (s_message->sensor_id == tab[i].sensor_id)
 800564e:	6858      	ldr	r0, [r3, #4]
 8005650:	4684      	mov	ip, r0
 8005652:	6920      	ldr	r0, [r4, #16]
 8005654:	4584      	cmp	ip, r0
 8005656:	d1ad      	bne.n	80055b4 <vTaskRead+0x190>
                        && (s_message->sensor_state == tab[i].sensor_state))
 8005658:	6899      	ldr	r1, [r3, #8]
 800565a:	6960      	ldr	r0, [r4, #20]
 800565c:	4281      	cmp	r1, r0
 800565e:	d1a9      	bne.n	80055b4 <vTaskRead+0x190>
                    existe = 1;
 8005660:	2101      	movs	r1, #1
 8005662:	9100      	str	r1, [sp, #0]
 8005664:	e7a6      	b.n	80055b4 <vTaskRead+0x190>
                        && (s_message->sensor_id == tab[i].sensor_id)
 8005666:	6858      	ldr	r0, [r3, #4]
 8005668:	4684      	mov	ip, r0
 800566a:	6860      	ldr	r0, [r4, #4]
 800566c:	4584      	cmp	ip, r0
 800566e:	d19f      	bne.n	80055b0 <vTaskRead+0x18c>
                        && (s_message->sensor_state == tab[i].sensor_state))
 8005670:	6898      	ldr	r0, [r3, #8]
 8005672:	68a1      	ldr	r1, [r4, #8]
 8005674:	1a41      	subs	r1, r0, r1
 8005676:	4248      	negs	r0, r1
 8005678:	4141      	adcs	r1, r0
 800567a:	b2c9      	uxtb	r1, r1
 800567c:	9100      	str	r1, [sp, #0]
 800567e:	e797      	b.n	80055b0 <vTaskRead+0x18c>
                        xSemaphoreGive(xSemPalette);
 8005680:	9b02      	ldr	r3, [sp, #8]
 8005682:	2200      	movs	r2, #0
 8005684:	6818      	ldr	r0, [r3, #0]
 8005686:	2100      	movs	r1, #0
 8005688:	2300      	movs	r3, #0
 800568a:	f7fa fef5 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 800568e:	2300      	movs	r3, #0
 8005690:	6123      	str	r3, [r4, #16]
                        tab[i].sensor_state = 0;
 8005692:	6163      	str	r3, [r4, #20]
                        aux ++;
 8005694:	3301      	adds	r3, #1
 8005696:	469c      	mov	ip, r3
 8005698:	44e3      	add	fp, ip
                        if (aux == 4)
 800569a:	465b      	mov	r3, fp
 800569c:	2b04      	cmp	r3, #4
 800569e:	d060      	beq.n	8005762 <vTaskRead+0x33e>
                        tab[i].sensor_state = 0;
 80056a0:	2300      	movs	r3, #0
 80056a2:	4698      	mov	r8, r3
 80056a4:	e6f0      	b.n	8005488 <vTaskRead+0x64>
                        xSemaphoreGive(xSemCarton);
 80056a6:	9b03      	ldr	r3, [sp, #12]
 80056a8:	e771      	b.n	800558e <vTaskRead+0x16a>
                        xSemaphoreGive(xSemPalette);
 80056aa:	9b02      	ldr	r3, [sp, #8]
 80056ac:	2200      	movs	r2, #0
 80056ae:	6818      	ldr	r0, [r3, #0]
 80056b0:	2100      	movs	r1, #0
 80056b2:	2300      	movs	r3, #0
 80056b4:	f7fa fee0 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 80056b8:	2300      	movs	r3, #0
 80056ba:	61e3      	str	r3, [r4, #28]
                        tab[i].sensor_state = 0;
 80056bc:	6223      	str	r3, [r4, #32]
                        aux ++;
 80056be:	3301      	adds	r3, #1
 80056c0:	469c      	mov	ip, r3
 80056c2:	44e3      	add	fp, ip
                        if (aux == 4)
 80056c4:	465b      	mov	r3, fp
 80056c6:	2b04      	cmp	r3, #4
 80056c8:	d000      	beq.n	80056cc <vTaskRead+0x2a8>
 80056ca:	e74c      	b.n	8005566 <vTaskRead+0x142>
                            xSemaphoreGive(xSem3);
 80056cc:	2300      	movs	r3, #0
 80056ce:	9805      	ldr	r0, [sp, #20]
 80056d0:	001a      	movs	r2, r3
 80056d2:	0019      	movs	r1, r3
 80056d4:	6800      	ldr	r0, [r0, #0]
 80056d6:	f7fa fecf 	bl	8000478 <xQueueGenericSend>
                            aux =0;
 80056da:	2300      	movs	r3, #0
                        tab[i].sensor_state = 0;
 80056dc:	2700      	movs	r7, #0
                            aux =0;
 80056de:	469b      	mov	fp, r3
                    if (tab[i].sem_id == 3)
 80056e0:	e742      	b.n	8005568 <vTaskRead+0x144>
                        xSemaphoreGive(xSemCarton);
 80056e2:	9b03      	ldr	r3, [sp, #12]
 80056e4:	e736      	b.n	8005554 <vTaskRead+0x130>
 80056e6:	9b03      	ldr	r3, [sp, #12]
 80056e8:	e719      	b.n	800551e <vTaskRead+0xfa>
                        xSemaphoreGive(xSemPalette);
 80056ea:	9b02      	ldr	r3, [sp, #8]
 80056ec:	2200      	movs	r2, #0
 80056ee:	6818      	ldr	r0, [r3, #0]
 80056f0:	2100      	movs	r1, #0
 80056f2:	2300      	movs	r3, #0
 80056f4:	f7fa fec0 	bl	8000478 <xQueueGenericSend>
                        tab[i].sensor_id = 0;
 80056f8:	2300      	movs	r3, #0
 80056fa:	62a3      	str	r3, [r4, #40]	; 0x28
                        tab[i].sensor_state = 0;
 80056fc:	62e3      	str	r3, [r4, #44]	; 0x2c
                        aux ++;
 80056fe:	3301      	adds	r3, #1
 8005700:	469c      	mov	ip, r3
 8005702:	44e3      	add	fp, ip
                        if (aux == 4)
 8005704:	465b      	mov	r3, fp
 8005706:	2b04      	cmp	r3, #4
 8005708:	d021      	beq.n	800574e <vTaskRead+0x32a>
                        tab[i].sensor_state = 0;
 800570a:	2300      	movs	r3, #0
 800570c:	4699      	mov	r9, r3
 800570e:	e6c0      	b.n	8005492 <vTaskRead+0x6e>
                        xSemaphoreGive(xSemPalette);
 8005710:	9b02      	ldr	r3, [sp, #8]
 8005712:	2200      	movs	r2, #0
 8005714:	6818      	ldr	r0, [r3, #0]
 8005716:	2100      	movs	r1, #0
 8005718:	2300      	movs	r3, #0
 800571a:	f7fa fead 	bl	8000478 <xQueueGenericSend>
                        tab[i].sem_id = 0;
 800571e:	2300      	movs	r3, #0
 8005720:	7023      	strb	r3, [r4, #0]
                        tab[i].sensor_id = 0;
 8005722:	6063      	str	r3, [r4, #4]
                        tab[i].sensor_state = 0;
 8005724:	60a3      	str	r3, [r4, #8]
                        aux ++;
 8005726:	3301      	adds	r3, #1
 8005728:	469c      	mov	ip, r3
 800572a:	44e3      	add	fp, ip
                        if (aux == 4)
 800572c:	465b      	mov	r3, fp
 800572e:	2b04      	cmp	r3, #4
 8005730:	d000      	beq.n	8005734 <vTaskRead+0x310>
 8005732:	e6e0      	b.n	80054f6 <vTaskRead+0xd2>
                            xSemaphoreGive(xSem3);
 8005734:	2300      	movs	r3, #0
 8005736:	9805      	ldr	r0, [sp, #20]
 8005738:	001a      	movs	r2, r3
 800573a:	0019      	movs	r1, r3
 800573c:	6800      	ldr	r0, [r0, #0]
 800573e:	f7fa fe9b 	bl	8000478 <xQueueGenericSend>
                            aux =0;
 8005742:	2300      	movs	r3, #0
                        tab[i].sensor_state = 0;
 8005744:	2600      	movs	r6, #0
                            aux =0;
 8005746:	469b      	mov	fp, r3
                    if (tab[i].sem_id == 3)
 8005748:	e6d6      	b.n	80054f8 <vTaskRead+0xd4>
                        xSemaphoreGive(xSemCarton);
 800574a:	9b03      	ldr	r3, [sp, #12]
 800574c:	e6c9      	b.n	80054e2 <vTaskRead+0xbe>
                            xSemaphoreGive(xSem3);
 800574e:	2300      	movs	r3, #0
 8005750:	9805      	ldr	r0, [sp, #20]
 8005752:	001a      	movs	r2, r3
 8005754:	0019      	movs	r1, r3
 8005756:	6800      	ldr	r0, [r0, #0]
 8005758:	f7fa fe8e 	bl	8000478 <xQueueGenericSend>
                            aux =0;
 800575c:	2300      	movs	r3, #0
 800575e:	469b      	mov	fp, r3
 8005760:	e7d3      	b.n	800570a <vTaskRead+0x2e6>
                            xSemaphoreGive(xSem3);
 8005762:	2300      	movs	r3, #0
 8005764:	9805      	ldr	r0, [sp, #20]
 8005766:	001a      	movs	r2, r3
 8005768:	0019      	movs	r1, r3
 800576a:	6800      	ldr	r0, [r0, #0]
 800576c:	f7fa fe84 	bl	8000478 <xQueueGenericSend>
                            aux =0;
 8005770:	2300      	movs	r3, #0
 8005772:	469b      	mov	fp, r3
 8005774:	e794      	b.n	80056a0 <vTaskRead+0x27c>
 8005776:	46c0      	nop			; (mov r8, r8)
 8005778:	200034a4 	.word	0x200034a4
 800577c:	200034c4 	.word	0x200034c4
 8005780:	200034b0 	.word	0x200034b0
 8005784:	200034b8 	.word	0x200034b8
 8005788:	200034a0 	.word	0x200034a0
 800578c:	200034ac 	.word	0x200034ac
 8005790:	200034b4 	.word	0x200034b4

08005794 <main>:
    RCC->CR |= RCC_CR_HSEBYP;
 8005794:	2380      	movs	r3, #128	; 0x80
 8005796:	4987      	ldr	r1, [pc, #540]	; (80059b4 <main+0x220>)
 8005798:	02db      	lsls	r3, r3, #11
 800579a:	680a      	ldr	r2, [r1, #0]
{
 800579c:	b510      	push	{r4, lr}
    RCC->CR |= RCC_CR_HSEBYP;
 800579e:	4313      	orrs	r3, r2
 80057a0:	600b      	str	r3, [r1, #0]
    RCC->CR |= RCC_CR_HSEON;
 80057a2:	2380      	movs	r3, #128	; 0x80
        HSE_Status = RCC->CR & RCC_CR_HSERDY_Msk;
 80057a4:	2080      	movs	r0, #128	; 0x80
    RCC->CR |= RCC_CR_HSEON;
 80057a6:	680a      	ldr	r2, [r1, #0]
 80057a8:	025b      	lsls	r3, r3, #9
 80057aa:	4313      	orrs	r3, r2
 80057ac:	600b      	str	r3, [r1, #0]
{
 80057ae:	b086      	sub	sp, #24
    timeout = 1000000;
 80057b0:	4b81      	ldr	r3, [pc, #516]	; (80059b8 <main+0x224>)
        HSE_Status = RCC->CR & RCC_CR_HSERDY_Msk;
 80057b2:	0280      	lsls	r0, r0, #10
 80057b4:	e001      	b.n	80057ba <main+0x26>
    } while ((HSE_Status == 0) && (timeout > 0));
 80057b6:	2b00      	cmp	r3, #0
 80057b8:	d003      	beq.n	80057c2 <main+0x2e>
        HSE_Status = RCC->CR & RCC_CR_HSERDY_Msk;
 80057ba:	680a      	ldr	r2, [r1, #0]
        timeout--;
 80057bc:	3b01      	subs	r3, #1
    } while ((HSE_Status == 0) && (timeout > 0));
 80057be:	4202      	tst	r2, r0
 80057c0:	d0f9      	beq.n	80057b6 <main+0x22>
    RCC->CFGR &= ~RCC_CFGR_PLLSRC_Msk;
 80057c2:	4a7c      	ldr	r2, [pc, #496]	; (80059b4 <main+0x220>)
 80057c4:	487d      	ldr	r0, [pc, #500]	; (80059bc <main+0x228>)
 80057c6:	6851      	ldr	r1, [r2, #4]
 80057c8:	4001      	ands	r1, r0
 80057ca:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (0x02 <<RCC_CFGR_PLLSRC_Pos);
 80057cc:	2180      	movs	r1, #128	; 0x80
 80057ce:	6850      	ldr	r0, [r2, #4]
 80057d0:	0249      	lsls	r1, r1, #9
 80057d2:	4301      	orrs	r1, r0
 80057d4:	6051      	str	r1, [r2, #4]
    RCC->CFGR2 = 0x00000000;
 80057d6:	2100      	movs	r1, #0
 80057d8:	62d1      	str	r1, [r2, #44]	; 0x2c
    RCC->CFGR &= ~RCC_CFGR_PLLMUL_Msk;
 80057da:	6851      	ldr	r1, [r2, #4]
 80057dc:	4878      	ldr	r0, [pc, #480]	; (80059c0 <main+0x22c>)
 80057de:	4001      	ands	r1, r0
 80057e0:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (0x04 <<RCC_CFGR_PLLMUL_Pos);
 80057e2:	2180      	movs	r1, #128	; 0x80
 80057e4:	6850      	ldr	r0, [r2, #4]
 80057e6:	0349      	lsls	r1, r1, #13
 80057e8:	4301      	orrs	r1, r0
 80057ea:	6051      	str	r1, [r2, #4]
    RCC-> CR |= RCC_CR_PLLON;
 80057ec:	2180      	movs	r1, #128	; 0x80
 80057ee:	6810      	ldr	r0, [r2, #0]
 80057f0:	0449      	lsls	r1, r1, #17
 80057f2:	4301      	orrs	r1, r0
        PLL_Status = RCC->CR & RCC_CR_PLLRDY_Msk;
 80057f4:	2080      	movs	r0, #128	; 0x80
    RCC-> CR |= RCC_CR_PLLON;
 80057f6:	6011      	str	r1, [r2, #0]
        PLL_Status = RCC->CR & RCC_CR_PLLRDY_Msk;
 80057f8:	0480      	lsls	r0, r0, #18
 80057fa:	e001      	b.n	8005800 <main+0x6c>
    } while ((PLL_Status == 0) && (timeout > 0));
 80057fc:	2b00      	cmp	r3, #0
 80057fe:	d003      	beq.n	8005808 <main+0x74>
        PLL_Status = RCC->CR & RCC_CR_PLLRDY_Msk;
 8005800:	6811      	ldr	r1, [r2, #0]
        timeout--;
 8005802:	3b01      	subs	r3, #1
    } while ((PLL_Status == 0) && (timeout > 0));
 8005804:	4201      	tst	r1, r0
 8005806:	d0f9      	beq.n	80057fc <main+0x68>
    RCC->CFGR &= ~RCC_CFGR_HPRE_Msk;
 8005808:	20f0      	movs	r0, #240	; 0xf0
 800580a:	496a      	ldr	r1, [pc, #424]	; (80059b4 <main+0x220>)
 800580c:	684a      	ldr	r2, [r1, #4]
 800580e:	4382      	bics	r2, r0
 8005810:	604a      	str	r2, [r1, #4]
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8005812:	684a      	ldr	r2, [r1, #4]
    RCC->CFGR &= ~RCC_CFGR_PPRE_Msk;
 8005814:	486b      	ldr	r0, [pc, #428]	; (80059c4 <main+0x230>)
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8005816:	604a      	str	r2, [r1, #4]
    RCC->CFGR &= ~RCC_CFGR_PPRE_Msk;
 8005818:	684a      	ldr	r2, [r1, #4]
 800581a:	4002      	ands	r2, r0
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 800581c:	2011      	movs	r0, #17
    RCC->CFGR &= ~RCC_CFGR_PPRE_Msk;
 800581e:	604a      	str	r2, [r1, #4]
    RCC->CFGR |= RCC_CFGR_PPRE_DIV1;
 8005820:	684a      	ldr	r2, [r1, #4]
 8005822:	604a      	str	r2, [r1, #4]
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 8005824:	4a68      	ldr	r2, [pc, #416]	; (80059c8 <main+0x234>)
 8005826:	6010      	str	r0, [r2, #0]
    RCC->CFGR &= ~RCC_CFGR_SW;
 8005828:	684a      	ldr	r2, [r1, #4]
 800582a:	380e      	subs	r0, #14
 800582c:	4382      	bics	r2, r0
 800582e:	604a      	str	r2, [r1, #4]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8005830:	684a      	ldr	r2, [r1, #4]
 8005832:	3801      	subs	r0, #1
 8005834:	4302      	orrs	r2, r0
 8005836:	604a      	str	r2, [r1, #4]
        SW_Status = (RCC->CFGR & RCC_CFGR_SWS_Msk);
 8005838:	300a      	adds	r0, #10
 800583a:	e001      	b.n	8005840 <main+0xac>
    } while ((SW_Status != RCC_CFGR_SWS_PLL) && (timeout > 0));
 800583c:	2b00      	cmp	r3, #0
 800583e:	d004      	beq.n	800584a <main+0xb6>
        SW_Status = (RCC->CFGR & RCC_CFGR_SWS_Msk);
 8005840:	684a      	ldr	r2, [r1, #4]
        timeout--;
 8005842:	3b01      	subs	r3, #1
        SW_Status = (RCC->CFGR & RCC_CFGR_SWS_Msk);
 8005844:	4002      	ands	r2, r0
    } while ((SW_Status != RCC_CFGR_SWS_PLL) && (timeout > 0));
 8005846:	2a08      	cmp	r2, #8
 8005848:	d1f8      	bne.n	800583c <main+0xa8>
    RCC->CFGR &= ~RCC_CFGR_MCO_Msk;
 800584a:	4b5a      	ldr	r3, [pc, #360]	; (80059b4 <main+0x220>)
 800584c:	495f      	ldr	r1, [pc, #380]	; (80059cc <main+0x238>)
 800584e:	685a      	ldr	r2, [r3, #4]
    GPIOA->MODER &= ~GPIO_MODER_MODER8_Msk;
 8005850:	485f      	ldr	r0, [pc, #380]	; (80059d0 <main+0x23c>)
    RCC->CFGR &= ~RCC_CFGR_MCO_Msk;
 8005852:	400a      	ands	r2, r1
 8005854:	605a      	str	r2, [r3, #4]
    RCC->CFGR |=  RCC_CFGR_MCOSEL_LSE;     // Change here
 8005856:	22c0      	movs	r2, #192	; 0xc0
 8005858:	6859      	ldr	r1, [r3, #4]
 800585a:	0492      	lsls	r2, r2, #18
 800585c:	430a      	orrs	r2, r1
 800585e:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= ~RCC_CFGR_MCOPRE_Msk;
 8005860:	685a      	ldr	r2, [r3, #4]
 8005862:	495c      	ldr	r1, [pc, #368]	; (80059d4 <main+0x240>)
 8005864:	400a      	ands	r2, r1
 8005866:	605a      	str	r2, [r3, #4]
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8005868:	2280      	movs	r2, #128	; 0x80
 800586a:	6959      	ldr	r1, [r3, #20]
 800586c:	0292      	lsls	r2, r2, #10
 800586e:	4311      	orrs	r1, r2
 8005870:	6159      	str	r1, [r3, #20]
    GPIOA->MODER &= ~GPIO_MODER_MODER8_Msk;
 8005872:	2390      	movs	r3, #144	; 0x90
 8005874:	05db      	lsls	r3, r3, #23
 8005876:	6819      	ldr	r1, [r3, #0]
 8005878:	4001      	ands	r1, r0
 800587a:	6019      	str	r1, [r3, #0]
    GPIOA->MODER |= (0x02 <<GPIO_MODER_MODER8_Pos);
 800587c:	6819      	ldr	r1, [r3, #0]
 800587e:	430a      	orrs	r2, r1
    GPIOA->AFR[1] &= ~(0x0000000F);
 8005880:	210f      	movs	r1, #15
    GPIOA->MODER |= (0x02 <<GPIO_MODER_MODER8_Pos);
 8005882:	601a      	str	r2, [r3, #0]
    GPIOA->AFR[1] &= ~(0x0000000F);
 8005884:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005886:	438a      	bics	r2, r1
 8005888:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOA->AFR[1] |=  (0x00000000);
 800588a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800588c:	625a      	str	r2, [r3, #36]	; 0x24
    SystemCoreClockUpdate();
 800588e:	f000 fa17 	bl	8005cc0 <SystemCoreClockUpdate>
	BSP_LED_Init();
 8005892:	f000 f915 	bl	8005ac0 <BSP_LED_Init>
	BSP_Console_Init();
 8005896:	f000 f93d 	bl	8005b14 <BSP_Console_Init>
	vTraceEnable(TRC_START);
 800589a:	2001      	movs	r0, #1
 800589c:	f7fd f944 	bl	8002b28 <vTraceEnable>
	xSem_UART_TC = xSemaphoreCreateBinary();
 80058a0:	2203      	movs	r2, #3
 80058a2:	2100      	movs	r1, #0
 80058a4:	2001      	movs	r0, #1
 80058a6:	f7fa fd3b 	bl	8000320 <xQueueGenericCreate>
 80058aa:	4b4b      	ldr	r3, [pc, #300]	; (80059d8 <main+0x244>)
	xSem_DMA_TC = xSemaphoreCreateBinary();
 80058ac:	2203      	movs	r2, #3
	xSem_UART_TC = xSemaphoreCreateBinary();
 80058ae:	6018      	str	r0, [r3, #0]
	xSem_DMA_TC = xSemaphoreCreateBinary();
 80058b0:	2100      	movs	r1, #0
 80058b2:	2001      	movs	r0, #1
 80058b4:	f7fa fd34 	bl	8000320 <xQueueGenericCreate>
 80058b8:	4b48      	ldr	r3, [pc, #288]	; (80059dc <main+0x248>)
	xSem1 = xSemaphoreCreateBinary();
 80058ba:	2203      	movs	r2, #3
	xSem_DMA_TC = xSemaphoreCreateBinary();
 80058bc:	6018      	str	r0, [r3, #0]
	xSem1 = xSemaphoreCreateBinary();
 80058be:	2100      	movs	r1, #0
 80058c0:	2001      	movs	r0, #1
 80058c2:	f7fa fd2d 	bl	8000320 <xQueueGenericCreate>
 80058c6:	4b46      	ldr	r3, [pc, #280]	; (80059e0 <main+0x24c>)
	xSem2 = xSemaphoreCreateBinary();
 80058c8:	2203      	movs	r2, #3
	xSem1 = xSemaphoreCreateBinary();
 80058ca:	6018      	str	r0, [r3, #0]
	xSem2 = xSemaphoreCreateBinary();
 80058cc:	2100      	movs	r1, #0
 80058ce:	2001      	movs	r0, #1
 80058d0:	f7fa fd26 	bl	8000320 <xQueueGenericCreate>
 80058d4:	4b43      	ldr	r3, [pc, #268]	; (80059e4 <main+0x250>)
	xSem3 = xSemaphoreCreateBinary();
 80058d6:	2203      	movs	r2, #3
	xSem2 = xSemaphoreCreateBinary();
 80058d8:	6018      	str	r0, [r3, #0]
	xSem3 = xSemaphoreCreateBinary();
 80058da:	2100      	movs	r1, #0
 80058dc:	2001      	movs	r0, #1
 80058de:	f7fa fd1f 	bl	8000320 <xQueueGenericCreate>
 80058e2:	4b41      	ldr	r3, [pc, #260]	; (80059e8 <main+0x254>)
	xSemCarton = xSemaphoreCreateBinary();
 80058e4:	2203      	movs	r2, #3
	xSem3 = xSemaphoreCreateBinary();
 80058e6:	6018      	str	r0, [r3, #0]
	xSemCarton = xSemaphoreCreateBinary();
 80058e8:	2100      	movs	r1, #0
 80058ea:	2001      	movs	r0, #1
 80058ec:	f7fa fd18 	bl	8000320 <xQueueGenericCreate>
 80058f0:	4b3e      	ldr	r3, [pc, #248]	; (80059ec <main+0x258>)
	xSemPalette = xSemaphoreCreateBinary();
 80058f2:	2203      	movs	r2, #3
	xSemCarton = xSemaphoreCreateBinary();
 80058f4:	6018      	str	r0, [r3, #0]
	xSemPalette = xSemaphoreCreateBinary();
 80058f6:	2100      	movs	r1, #0
 80058f8:	2001      	movs	r0, #1
 80058fa:	f7fa fd11 	bl	8000320 <xQueueGenericCreate>
 80058fe:	4b3c      	ldr	r3, [pc, #240]	; (80059f0 <main+0x25c>)
	xSemAscenseur = xSemaphoreCreateBinary();
 8005900:	2203      	movs	r2, #3
 8005902:	2100      	movs	r1, #0
	xSemPalette = xSemaphoreCreateBinary();
 8005904:	6018      	str	r0, [r3, #0]
	xSemAscenseur = xSemaphoreCreateBinary();
 8005906:	2001      	movs	r0, #1
 8005908:	f7fa fd0a 	bl	8000320 <xQueueGenericCreate>
 800590c:	4b39      	ldr	r3, [pc, #228]	; (80059f4 <main+0x260>)
 800590e:	6018      	str	r0, [r3, #0]
	xConsoleMutex = xSemaphoreCreateMutex();
 8005910:	2001      	movs	r0, #1
 8005912:	f7fa ffbb 	bl	800088c <xQueueCreateMutex>
 8005916:	4b38      	ldr	r3, [pc, #224]	; (80059f8 <main+0x264>)
	xComQueue = xQueueCreate(10, sizeof(uint32_t*));
 8005918:	2200      	movs	r2, #0
	xConsoleMutex = xSemaphoreCreateMutex();
 800591a:	6018      	str	r0, [r3, #0]
	xComQueue = xQueueCreate(10, sizeof(uint32_t*));
 800591c:	2104      	movs	r1, #4
 800591e:	200a      	movs	r0, #10
 8005920:	f7fa fcfe 	bl	8000320 <xQueueGenericCreate>
 8005924:	4c35      	ldr	r4, [pc, #212]	; (80059fc <main+0x268>)
	xSubcribeQueue = xQueueCreate(10, sizeof(subscribe_message_t*));
 8005926:	2200      	movs	r2, #0
	xComQueue = xQueueCreate(10, sizeof(uint32_t*));
 8005928:	6020      	str	r0, [r4, #0]
	xSubcribeQueue = xQueueCreate(10, sizeof(subscribe_message_t*));
 800592a:	2104      	movs	r1, #4
 800592c:	200a      	movs	r0, #10
 800592e:	f7fa fcf7 	bl	8000320 <xQueueGenericCreate>
 8005932:	4b33      	ldr	r3, [pc, #204]	; (8005a00 <main+0x26c>)
    command.mask = Tapis_Distribution_Cartons_MSK
 8005934:	4a33      	ldr	r2, [pc, #204]	; (8005a04 <main+0x270>)
	xSubcribeQueue = xQueueCreate(10, sizeof(subscribe_message_t*));
 8005936:	6018      	str	r0, [r3, #0]
    command.mask = Tapis_Distribution_Cartons_MSK
 8005938:	4b32      	ldr	r3, [pc, #200]	; (8005a04 <main+0x270>)
    xQueueSendToBack(xComQueue, &message, 0);
 800593a:	6820      	ldr	r0, [r4, #0]
    command.mask = Tapis_Distribution_Cartons_MSK
 800593c:	9204      	str	r2, [sp, #16]
 800593e:	9305      	str	r3, [sp, #20]
    message = &command;
 8005940:	ab04      	add	r3, sp, #16
    xQueueSendToBack(xComQueue, &message, 0);
 8005942:	2200      	movs	r2, #0
    message = &command;
 8005944:	9303      	str	r3, [sp, #12]
    xQueueSendToBack(xComQueue, &message, 0);
 8005946:	a903      	add	r1, sp, #12
 8005948:	2300      	movs	r3, #0
 800594a:	f7fa fd95 	bl	8000478 <xQueueGenericSend>
	xTaskCreate(vTaskPalettiseur, "vTaskPalettiseur", 128, NULL, 3, NULL);
 800594e:	2400      	movs	r4, #0
 8005950:	2303      	movs	r3, #3
 8005952:	2280      	movs	r2, #128	; 0x80
 8005954:	492c      	ldr	r1, [pc, #176]	; (8005a08 <main+0x274>)
 8005956:	9300      	str	r3, [sp, #0]
 8005958:	482c      	ldr	r0, [pc, #176]	; (8005a0c <main+0x278>)
 800595a:	2300      	movs	r3, #0
 800595c:	9401      	str	r4, [sp, #4]
 800595e:	f7fb fe69 	bl	8001634 <xTaskCreate>
	xTaskCreate(vTaskPalette, "vTaskPalette", 128, NULL, 2, NULL);
 8005962:	2302      	movs	r3, #2
 8005964:	2280      	movs	r2, #128	; 0x80
 8005966:	492a      	ldr	r1, [pc, #168]	; (8005a10 <main+0x27c>)
 8005968:	9300      	str	r3, [sp, #0]
 800596a:	482a      	ldr	r0, [pc, #168]	; (8005a14 <main+0x280>)
 800596c:	2300      	movs	r3, #0
 800596e:	9401      	str	r4, [sp, #4]
 8005970:	f7fb fe60 	bl	8001634 <xTaskCreate>
	xTaskCreate(vTaskAscenseur, "vTaskAscenseur", 128, NULL, 4, NULL);
 8005974:	2304      	movs	r3, #4
 8005976:	2280      	movs	r2, #128	; 0x80
 8005978:	4927      	ldr	r1, [pc, #156]	; (8005a18 <main+0x284>)
 800597a:	9300      	str	r3, [sp, #0]
 800597c:	4827      	ldr	r0, [pc, #156]	; (8005a1c <main+0x288>)
 800597e:	2300      	movs	r3, #0
 8005980:	9401      	str	r4, [sp, #4]
 8005982:	f7fb fe57 	bl	8001634 <xTaskCreate>
	xTaskCreate(vTaskRead, "vTaskRead", 256, NULL, 6, NULL);
 8005986:	2306      	movs	r3, #6
 8005988:	2280      	movs	r2, #128	; 0x80
 800598a:	4925      	ldr	r1, [pc, #148]	; (8005a20 <main+0x28c>)
 800598c:	9300      	str	r3, [sp, #0]
 800598e:	0052      	lsls	r2, r2, #1
 8005990:	2300      	movs	r3, #0
 8005992:	4824      	ldr	r0, [pc, #144]	; (8005a24 <main+0x290>)
 8005994:	9401      	str	r4, [sp, #4]
 8005996:	f7fb fe4d 	bl	8001634 <xTaskCreate>
	xTaskCreate(vTaskWrite, "vTaskWrite", 256, NULL, 5, NULL);
 800599a:	2305      	movs	r3, #5
 800599c:	2280      	movs	r2, #128	; 0x80
 800599e:	4922      	ldr	r1, [pc, #136]	; (8005a28 <main+0x294>)
 80059a0:	9300      	str	r3, [sp, #0]
 80059a2:	0052      	lsls	r2, r2, #1
 80059a4:	2300      	movs	r3, #0
 80059a6:	4821      	ldr	r0, [pc, #132]	; (8005a2c <main+0x298>)
 80059a8:	9401      	str	r4, [sp, #4]
 80059aa:	f7fb fe43 	bl	8001634 <xTaskCreate>
	vTaskStartScheduler();
 80059ae:	f7fb ffa1 	bl	80018f4 <vTaskStartScheduler>
	while(1)
 80059b2:	e7fe      	b.n	80059b2 <main+0x21e>
 80059b4:	40021000 	.word	0x40021000
 80059b8:	000f4240 	.word	0x000f4240
 80059bc:	fffe7fff 	.word	0xfffe7fff
 80059c0:	ffc3ffff 	.word	0xffc3ffff
 80059c4:	fffff8ff 	.word	0xfffff8ff
 80059c8:	40022000 	.word	0x40022000
 80059cc:	f0ffffff 	.word	0xf0ffffff
 80059d0:	fffcffff 	.word	0xfffcffff
 80059d4:	8fffffff 	.word	0x8fffffff
 80059d8:	200034c0 	.word	0x200034c0
 80059dc:	200034bc 	.word	0x200034bc
 80059e0:	200034a4 	.word	0x200034a4
 80059e4:	200034a8 	.word	0x200034a8
 80059e8:	200034ac 	.word	0x200034ac
 80059ec:	200034b4 	.word	0x200034b4
 80059f0:	200034b8 	.word	0x200034b8
 80059f4:	200034b0 	.word	0x200034b0
 80059f8:	200034a0 	.word	0x200034a0
 80059fc:	2000349c 	.word	0x2000349c
 8005a00:	200034c4 	.word	0x200034c4
 8005a04:	003c1006 	.word	0x003c1006
 8005a08:	080069e8 	.word	0x080069e8
 8005a0c:	08004d29 	.word	0x08004d29
 8005a10:	080069fc 	.word	0x080069fc
 8005a14:	0800519d 	.word	0x0800519d
 8005a18:	08006a0c 	.word	0x08006a0c
 8005a1c:	08004f1d 	.word	0x08004f1d
 8005a20:	08006a1c 	.word	0x08006a1c
 8005a24:	08005425 	.word	0x08005425
 8005a28:	08006a28 	.word	0x08006a28
 8005a2c:	08005335 	.word	0x08005335

08005a30 <NMI_Handler>:
 * @param  None
 * @retval None
 */
void NMI_Handler(void)
{
}
 8005a30:	4770      	bx	lr
 8005a32:	46c0      	nop			; (mov r8, r8)

08005a34 <HardFault_Handler>:
 * @retval None
 */
void HardFault_Handler(void)
{
	/* Go to infinite loop when Hard Fault exception occurs */
	while (1)
 8005a34:	e7fe      	b.n	8005a34 <HardFault_Handler>
 8005a36:	46c0      	nop			; (mov r8, r8)

08005a38 <USART2_IRQHandler>:
 */

extern xSemaphoreHandle xSem_UART_TC;
void USART2_IRQHandler()
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8005a38:	2300      	movs	r3, #0
	// Test for TXE pending interrupt
	if ((USART2->ISR & USART_ISR_TC) == USART_ISR_TC)
 8005a3a:	2240      	movs	r2, #64	; 0x40
{
 8005a3c:	b500      	push	{lr}
 8005a3e:	b083      	sub	sp, #12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8005a40:	9301      	str	r3, [sp, #4]
	if ((USART2->ISR & USART_ISR_TC) == USART_ISR_TC)
 8005a42:	4b0b      	ldr	r3, [pc, #44]	; (8005a70 <USART2_IRQHandler+0x38>)
 8005a44:	69d9      	ldr	r1, [r3, #28]
 8005a46:	420a      	tst	r2, r1
 8005a48:	d101      	bne.n	8005a4e <USART2_IRQHandler+0x16>

		// Perform a context switch to the waiting task
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
	}

}
 8005a4a:	b003      	add	sp, #12
 8005a4c:	bd00      	pop	{pc}
		USART2->ICR |= USART_ICR_TCCF;
 8005a4e:	6a19      	ldr	r1, [r3, #32]
 8005a50:	430a      	orrs	r2, r1
 8005a52:	621a      	str	r2, [r3, #32]
		xSemaphoreGiveFromISR(xSem_UART_TC, &xHigherPriorityTaskWoken);
 8005a54:	4b07      	ldr	r3, [pc, #28]	; (8005a74 <USART2_IRQHandler+0x3c>)
 8005a56:	a901      	add	r1, sp, #4
 8005a58:	6818      	ldr	r0, [r3, #0]
 8005a5a:	f7fa ffab 	bl	80009b4 <xQueueGiveFromISR>
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 8005a5e:	9b01      	ldr	r3, [sp, #4]
 8005a60:	2b00      	cmp	r3, #0
 8005a62:	d0f2      	beq.n	8005a4a <USART2_IRQHandler+0x12>
 8005a64:	2280      	movs	r2, #128	; 0x80
 8005a66:	4b04      	ldr	r3, [pc, #16]	; (8005a78 <USART2_IRQHandler+0x40>)
 8005a68:	0552      	lsls	r2, r2, #21
 8005a6a:	601a      	str	r2, [r3, #0]
}
 8005a6c:	e7ed      	b.n	8005a4a <USART2_IRQHandler+0x12>
 8005a6e:	46c0      	nop			; (mov r8, r8)
 8005a70:	40004400 	.word	0x40004400
 8005a74:	200034c0 	.word	0x200034c0
 8005a78:	e000ed04 	.word	0xe000ed04

08005a7c <DMA1_Channel4_5_6_7_IRQHandler>:
 */
extern xSemaphoreHandle xSem_DMA_TC;

void DMA1_Channel4_5_6_7_IRQHandler()
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8005a7c:	2300      	movs	r3, #0
{
 8005a7e:	b500      	push	{lr}
 8005a80:	b083      	sub	sp, #12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8005a82:	9301      	str	r3, [sp, #4]
	// Test for Channel 4 Transfer Complete
	if ((DMA1->ISR & DMA_ISR_TCIF4) == DMA_ISR_TCIF4)
 8005a84:	2380      	movs	r3, #128	; 0x80
 8005a86:	4a0b      	ldr	r2, [pc, #44]	; (8005ab4 <DMA1_Channel4_5_6_7_IRQHandler+0x38>)
 8005a88:	019b      	lsls	r3, r3, #6
 8005a8a:	6811      	ldr	r1, [r2, #0]
 8005a8c:	4219      	tst	r1, r3
 8005a8e:	d101      	bne.n	8005a94 <DMA1_Channel4_5_6_7_IRQHandler+0x18>
		xSemaphoreGiveFromISR(xSem_DMA_TC, &xHigherPriorityTaskWoken);

		// Perform a context switch to the waiting task
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
	}
}
 8005a90:	b003      	add	sp, #12
 8005a92:	bd00      	pop	{pc}
		DMA1->IFCR |= DMA_IFCR_CTCIF4;
 8005a94:	6851      	ldr	r1, [r2, #4]
 8005a96:	430b      	orrs	r3, r1
 8005a98:	6053      	str	r3, [r2, #4]
		xSemaphoreGiveFromISR(xSem_DMA_TC, &xHigherPriorityTaskWoken);
 8005a9a:	4b07      	ldr	r3, [pc, #28]	; (8005ab8 <DMA1_Channel4_5_6_7_IRQHandler+0x3c>)
 8005a9c:	a901      	add	r1, sp, #4
 8005a9e:	6818      	ldr	r0, [r3, #0]
 8005aa0:	f7fa ff88 	bl	80009b4 <xQueueGiveFromISR>
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 8005aa4:	9b01      	ldr	r3, [sp, #4]
 8005aa6:	2b00      	cmp	r3, #0
 8005aa8:	d0f2      	beq.n	8005a90 <DMA1_Channel4_5_6_7_IRQHandler+0x14>
 8005aaa:	2280      	movs	r2, #128	; 0x80
 8005aac:	4b03      	ldr	r3, [pc, #12]	; (8005abc <DMA1_Channel4_5_6_7_IRQHandler+0x40>)
 8005aae:	0552      	lsls	r2, r2, #21
 8005ab0:	601a      	str	r2, [r3, #0]
}
 8005ab2:	e7ed      	b.n	8005a90 <DMA1_Channel4_5_6_7_IRQHandler+0x14>
 8005ab4:	40020000 	.word	0x40020000
 8005ab8:	200034bc 	.word	0x200034bc
 8005abc:	e000ed04 	.word	0xe000ed04

08005ac0 <BSP_LED_Init>:
 */

void BSP_LED_Init()
{
	// Enable GPIOA clock
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8005ac0:	2380      	movs	r3, #128	; 0x80
 8005ac2:	4a12      	ldr	r2, [pc, #72]	; (8005b0c <BSP_LED_Init+0x4c>)
 8005ac4:	029b      	lsls	r3, r3, #10
 8005ac6:	6951      	ldr	r1, [r2, #20]
 8005ac8:	430b      	orrs	r3, r1
 8005aca:	6153      	str	r3, [r2, #20]

	// Configure PA5 as output
	GPIOA->MODER &= ~GPIO_MODER_MODER5_Msk;
 8005acc:	2390      	movs	r3, #144	; 0x90
 8005ace:	05db      	lsls	r3, r3, #23
 8005ad0:	681a      	ldr	r2, [r3, #0]
 8005ad2:	490f      	ldr	r1, [pc, #60]	; (8005b10 <BSP_LED_Init+0x50>)
 8005ad4:	400a      	ands	r2, r1
 8005ad6:	601a      	str	r2, [r3, #0]
	GPIOA->MODER |= (0x01 << GPIO_MODER_MODER5_Pos);
 8005ad8:	2280      	movs	r2, #128	; 0x80
 8005ada:	6818      	ldr	r0, [r3, #0]
 8005adc:	00d2      	lsls	r2, r2, #3
 8005ade:	4302      	orrs	r2, r0

	// Configure PA5 as Push-Pull output
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_5;
 8005ae0:	2020      	movs	r0, #32
	GPIOA->MODER |= (0x01 << GPIO_MODER_MODER5_Pos);
 8005ae2:	601a      	str	r2, [r3, #0]
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_5;
 8005ae4:	685a      	ldr	r2, [r3, #4]
 8005ae6:	4382      	bics	r2, r0
 8005ae8:	605a      	str	r2, [r3, #4]

	// Configure PA5 as High-Speed Output
	GPIOA->OSPEEDR &= ~GPIO_OSPEEDR_OSPEEDR5_Msk;
 8005aea:	689a      	ldr	r2, [r3, #8]
 8005aec:	400a      	ands	r2, r1
 8005aee:	609a      	str	r2, [r3, #8]
	GPIOA->OSPEEDR |= (0x03 << GPIO_OSPEEDR_OSPEEDR5_Pos);
 8005af0:	22c0      	movs	r2, #192	; 0xc0
 8005af2:	6898      	ldr	r0, [r3, #8]
 8005af4:	0112      	lsls	r2, r2, #4
 8005af6:	4302      	orrs	r2, r0
 8005af8:	609a      	str	r2, [r3, #8]

	// Disable PA5 Pull-up/Pull-down
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR5_Msk;
 8005afa:	68da      	ldr	r2, [r3, #12]
 8005afc:	400a      	ands	r2, r1
 8005afe:	60da      	str	r2, [r3, #12]

	// Set Initial State OFF
	GPIOA->BSRR |= GPIO_BSRR_BR_5;
 8005b00:	2280      	movs	r2, #128	; 0x80
 8005b02:	6999      	ldr	r1, [r3, #24]
 8005b04:	0392      	lsls	r2, r2, #14
 8005b06:	430a      	orrs	r2, r1
 8005b08:	619a      	str	r2, [r3, #24]
}
 8005b0a:	4770      	bx	lr
 8005b0c:	40021000 	.word	0x40021000
 8005b10:	fffff3ff 	.word	0xfffff3ff

08005b14 <BSP_Console_Init>:

void BSP_Console_Init()
{
	
	// Enable GPIOA clock
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8005b14:	2180      	movs	r1, #128	; 0x80
{
 8005b16:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005b18:	46c6      	mov	lr, r8
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8005b1a:	4b3e      	ldr	r3, [pc, #248]	; (8005c14 <BSP_Console_Init+0x100>)
 8005b1c:	0289      	lsls	r1, r1, #10
 8005b1e:	695a      	ldr	r2, [r3, #20]
{
 8005b20:	b500      	push	{lr}
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8005b22:	430a      	orrs	r2, r1
 8005b24:	615a      	str	r2, [r3, #20]

	// Configure PA2 and PA3 as Alternate function
	GPIOA->MODER &= ~(GPIO_MODER_MODER2_Msk | GPIO_MODER_MODER3_Msk);
 8005b26:	2290      	movs	r2, #144	; 0x90
 8005b28:	24f0      	movs	r4, #240	; 0xf0
 8005b2a:	05d2      	lsls	r2, r2, #23
 8005b2c:	6810      	ldr	r0, [r2, #0]

	// Enable Transfer Complete ISR
	USART2->CR1 |= USART_CR1_TCIE;

	// Enable both Transmitter and Receiver
	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;
 8005b2e:	250c      	movs	r5, #12
	GPIOA->MODER &= ~(GPIO_MODER_MODER2_Msk | GPIO_MODER_MODER3_Msk);
 8005b30:	43a0      	bics	r0, r4
 8005b32:	6010      	str	r0, [r2, #0]
	GPIOA->MODER |= (0x02 << GPIO_MODER_MODER2_Pos) | (0x02 << GPIO_MODER_MODER3_Pos);
 8005b34:	6810      	ldr	r0, [r2, #0]
 8005b36:	3c50      	subs	r4, #80	; 0x50
 8005b38:	4320      	orrs	r0, r4
 8005b3a:	6010      	str	r0, [r2, #0]
	GPIOA->AFR[0] &= ~(0x0000FF00);
 8005b3c:	6a10      	ldr	r0, [r2, #32]
 8005b3e:	4c36      	ldr	r4, [pc, #216]	; (8005c18 <BSP_Console_Init+0x104>)
	 */
	// Reset DMA1 Channel 5 configuration
	DMA1_Channel5->CCR = 0x00000000;

	// Set direction Peripheral -> Memory
	DMA1_Channel5->CCR &= ~DMA_CCR_DIR;
 8005b40:	2710      	movs	r7, #16
	GPIOA->AFR[0] &= ~(0x0000FF00);
 8005b42:	4020      	ands	r0, r4
 8005b44:	6210      	str	r0, [r2, #32]
	GPIOA->AFR[0] |= (0x00001100);
 8005b46:	2088      	movs	r0, #136	; 0x88
 8005b48:	6a14      	ldr	r4, [r2, #32]
 8005b4a:	0140      	lsls	r0, r0, #5
 8005b4c:	4320      	orrs	r0, r4
 8005b4e:	6210      	str	r0, [r2, #32]
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
 8005b50:	69da      	ldr	r2, [r3, #28]
	RCC->CFGR3 &= ~RCC_CFGR3_USART2SW_Msk;
 8005b52:	4c32      	ldr	r4, [pc, #200]	; (8005c1c <BSP_Console_Init+0x108>)
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
 8005b54:	4311      	orrs	r1, r2
 8005b56:	61d9      	str	r1, [r3, #28]
	USART2->CR1 = 0x00000000;
 8005b58:	2100      	movs	r1, #0
 8005b5a:	4a31      	ldr	r2, [pc, #196]	; (8005c20 <BSP_Console_Init+0x10c>)
 8005b5c:	6011      	str	r1, [r2, #0]
	USART2->CR2 = 0x00000000;
 8005b5e:	6051      	str	r1, [r2, #4]
	USART2->CR3 = 0x00000000;
 8005b60:	6091      	str	r1, [r2, #8]
	RCC->CFGR3 &= ~RCC_CFGR3_USART2SW_Msk;
 8005b62:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8005b64:	4020      	ands	r0, r4
 8005b66:	6318      	str	r0, [r3, #48]	; 0x30
	USART2->CR1 &= ~USART_CR1_OVER8;
 8005b68:	6810      	ldr	r0, [r2, #0]
 8005b6a:	4c2e      	ldr	r4, [pc, #184]	; (8005c24 <BSP_Console_Init+0x110>)
 8005b6c:	4020      	ands	r0, r4
 8005b6e:	6010      	str	r0, [r2, #0]
	USART2->BRR = 5000; // 9600 bauds
 8005b70:	482d      	ldr	r0, [pc, #180]	; (8005c28 <BSP_Console_Init+0x114>)
 8005b72:	60d0      	str	r0, [r2, #12]
	USART2->CR3 |= USART_CR3_OVRDIS;
 8005b74:	2080      	movs	r0, #128	; 0x80
 8005b76:	6894      	ldr	r4, [r2, #8]
 8005b78:	0140      	lsls	r0, r0, #5
 8005b7a:	4320      	orrs	r0, r4
 8005b7c:	6090      	str	r0, [r2, #8]
	USART2->CR1 |= USART_CR1_TCIE;
 8005b7e:	2040      	movs	r0, #64	; 0x40
 8005b80:	6814      	ldr	r4, [r2, #0]
 8005b82:	4304      	orrs	r4, r0
 8005b84:	6014      	str	r4, [r2, #0]
	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;
 8005b86:	6814      	ldr	r4, [r2, #0]
 8005b88:	432c      	orrs	r4, r5
 8005b8a:	6014      	str	r4, [r2, #0]
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
 8005b8c:	2401      	movs	r4, #1
 8005b8e:	695d      	ldr	r5, [r3, #20]
 8005b90:	4325      	orrs	r5, r4
 8005b92:	615d      	str	r5, [r3, #20]
	DMA1_Channel5->CCR = 0x00000000;
 8005b94:	4b25      	ldr	r3, [pc, #148]	; (8005c2c <BSP_Console_Init+0x118>)
 8005b96:	6019      	str	r1, [r3, #0]
	DMA1_Channel5->CCR &= ~DMA_CCR_DIR;
 8005b98:	681d      	ldr	r5, [r3, #0]
 8005b9a:	43bd      	bics	r5, r7
 8005b9c:	601d      	str	r5, [r3, #0]

	// Peripheral is USART2 RDR
	DMA1_Channel5->CPAR = (uint32_t)&USART2->RDR;
 8005b9e:	4d24      	ldr	r5, [pc, #144]	; (8005c30 <BSP_Console_Init+0x11c>)
 8005ba0:	609d      	str	r5, [r3, #8]

	// Peripheral data size is 8-bit (byte)
	DMA1_Channel5->CCR |= (0x00 << DMA_CCR_PSIZE_Pos);
 8005ba2:	681d      	ldr	r5, [r3, #0]
 8005ba4:	601d      	str	r5, [r3, #0]

	// Disable auto-increment Peripheral address
	DMA1_Channel5->CCR &= ~DMA_CCR_PINC;
 8005ba6:	681d      	ldr	r5, [r3, #0]
 8005ba8:	4385      	bics	r5, r0
 8005baa:	601d      	str	r5, [r3, #0]

	// Memory is rx_dma_buffer
	DMA1_Channel5->CMAR = (uint32_t)rx_dma_buffer;
 8005bac:	4d21      	ldr	r5, [pc, #132]	; (8005c34 <BSP_Console_Init+0x120>)
 8005bae:	60dd      	str	r5, [r3, #12]

	// Memory data size is 8-bit (byte)
	DMA1_Channel5->CCR |= (0x00 << DMA_CCR_MSIZE_Pos);
 8005bb0:	681d      	ldr	r5, [r3, #0]
 8005bb2:	601d      	str	r5, [r3, #0]

	// Enable auto-increment Memory address
	DMA1_Channel5->CCR |= DMA_CCR_MINC;
 8005bb4:	2580      	movs	r5, #128	; 0x80
 8005bb6:	681e      	ldr	r6, [r3, #0]
 8005bb8:	46a8      	mov	r8, r5
 8005bba:	432e      	orrs	r6, r5
 8005bbc:	601e      	str	r6, [r3, #0]

	// Set Memory Buffer size
	DMA1_Channel5->CNDTR = 14;
 8005bbe:	260e      	movs	r6, #14
 8005bc0:	605e      	str	r6, [r3, #4]

	// DMA mode is circular
	DMA1_Channel5->CCR |= DMA_CCR_CIRC;
 8005bc2:	681e      	ldr	r6, [r3, #0]
 8005bc4:	3d60      	subs	r5, #96	; 0x60
 8005bc6:	432e      	orrs	r6, r5
 8005bc8:	601e      	str	r6, [r3, #0]

	// Enable DMA1 Channel 5
	DMA1_Channel5->CCR |= DMA_CCR_EN;
 8005bca:	681e      	ldr	r6, [r3, #0]
 8005bcc:	4326      	orrs	r6, r4
 8005bce:	601e      	str	r6, [r3, #0]

	// Enable USART2 DMA Request on RX
	USART2->CR3 |= USART_CR3_DMAR;
 8005bd0:	6893      	ldr	r3, [r2, #8]
 8005bd2:	4303      	orrs	r3, r0
 8005bd4:	6093      	str	r3, [r2, #8]
	/*
	 * DMA en transmission TX channel 4
	 */

	// Reset DMA1 Channel 4 configuration
	DMA1_Channel4->CCR = 0x00000000;
 8005bd6:	4b18      	ldr	r3, [pc, #96]	; (8005c38 <BSP_Console_Init+0x124>)
 8005bd8:	6019      	str	r1, [r3, #0]

	// Set direction Memory -> Peripheral
	DMA1_Channel4->CCR |= DMA_CCR_DIR;
 8005bda:	6819      	ldr	r1, [r3, #0]
 8005bdc:	4339      	orrs	r1, r7
 8005bde:	6019      	str	r1, [r3, #0]

	// Peripheral is USART2 TDR
	DMA1_Channel4->CPAR = (uint32_t)&USART2->TDR;
 8005be0:	4916      	ldr	r1, [pc, #88]	; (8005c3c <BSP_Console_Init+0x128>)
 8005be2:	6099      	str	r1, [r3, #8]

	// Peripheral data size is 8-bit (byte)
	DMA1_Channel4->CCR |= (0x00 << DMA_CCR_PSIZE_Pos);
 8005be4:	6819      	ldr	r1, [r3, #0]
 8005be6:	6019      	str	r1, [r3, #0]

	// Disable auto-increment Peripheral address
	DMA1_Channel4->CCR &= ~DMA_CCR_PINC;
 8005be8:	6819      	ldr	r1, [r3, #0]
 8005bea:	4381      	bics	r1, r0

	// Memory data size is 8-bit (byte)
	DMA1_Channel4->CCR |= (0x00 << DMA_CCR_MSIZE_Pos);

	// Enable auto-increment Memory address
	DMA1_Channel4->CCR |= DMA_CCR_MINC;
 8005bec:	4640      	mov	r0, r8
	DMA1_Channel4->CCR &= ~DMA_CCR_PINC;
 8005bee:	6019      	str	r1, [r3, #0]
	DMA1_Channel4->CMAR = (uint32_t)&tx_dma_buffer;
 8005bf0:	4913      	ldr	r1, [pc, #76]	; (8005c40 <BSP_Console_Init+0x12c>)
 8005bf2:	60d9      	str	r1, [r3, #12]
	DMA1_Channel4->CCR |= (0x00 << DMA_CCR_MSIZE_Pos);
 8005bf4:	6819      	ldr	r1, [r3, #0]
 8005bf6:	6019      	str	r1, [r3, #0]
	DMA1_Channel4->CCR |= DMA_CCR_MINC;
 8005bf8:	6819      	ldr	r1, [r3, #0]
 8005bfa:	4301      	orrs	r1, r0
 8005bfc:	6019      	str	r1, [r3, #0]

	// DMA mode is circular disable
	// DMA1_Channel4->CCR &= ~DMA_CCR_CIRC;				AQQQQ

	// Enable DMA TC interrupts
	DMA1_Channel4->CCR |= DMA_CCR_TCIE;
 8005bfe:	6819      	ldr	r1, [r3, #0]
 8005c00:	387e      	subs	r0, #126	; 0x7e
 8005c02:	4301      	orrs	r1, r0
 8005c04:	6019      	str	r1, [r3, #0]

	// Enable USART2
	USART2->CR1 |= USART_CR1_UE;
 8005c06:	6813      	ldr	r3, [r2, #0]
 8005c08:	4323      	orrs	r3, r4
 8005c0a:	6013      	str	r3, [r2, #0]
}
 8005c0c:	bc80      	pop	{r7}
 8005c0e:	46b8      	mov	r8, r7
 8005c10:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005c12:	46c0      	nop			; (mov r8, r8)
 8005c14:	40021000 	.word	0x40021000
 8005c18:	ffff00ff 	.word	0xffff00ff
 8005c1c:	fffcffff 	.word	0xfffcffff
 8005c20:	40004400 	.word	0x40004400
 8005c24:	ffff7fff 	.word	0xffff7fff
 8005c28:	00001388 	.word	0x00001388
 8005c2c:	40020058 	.word	0x40020058
 8005c30:	40004424 	.word	0x40004424
 8005c34:	200034c8 	.word	0x200034c8
 8005c38:	40020044 	.word	0x40020044
 8005c3c:	40004428 	.word	0x40004428
 8005c40:	200034d8 	.word	0x200034d8

08005c44 <FACTORY_IO_Sensors_Get>:
	sstates = 0x00000000;

	sstates |= rx_dma_buffer[1];
	sstates |= (rx_dma_buffer[2] <<8U );
	sstates |= (rx_dma_buffer[3] <<16U);
	sstates |= (rx_dma_buffer[4] <<24U);
 8005c44:	4907      	ldr	r1, [pc, #28]	; (8005c64 <FACTORY_IO_Sensors_Get+0x20>)
 8005c46:	788b      	ldrb	r3, [r1, #2]
 8005c48:	784a      	ldrb	r2, [r1, #1]
 8005c4a:	021b      	lsls	r3, r3, #8
 8005c4c:	4313      	orrs	r3, r2
 8005c4e:	78ca      	ldrb	r2, [r1, #3]
 8005c50:	0412      	lsls	r2, r2, #16
 8005c52:	431a      	orrs	r2, r3
 8005c54:	790b      	ldrb	r3, [r1, #4]
 8005c56:	061b      	lsls	r3, r3, #24
 8005c58:	4313      	orrs	r3, r2

	// Perform logical comparison with mask
	if ((sstates & msk) == 0)
 8005c5a:	4018      	ands	r0, r3
 8005c5c:	1e43      	subs	r3, r0, #1
 8005c5e:	4198      	sbcs	r0, r3

	else
	{
		return 1;
	}
}
 8005c60:	b2c0      	uxtb	r0, r0
 8005c62:	4770      	bx	lr
 8005c64:	200034c8 	.word	0x200034c8

08005c68 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005c68:	480d      	ldr	r0, [pc, #52]	; (8005ca0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005c6a:	4685      	mov	sp, r0
  
/* Call the clock system initialization function.*/
  bl  SystemInit
 8005c6c:	f000 f826 	bl	8005cbc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8005c70:	480c      	ldr	r0, [pc, #48]	; (8005ca4 <LoopForever+0x6>)
  ldr r1, =_edata
 8005c72:	490d      	ldr	r1, [pc, #52]	; (8005ca8 <LoopForever+0xa>)
  ldr r2, =_sidata
 8005c74:	4a0d      	ldr	r2, [pc, #52]	; (8005cac <LoopForever+0xe>)
  movs r3, #0
 8005c76:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8005c78:	e002      	b.n	8005c80 <LoopCopyDataInit>

08005c7a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8005c7a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8005c7c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8005c7e:	3304      	adds	r3, #4

08005c80 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8005c80:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8005c82:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8005c84:	d3f9      	bcc.n	8005c7a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8005c86:	4a0a      	ldr	r2, [pc, #40]	; (8005cb0 <LoopForever+0x12>)
  ldr r4, =_ebss
 8005c88:	4c0a      	ldr	r4, [pc, #40]	; (8005cb4 <LoopForever+0x16>)
  movs r3, #0
 8005c8a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8005c8c:	e001      	b.n	8005c92 <LoopFillZerobss>

08005c8e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8005c8e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005c90:	3204      	adds	r2, #4

08005c92 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8005c92:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8005c94:	d3fb      	bcc.n	8005c8e <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8005c96:	f000 f853 	bl	8005d40 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005c9a:	f7ff fd7b 	bl	8005794 <main>

08005c9e <LoopForever>:

LoopForever:
    b LoopForever
 8005c9e:	e7fe      	b.n	8005c9e <LoopForever>
  ldr   r0, =_estack
 8005ca0:	20004000 	.word	0x20004000
  ldr r0, =_sdata
 8005ca4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8005ca8:	20000018 	.word	0x20000018
  ldr r2, =_sidata
 8005cac:	08006a4c 	.word	0x08006a4c
  ldr r2, =_sbss
 8005cb0:	20000018 	.word	0x20000018
  ldr r4, =_ebss
 8005cb4:	200034e0 	.word	0x200034e0

08005cb8 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005cb8:	e7fe      	b.n	8005cb8 <ADC1_COMP_IRQHandler>
	...

08005cbc <SystemInit>:
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 8005cbc:	4770      	bx	lr
 8005cbe:	46c0      	nop			; (mov r8, r8)

08005cc0 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, predivfactor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8005cc0:	230c      	movs	r3, #12
 8005cc2:	4a16      	ldr	r2, [pc, #88]	; (8005d1c <SystemCoreClockUpdate+0x5c>)
{
 8005cc4:	b570      	push	{r4, r5, r6, lr}
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8005cc6:	6851      	ldr	r1, [r2, #4]
 8005cc8:	400b      	ands	r3, r1

  switch (tmp)
 8005cca:	2b08      	cmp	r3, #8
 8005ccc:	d00a      	beq.n	8005ce4 <SystemCoreClockUpdate+0x24>
 8005cce:	4814      	ldr	r0, [pc, #80]	; (8005d20 <SystemCoreClockUpdate+0x60>)
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8005cd0:	4b12      	ldr	r3, [pc, #72]	; (8005d1c <SystemCoreClockUpdate+0x5c>)
 8005cd2:	4a14      	ldr	r2, [pc, #80]	; (8005d24 <SystemCoreClockUpdate+0x64>)
 8005cd4:	685b      	ldr	r3, [r3, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 8005cd6:	4914      	ldr	r1, [pc, #80]	; (8005d28 <SystemCoreClockUpdate+0x68>)
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8005cd8:	061b      	lsls	r3, r3, #24
 8005cda:	0f1b      	lsrs	r3, r3, #28
 8005cdc:	5cd3      	ldrb	r3, [r2, r3]
  SystemCoreClock >>= tmp;
 8005cde:	40d8      	lsrs	r0, r3
 8005ce0:	6008      	str	r0, [r1, #0]
}
 8005ce2:	bd70      	pop	{r4, r5, r6, pc}
      pllmull = ( pllmull >> 18) + 2;
 8005ce4:	210f      	movs	r1, #15
      pllmull = RCC->CFGR & RCC_CFGR_PLLMUL;
 8005ce6:	6850      	ldr	r0, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8005ce8:	6853      	ldr	r3, [r2, #4]
      predivfactor = (RCC->CFGR2 & RCC_CFGR2_PREDIV) + 1;
 8005cea:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8005cec:	25c0      	movs	r5, #192	; 0xc0
      pllmull = ( pllmull >> 18) + 2;
 8005cee:	0c80      	lsrs	r0, r0, #18
 8005cf0:	4008      	ands	r0, r1
      predivfactor = (RCC->CFGR2 & RCC_CFGR2_PREDIV) + 1;
 8005cf2:	4011      	ands	r1, r2
      if (pllsource == RCC_CFGR_PLLSRC_HSE_PREDIV)
 8005cf4:	2280      	movs	r2, #128	; 0x80
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8005cf6:	026d      	lsls	r5, r5, #9
 8005cf8:	402b      	ands	r3, r5
      pllmull = ( pllmull >> 18) + 2;
 8005cfa:	1c84      	adds	r4, r0, #2
      predivfactor = (RCC->CFGR2 & RCC_CFGR2_PREDIV) + 1;
 8005cfc:	3101      	adds	r1, #1
      if (pllsource == RCC_CFGR_PLLSRC_HSE_PREDIV)
 8005cfe:	0252      	lsls	r2, r2, #9
 8005d00:	4293      	cmp	r3, r2
 8005d02:	d001      	beq.n	8005d08 <SystemCoreClockUpdate+0x48>
      else if (pllsource == RCC_CFGR_PLLSRC_HSI48_PREDIV)
 8005d04:	42ab      	cmp	r3, r5
 8005d06:	d004      	beq.n	8005d12 <SystemCoreClockUpdate+0x52>
        SystemCoreClock = (HSI_VALUE/predivfactor) * pllmull;
 8005d08:	4805      	ldr	r0, [pc, #20]	; (8005d20 <SystemCoreClockUpdate+0x60>)
 8005d0a:	f7fa f9fd 	bl	8000108 <__udivsi3>
 8005d0e:	4360      	muls	r0, r4
 8005d10:	e7de      	b.n	8005cd0 <SystemCoreClockUpdate+0x10>
        SystemCoreClock = (HSI48_VALUE/predivfactor) * pllmull;
 8005d12:	4806      	ldr	r0, [pc, #24]	; (8005d2c <SystemCoreClockUpdate+0x6c>)
 8005d14:	f7fa f9f8 	bl	8000108 <__udivsi3>
 8005d18:	4360      	muls	r0, r4
 8005d1a:	e7d9      	b.n	8005cd0 <SystemCoreClockUpdate+0x10>
 8005d1c:	40021000 	.word	0x40021000
 8005d20:	007a1200 	.word	0x007a1200
 8005d24:	08006a34 	.word	0x08006a34
 8005d28:	20000014 	.word	0x20000014
 8005d2c:	02dc6c00 	.word	0x02dc6c00

08005d30 <memset>:
 8005d30:	0003      	movs	r3, r0
 8005d32:	1882      	adds	r2, r0, r2
 8005d34:	4293      	cmp	r3, r2
 8005d36:	d100      	bne.n	8005d3a <memset+0xa>
 8005d38:	4770      	bx	lr
 8005d3a:	7019      	strb	r1, [r3, #0]
 8005d3c:	3301      	adds	r3, #1
 8005d3e:	e7f9      	b.n	8005d34 <memset+0x4>

08005d40 <__libc_init_array>:
 8005d40:	b570      	push	{r4, r5, r6, lr}
 8005d42:	2600      	movs	r6, #0
 8005d44:	4c0c      	ldr	r4, [pc, #48]	; (8005d78 <__libc_init_array+0x38>)
 8005d46:	4d0d      	ldr	r5, [pc, #52]	; (8005d7c <__libc_init_array+0x3c>)
 8005d48:	1b64      	subs	r4, r4, r5
 8005d4a:	10a4      	asrs	r4, r4, #2
 8005d4c:	42a6      	cmp	r6, r4
 8005d4e:	d109      	bne.n	8005d64 <__libc_init_array+0x24>
 8005d50:	2600      	movs	r6, #0
 8005d52:	f000 f823 	bl	8005d9c <_init>
 8005d56:	4c0a      	ldr	r4, [pc, #40]	; (8005d80 <__libc_init_array+0x40>)
 8005d58:	4d0a      	ldr	r5, [pc, #40]	; (8005d84 <__libc_init_array+0x44>)
 8005d5a:	1b64      	subs	r4, r4, r5
 8005d5c:	10a4      	asrs	r4, r4, #2
 8005d5e:	42a6      	cmp	r6, r4
 8005d60:	d105      	bne.n	8005d6e <__libc_init_array+0x2e>
 8005d62:	bd70      	pop	{r4, r5, r6, pc}
 8005d64:	00b3      	lsls	r3, r6, #2
 8005d66:	58eb      	ldr	r3, [r5, r3]
 8005d68:	4798      	blx	r3
 8005d6a:	3601      	adds	r6, #1
 8005d6c:	e7ee      	b.n	8005d4c <__libc_init_array+0xc>
 8005d6e:	00b3      	lsls	r3, r6, #2
 8005d70:	58eb      	ldr	r3, [r5, r3]
 8005d72:	4798      	blx	r3
 8005d74:	3601      	adds	r6, #1
 8005d76:	e7f2      	b.n	8005d5e <__libc_init_array+0x1e>
 8005d78:	08006a44 	.word	0x08006a44
 8005d7c:	08006a44 	.word	0x08006a44
 8005d80:	08006a48 	.word	0x08006a48
 8005d84:	08006a44 	.word	0x08006a44

08005d88 <memcpy>:
 8005d88:	2300      	movs	r3, #0
 8005d8a:	b510      	push	{r4, lr}
 8005d8c:	429a      	cmp	r2, r3
 8005d8e:	d100      	bne.n	8005d92 <memcpy+0xa>
 8005d90:	bd10      	pop	{r4, pc}
 8005d92:	5ccc      	ldrb	r4, [r1, r3]
 8005d94:	54c4      	strb	r4, [r0, r3]
 8005d96:	3301      	adds	r3, #1
 8005d98:	e7f8      	b.n	8005d8c <memcpy+0x4>
	...

08005d9c <_init>:
 8005d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005d9e:	46c0      	nop			; (mov r8, r8)
 8005da0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005da2:	bc08      	pop	{r3}
 8005da4:	469e      	mov	lr, r3
 8005da6:	4770      	bx	lr

08005da8 <_fini>:
 8005da8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005daa:	46c0      	nop			; (mov r8, r8)
 8005dac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005dae:	bc08      	pop	{r3}
 8005db0:	469e      	mov	lr, r3
 8005db2:	4770      	bx	lr
